{"ast":null,"code":"/* esri-leaflet-geocoder - v2.3.3 - Fri May 29 2020 15:01:40 GMT-0500 (Central Daylight Time)\n * Copyright (c) 2020 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('leaflet'), require('esri-leaflet')) : typeof define === 'function' && define.amd ? define(['exports', 'leaflet', 'esri-leaflet'], factory) : (global = global || self, factory((global.L = global.L || {}, global.L.esri = global.L.esri || {}, global.L.esri.Geocoding = {}), global.L, global.L.esri));\n})(this, function (exports, leaflet, esriLeaflet) {\n  'use strict';\n\n  var version = \"2.3.3\";\n  var WorldGeocodingServiceUrl = 'https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/';\n  var Geocode = esriLeaflet.Task.extend({\n    path: 'findAddressCandidates',\n    params: {\n      outSr: 4326,\n      forStorage: false,\n      outFields: '*',\n      maxLocations: 20\n    },\n    setters: {\n      'address': 'address',\n      'neighborhood': 'neighborhood',\n      'city': 'city',\n      'subregion': 'subregion',\n      'region': 'region',\n      'postal': 'postal',\n      'country': 'country',\n      'text': 'singleLine',\n      'category': 'category',\n      'token': 'token',\n      'key': 'magicKey',\n      'fields': 'outFields',\n      'forStorage': 'forStorage',\n      'maxLocations': 'maxLocations',\n      // World Geocoding Service (only works with singleLine)\n      'countries': 'sourceCountry'\n    },\n    initialize: function initialize(options) {\n      options = options || {};\n      options.url = options.url || WorldGeocodingServiceUrl;\n      esriLeaflet.Task.prototype.initialize.call(this, options);\n    },\n    within: function within(bounds) {\n      bounds = leaflet.latLngBounds(bounds);\n      this.params.searchExtent = esriLeaflet.Util.boundsToExtent(bounds);\n      return this;\n    },\n    nearby: function nearby(coords, radius) {\n      var centroid = leaflet.latLng(coords);\n      this.params.location = centroid.lng + ',' + centroid.lat;\n      this.params.distance = Math.min(Math.max(radius, 2000), 50000);\n      return this;\n    },\n    run: function run(callback, context) {\n      if (this.options.customParam) {\n        this.params[this.options.customParam] = this.params.singleLine;\n        delete this.params.singleLine;\n      }\n\n      return this.request(function (error, response) {\n        var processor = this._processGeocoderResponse;\n        var results = !error ? processor(response) : undefined;\n        callback.call(context, error, {\n          results: results\n        }, response);\n      }, this);\n    },\n    _processGeocoderResponse: function _processGeocoderResponse(response) {\n      var results = [];\n\n      for (var i = 0; i < response.candidates.length; i++) {\n        var candidate = response.candidates[i];\n\n        if (candidate.extent) {\n          var bounds = esriLeaflet.Util.extentToBounds(candidate.extent);\n        }\n\n        results.push({\n          text: candidate.address,\n          bounds: bounds,\n          score: candidate.score,\n          latlng: leaflet.latLng(candidate.location.y, candidate.location.x),\n          properties: candidate.attributes\n        });\n      }\n\n      return results;\n    }\n  });\n\n  function _geocode(options) {\n    return new Geocode(options);\n  }\n\n  var ReverseGeocode = esriLeaflet.Task.extend({\n    path: 'reverseGeocode',\n    params: {\n      outSR: 4326,\n      returnIntersection: false\n    },\n    setters: {\n      'distance': 'distance',\n      'language': 'langCode',\n      'intersection': 'returnIntersection'\n    },\n    initialize: function initialize(options) {\n      options = options || {};\n      options.url = options.url || WorldGeocodingServiceUrl;\n      esriLeaflet.Task.prototype.initialize.call(this, options);\n    },\n    latlng: function latlng(coords) {\n      var centroid = leaflet.latLng(coords);\n      this.params.location = centroid.lng + ',' + centroid.lat;\n      return this;\n    },\n    run: function run(callback, context) {\n      return this.request(function (error, response) {\n        var result;\n\n        if (!error) {\n          result = {\n            latlng: leaflet.latLng(response.location.y, response.location.x),\n            address: response.address\n          };\n        } else {\n          result = undefined;\n        }\n\n        callback.call(context, error, result, response);\n      }, this);\n    }\n  });\n\n  function reverseGeocode(options) {\n    return new ReverseGeocode(options);\n  }\n\n  var Suggest = esriLeaflet.Task.extend({\n    path: 'suggest',\n    params: {},\n    setters: {\n      text: 'text',\n      category: 'category',\n      countries: 'countryCode',\n      maxSuggestions: 'maxSuggestions'\n    },\n    initialize: function initialize(options) {\n      options = options || {};\n\n      if (!options.url) {\n        options.url = WorldGeocodingServiceUrl;\n        options.supportsSuggest = true;\n      }\n\n      esriLeaflet.Task.prototype.initialize.call(this, options);\n    },\n    within: function within(bounds) {\n      bounds = leaflet.latLngBounds(bounds);\n      bounds = bounds.pad(0.5);\n      var center = bounds.getCenter();\n      var ne = bounds.getNorthWest();\n      this.params.location = center.lng + ',' + center.lat;\n      this.params.distance = Math.min(Math.max(center.distanceTo(ne), 2000), 50000);\n      this.params.searchExtent = esriLeaflet.Util.boundsToExtent(bounds);\n      return this;\n    },\n    nearby: function nearby(coords, radius) {\n      var centroid = leaflet.latLng(coords);\n      this.params.location = centroid.lng + ',' + centroid.lat;\n      this.params.distance = Math.min(Math.max(radius, 2000), 50000);\n      return this;\n    },\n    run: function run(callback, context) {\n      if (this.options.supportsSuggest) {\n        return this.request(function (error, response) {\n          callback.call(context, error, response, response);\n        }, this);\n      } else {\n        console.warn('this geocoding service does not support asking for suggestions');\n      }\n    }\n  });\n\n  function _suggest(options) {\n    return new Suggest(options);\n  }\n\n  var GeocodeService = esriLeaflet.Service.extend({\n    initialize: function initialize(options) {\n      options = options || {};\n\n      if (options.url) {\n        esriLeaflet.Service.prototype.initialize.call(this, options);\n\n        this._confirmSuggestSupport();\n      } else {\n        options.url = WorldGeocodingServiceUrl;\n        options.supportsSuggest = true;\n        esriLeaflet.Service.prototype.initialize.call(this, options);\n      }\n    },\n    geocode: function geocode() {\n      return _geocode(this);\n    },\n    reverse: function reverse() {\n      return reverseGeocode(this);\n    },\n    suggest: function suggest() {\n      // requires either the Esri World Geocoding Service or a <10.3 ArcGIS Server Geocoding Service that supports suggest.\n      return _suggest(this);\n    },\n    _confirmSuggestSupport: function _confirmSuggestSupport() {\n      this.metadata(function (error, response) {\n        if (error) {\n          return;\n        } // pre 10.3 geocoding services dont list capabilities (and dont support maxLocations)\n        // only SOME individual services have been configured to support asking for suggestions\n\n\n        if (!response.capabilities) {\n          this.options.supportsSuggest = false;\n        } else if (response.capabilities.indexOf('Suggest') > -1) {\n          this.options.supportsSuggest = true;\n        } else {\n          this.options.supportsSuggest = false;\n        } // whether the service supports suggest or not, utilize the metadata response to determine the appropriate parameter name for single line geocoding requests\n\n\n        this.options.customParam = response.singleLineAddressField.name;\n      }, this);\n    }\n  });\n\n  function geocodeService(options) {\n    return new GeocodeService(options);\n  }\n\n  var GeosearchCore = leaflet.Evented.extend({\n    options: {\n      zoomToResult: true,\n      useMapBounds: 12,\n      searchBounds: null\n    },\n    initialize: function initialize(control, options) {\n      leaflet.Util.setOptions(this, options);\n      this._control = control;\n\n      if (!options || !options.providers || !options.providers.length) {\n        throw new Error('You must specify at least one provider');\n      }\n\n      this._providers = options.providers;\n    },\n    _geocode: function _geocode(text, key, provider) {\n      var activeRequests = 0;\n      var allResults = [];\n      var bounds;\n      var callback = leaflet.Util.bind(function (error, results) {\n        activeRequests--;\n\n        if (error) {\n          return;\n        }\n\n        if (results) {\n          allResults = allResults.concat(results);\n        }\n\n        if (activeRequests <= 0) {\n          bounds = this._boundsFromResults(allResults);\n          this.fire('results', {\n            results: allResults,\n            bounds: bounds,\n            latlng: bounds ? bounds.getCenter() : undefined,\n            text: text\n          }, true);\n\n          if (this.options.zoomToResult && bounds) {\n            this._control._map.fitBounds(bounds);\n          }\n\n          this.fire('load');\n        }\n      }, this);\n\n      if (key) {\n        activeRequests++;\n        provider.results(text, key, this._searchBounds(), callback);\n      } else {\n        for (var i = 0; i < this._providers.length; i++) {\n          activeRequests++;\n\n          this._providers[i].results(text, key, this._searchBounds(), callback);\n        }\n      }\n    },\n    _suggest: function _suggest(text) {\n      var activeRequests = this._providers.length;\n      var suggestionsLength = 0;\n      var createCallback = leaflet.Util.bind(function (text, provider) {\n        return leaflet.Util.bind(function (error, suggestions) {\n          activeRequests = activeRequests - 1;\n          suggestionsLength += suggestions.length;\n\n          if (error) {\n            // an error occurred for one of the providers' suggest requests\n            this._control._clearProviderSuggestions(provider); // perform additional cleanup when all requests are finished\n\n\n            this._control._finalizeSuggestions(activeRequests, suggestionsLength);\n\n            return;\n          }\n\n          if (suggestions.length) {\n            for (var i = 0; i < suggestions.length; i++) {\n              suggestions[i].provider = provider;\n            }\n          } else {\n            // we still need to update the UI\n            this._control._renderSuggestions(suggestions);\n          }\n\n          if (provider._lastRender !== text) {\n            this._control._clearProviderSuggestions(provider);\n          }\n\n          if (suggestions.length && this._control._input.value === text) {\n            provider._lastRender = text;\n\n            this._control._renderSuggestions(suggestions);\n          } // perform additional cleanup when all requests are finished\n\n\n          this._control._finalizeSuggestions(activeRequests, suggestionsLength);\n        }, this);\n      }, this);\n      this._pendingSuggestions = [];\n\n      for (var i = 0; i < this._providers.length; i++) {\n        var provider = this._providers[i];\n        var request = provider.suggestions(text, this._searchBounds(), createCallback(text, provider));\n\n        this._pendingSuggestions.push(request);\n      }\n    },\n    _searchBounds: function _searchBounds() {\n      if (this.options.searchBounds !== null) {\n        return this.options.searchBounds;\n      }\n\n      if (this.options.useMapBounds === false) {\n        return null;\n      }\n\n      if (this.options.useMapBounds === true) {\n        return this._control._map.getBounds();\n      }\n\n      if (this.options.useMapBounds <= this._control._map.getZoom()) {\n        return this._control._map.getBounds();\n      }\n\n      return null;\n    },\n    _boundsFromResults: function _boundsFromResults(results) {\n      if (!results.length) {\n        return;\n      }\n\n      var nullIsland = leaflet.latLngBounds([0, 0], [0, 0]);\n      var resultBounds = [];\n      var resultLatlngs = []; // collect the bounds and center of each result\n\n      for (var i = results.length - 1; i >= 0; i--) {\n        var result = results[i];\n        resultLatlngs.push(result.latlng); // make sure bounds are valid and not 0,0. sometimes bounds are incorrect or not present\n\n        if (result.bounds && result.bounds.isValid() && !result.bounds.equals(nullIsland)) {\n          resultBounds.push(result.bounds);\n        }\n      } // form a bounds object containing all center points\n\n\n      var bounds = leaflet.latLngBounds(resultLatlngs); // and extend it to contain all bounds objects\n\n      for (var j = 0; j < resultBounds.length; j++) {\n        bounds.extend(resultBounds[j]);\n      }\n\n      return bounds;\n    },\n    _getAttribution: function _getAttribution() {\n      var attribs = [];\n      var providers = this._providers;\n\n      for (var i = 0; i < providers.length; i++) {\n        if (providers[i].options.attribution) {\n          attribs.push(providers[i].options.attribution);\n        }\n      }\n\n      return attribs.join(', ');\n    }\n  });\n\n  function geosearchCore(control, options) {\n    return new GeosearchCore(control, options);\n  }\n\n  var ArcgisOnlineProvider = GeocodeService.extend({\n    options: {\n      label: 'Places and Addresses',\n      maxResults: 5\n    },\n    suggestions: function suggestions(text, bounds, callback) {\n      var request = this.suggest().text(text);\n\n      if (bounds) {\n        request.within(bounds);\n      }\n\n      if (this.options.countries) {\n        request.countries(this.options.countries);\n      }\n\n      if (this.options.categories) {\n        request.category(this.options.categories);\n      } // 15 is the maximum number of suggestions that can be returned\n\n\n      request.maxSuggestions(this.options.maxResults);\n      return request.run(function (error, results, response) {\n        var suggestions = [];\n\n        if (!error) {\n          while (response.suggestions.length && suggestions.length <= this.options.maxResults - 1) {\n            var suggestion = response.suggestions.shift();\n\n            if (!suggestion.isCollection) {\n              suggestions.push({\n                text: suggestion.text,\n                unformattedText: suggestion.text,\n                magicKey: suggestion.magicKey\n              });\n            }\n          }\n        }\n\n        callback(error, suggestions);\n      }, this);\n    },\n    results: function results(text, key, bounds, callback) {\n      var request = this.geocode().text(text);\n\n      if (key) {\n        request.key(key);\n      } // in the future Address/StreetName geocoding requests that include a magicKey will always only return one match\n\n\n      request.maxLocations(this.options.maxResults);\n\n      if (bounds) {\n        request.within(bounds);\n      }\n\n      if (this.options.forStorage) {\n        request.forStorage(true);\n      }\n\n      if (this.options.countries) {\n        request.countries(this.options.countries);\n      }\n\n      if (this.options.categories) {\n        request.category(this.options.categories);\n      }\n\n      return request.run(function (error, response) {\n        callback(error, response.results);\n      }, this);\n    }\n  });\n\n  function arcgisOnlineProvider(options) {\n    return new ArcgisOnlineProvider(options);\n  }\n\n  var Geosearch = leaflet.Control.extend({\n    includes: leaflet.Evented.prototype,\n    options: {\n      position: 'topleft',\n      collapseAfterResult: true,\n      expanded: false,\n      allowMultipleResults: true,\n      placeholder: 'Search for places or addresses',\n      title: 'Location Search'\n    },\n    initialize: function initialize(options) {\n      leaflet.Util.setOptions(this, options);\n\n      if (!options || !options.providers || !options.providers.length) {\n        if (!options) {\n          options = {};\n        }\n\n        options.providers = [arcgisOnlineProvider()];\n      } // instantiate the underlying class and pass along options\n\n\n      this._geosearchCore = geosearchCore(this, options);\n      this._geosearchCore._providers = options.providers; // bubble each providers events to the control\n\n      this._geosearchCore.addEventParent(this);\n\n      for (var i = 0; i < this._geosearchCore._providers.length; i++) {\n        this._geosearchCore._providers[i].addEventParent(this);\n      }\n\n      this._geosearchCore._pendingSuggestions = [];\n      leaflet.Control.prototype.initialize.call(this, options);\n    },\n    _renderSuggestions: function _renderSuggestions(suggestions) {\n      var currentGroup;\n\n      if (suggestions.length > 0) {\n        this._suggestions.style.display = 'block';\n      }\n\n      var list;\n      var header;\n      var suggestionTextArray = [];\n\n      for (var i = 0; i < suggestions.length; i++) {\n        var suggestion = suggestions[i];\n\n        if (!header && this._geosearchCore._providers.length > 1 && currentGroup !== suggestion.provider.options.label) {\n          header = leaflet.DomUtil.create('div', 'geocoder-control-header', suggestion.provider._contentsElement);\n          header.textContent = suggestion.provider.options.label;\n          header.innerText = suggestion.provider.options.label;\n          currentGroup = suggestion.provider.options.label;\n        }\n\n        if (!list) {\n          list = leaflet.DomUtil.create('ul', 'geocoder-control-list', suggestion.provider._contentsElement);\n        }\n\n        if (suggestionTextArray.indexOf(suggestion.text) === -1) {\n          var suggestionItem = leaflet.DomUtil.create('li', 'geocoder-control-suggestion', list);\n          suggestionItem.innerHTML = suggestion.text;\n          suggestionItem.provider = suggestion.provider;\n          suggestionItem['data-magic-key'] = suggestion.magicKey;\n          suggestionItem.unformattedText = suggestion.unformattedText;\n        } else {\n          for (var j = 0; j < list.childNodes.length; j++) {\n            // if the same text already appears in the list of suggestions, append an additional ObjectID to its magicKey instead\n            if (list.childNodes[j].innerHTML === suggestion.text) {\n              list.childNodes[j]['data-magic-key'] += ',' + suggestion.magicKey;\n            }\n          }\n        }\n\n        suggestionTextArray.push(suggestion.text);\n      } // when the geocoder position is either \"topleft\" or \"topright\":\n      // set the maxHeight of the suggestions box to:\n      //  map height\n      //  - suggestions offset (distance from top of suggestions to top of control)\n      //  - control offset (distance from top of control to top of map)\n      //  - 10 (extra padding)\n\n\n      if (this.getPosition().indexOf('top') > -1) {\n        this._suggestions.style.maxHeight = this._map.getSize().y - this._suggestions.offsetTop - this._wrapper.offsetTop - 10 + 'px';\n      } // when the geocoder position is either \"bottomleft\" or \"bottomright\":\n      // 1. set the maxHeight of the suggestions box to:\n      //  map height\n      //  - corner control container offsetHeight (height of container of bottom corner)\n      //  - control offsetHeight (height of geocoder control wrapper, the main expandable button)\n      // 2. to move it up, set the top of the suggestions box to:\n      //  negative offsetHeight of suggestions box (its own negative height now that it has children elements\n      //  - control offsetHeight (height of geocoder control wrapper, the main expandable button)\n      //  + 20 (extra spacing)\n\n\n      if (this.getPosition().indexOf('bottom') > -1) {\n        this._setSuggestionsBottomPosition();\n      }\n    },\n    _setSuggestionsBottomPosition: function _setSuggestionsBottomPosition() {\n      this._suggestions.style.maxHeight = this._map.getSize().y - this._map._controlCorners[this.getPosition()].offsetHeight - this._wrapper.offsetHeight + 'px';\n      this._suggestions.style.top = -this._suggestions.offsetHeight - this._wrapper.offsetHeight + 20 + 'px';\n    },\n    _boundsFromResults: function _boundsFromResults(results) {\n      if (!results.length) {\n        return;\n      }\n\n      var nullIsland = leaflet.latLngBounds([0, 0], [0, 0]);\n      var resultBounds = [];\n      var resultLatlngs = []; // collect the bounds and center of each result\n\n      for (var i = results.length - 1; i >= 0; i--) {\n        var result = results[i];\n        resultLatlngs.push(result.latlng); // make sure bounds are valid and not 0,0. sometimes bounds are incorrect or not present\n\n        if (result.bounds && result.bounds.isValid() && !result.bounds.equals(nullIsland)) {\n          resultBounds.push(result.bounds);\n        }\n      } // form a bounds object containing all center points\n\n\n      var bounds = leaflet.latLngBounds(resultLatlngs); // and extend it to contain all bounds objects\n\n      for (var j = 0; j < resultBounds.length; j++) {\n        bounds.extend(resultBounds[j]);\n      }\n\n      return bounds;\n    },\n    clear: function clear() {\n      this._clearAllSuggestions();\n\n      if (this.options.collapseAfterResult) {\n        this._input.value = '';\n        this._lastValue = '';\n        this._input.placeholder = '';\n        leaflet.DomUtil.removeClass(this._wrapper, 'geocoder-control-expanded');\n      }\n\n      if (!this._map.scrollWheelZoom.enabled() && this._map.options.scrollWheelZoom) {\n        this._map.scrollWheelZoom.enable();\n      }\n    },\n    _clearAllSuggestions: function _clearAllSuggestions() {\n      this._suggestions.style.display = 'none';\n\n      for (var i = 0; i < this.options.providers.length; i++) {\n        this._clearProviderSuggestions(this.options.providers[i]);\n      }\n    },\n    _clearProviderSuggestions: function _clearProviderSuggestions(provider) {\n      provider._contentsElement.innerHTML = '';\n    },\n    _finalizeSuggestions: function _finalizeSuggestions(activeRequests, suggestionsLength) {\n      // check if all requests are finished to remove the loading indicator\n      if (!activeRequests) {\n        leaflet.DomUtil.removeClass(this._input, 'geocoder-control-loading'); // when the geocoder position is either \"bottomleft\" or \"bottomright\",\n        // it is necessary in some cases to recalculate the maxHeight and top values of the this._suggestions element,\n        // even though this is also being done after each provider returns their own suggestions\n\n        if (this.getPosition().indexOf('bottom') > -1) {\n          this._setSuggestionsBottomPosition();\n        } // also check if there were 0 total suggest results to clear the parent suggestions element\n        // otherwise its display value may be \"block\" instead of \"none\"\n\n\n        if (!suggestionsLength) {\n          this._clearAllSuggestions();\n        }\n      }\n    },\n    _setupClick: function _setupClick() {\n      leaflet.DomUtil.addClass(this._wrapper, 'geocoder-control-expanded');\n\n      this._input.focus();\n    },\n    disable: function disable() {\n      this._input.disabled = true;\n      leaflet.DomUtil.addClass(this._input, 'geocoder-control-input-disabled');\n      leaflet.DomEvent.removeListener(this._wrapper, 'click', this._setupClick, this);\n    },\n    enable: function enable() {\n      this._input.disabled = false;\n      leaflet.DomUtil.removeClass(this._input, 'geocoder-control-input-disabled');\n      leaflet.DomEvent.addListener(this._wrapper, 'click', this._setupClick, this);\n    },\n    getAttribution: function getAttribution() {\n      var attribs = [];\n\n      for (var i = 0; i < this._providers.length; i++) {\n        if (this._providers[i].options.attribution) {\n          attribs.push(this._providers[i].options.attribution);\n        }\n      }\n\n      return attribs.join(', ');\n    },\n    geocodeSuggestion: function geocodeSuggestion(e) {\n      var suggestionItem = e.target || e.srcElement;\n\n      if (suggestionItem.classList.contains('geocoder-control-suggestions') || suggestionItem.classList.contains('geocoder-control-header')) {\n        return;\n      } // make sure and point at the actual 'geocoder-control-suggestion'\n\n\n      if (suggestionItem.classList.length < 1) {\n        suggestionItem = suggestionItem.parentNode;\n      }\n\n      this._geosearchCore._geocode(suggestionItem.unformattedText, suggestionItem['data-magic-key'], suggestionItem.provider);\n\n      this.clear();\n    },\n    onAdd: function onAdd(map) {\n      // include 'Powered by Esri' in map attribution\n      esriLeaflet.Util.setEsriAttribution(map);\n      this._map = map;\n      this._wrapper = leaflet.DomUtil.create('div', 'geocoder-control');\n      this._input = leaflet.DomUtil.create('input', 'geocoder-control-input leaflet-bar', this._wrapper);\n      this._input.title = this.options.title;\n\n      if (this.options.expanded) {\n        leaflet.DomUtil.addClass(this._wrapper, 'geocoder-control-expanded');\n        this._input.placeholder = this.options.placeholder;\n      } // create the main suggested results container element\n\n\n      this._suggestions = leaflet.DomUtil.create('div', 'geocoder-control-suggestions leaflet-bar', this._wrapper); // create a child contents container element for each provider inside of this._suggestions\n      // to maintain the configured order of providers for suggested results\n\n      for (var i = 0; i < this.options.providers.length; i++) {\n        this.options.providers[i]._contentsElement = leaflet.DomUtil.create('div', null, this._suggestions);\n      }\n\n      var credits = this._geosearchCore._getAttribution();\n\n      if (map.attributionControl) {\n        map.attributionControl.addAttribution(credits);\n      }\n\n      leaflet.DomEvent.addListener(this._input, 'focus', function (e) {\n        this._input.placeholder = this.options.placeholder;\n        leaflet.DomUtil.addClass(this._wrapper, 'geocoder-control-expanded');\n      }, this);\n      leaflet.DomEvent.addListener(this._wrapper, 'click', this._setupClick, this); // make sure both click and touch spawn an address/poi search\n\n      leaflet.DomEvent.addListener(this._suggestions, 'mousedown', this.geocodeSuggestion, this);\n      leaflet.DomEvent.addListener(this._input, 'blur', function (e) {\n        // TODO: this is too greedy and should not \"clear\"\n        // when trying to use the scrollbar or clicking on a non-suggestion item (such as a provider header)\n        this.clear();\n      }, this);\n      leaflet.DomEvent.addListener(this._input, 'keydown', function (e) {\n        var text = (e.target || e.srcElement).value;\n        leaflet.DomUtil.addClass(this._wrapper, 'geocoder-control-expanded');\n\n        var list = this._suggestions.querySelectorAll('.' + 'geocoder-control-suggestion');\n\n        var selected = this._suggestions.querySelectorAll('.' + 'geocoder-control-selected')[0];\n\n        var selectedPosition;\n\n        for (var i = 0; i < list.length; i++) {\n          if (list[i] === selected) {\n            selectedPosition = i;\n            break;\n          }\n        }\n\n        switch (e.keyCode) {\n          case 13:\n            /*\r\n              if an item has been selected, geocode it\r\n              if focus is on the input textbox, geocode only if multiple results are allowed and more than two characters are present, or if a single suggestion is displayed.\r\n              if less than two characters have been typed, abort the geocode\r\n            */\n            if (selected) {\n              this._input.value = selected.innerText;\n\n              this._geosearchCore._geocode(selected.unformattedText, selected['data-magic-key'], selected.provider);\n\n              this.clear();\n            } else if (this.options.allowMultipleResults && text.length >= 2) {\n              this._geosearchCore._geocode(this._input.value, undefined);\n\n              this.clear();\n            } else {\n              if (list.length === 1) {\n                leaflet.DomUtil.addClass(list[0], 'geocoder-control-selected');\n\n                this._geosearchCore._geocode(list[0].innerHTML, list[0]['data-magic-key'], list[0].provider);\n              } else {\n                this.clear();\n\n                this._input.blur();\n              }\n            }\n\n            leaflet.DomEvent.preventDefault(e);\n            break;\n\n          case 38:\n            if (selected) {\n              leaflet.DomUtil.removeClass(selected, 'geocoder-control-selected');\n            }\n\n            var previousItem = list[selectedPosition - 1];\n\n            if (selected && previousItem) {\n              leaflet.DomUtil.addClass(previousItem, 'geocoder-control-selected');\n            } else {\n              leaflet.DomUtil.addClass(list[list.length - 1], 'geocoder-control-selected');\n            }\n\n            leaflet.DomEvent.preventDefault(e);\n            break;\n\n          case 40:\n            if (selected) {\n              leaflet.DomUtil.removeClass(selected, 'geocoder-control-selected');\n            }\n\n            var nextItem = list[selectedPosition + 1];\n\n            if (selected && nextItem) {\n              leaflet.DomUtil.addClass(nextItem, 'geocoder-control-selected');\n            } else {\n              leaflet.DomUtil.addClass(list[0], 'geocoder-control-selected');\n            }\n\n            leaflet.DomEvent.preventDefault(e);\n            break;\n\n          default:\n            // when the input changes we should cancel all pending suggestion requests if possible to avoid result collisions\n            for (var x = 0; x < this._geosearchCore._pendingSuggestions.length; x++) {\n              var request = this._geosearchCore._pendingSuggestions[x];\n\n              if (request && request.abort && !request.id) {\n                request.abort();\n              }\n            }\n\n            break;\n        }\n      }, this);\n      leaflet.DomEvent.addListener(this._input, 'keyup', leaflet.Util.throttle(function (e) {\n        var key = e.which || e.keyCode;\n        var text = (e.target || e.srcElement).value; // require at least 2 characters for suggestions\n\n        if (text.length < 2) {\n          this._lastValue = this._input.value;\n\n          this._clearAllSuggestions();\n\n          leaflet.DomUtil.removeClass(this._input, 'geocoder-control-loading');\n          return;\n        } // if this is the escape key it will clear the input so clear suggestions\n\n\n        if (key === 27) {\n          this._clearAllSuggestions();\n\n          return;\n        } // if this is NOT the up/down arrows or enter make a suggestion\n\n\n        if (key !== 13 && key !== 38 && key !== 40) {\n          if (this._input.value !== this._lastValue) {\n            this._lastValue = this._input.value;\n            leaflet.DomUtil.addClass(this._input, 'geocoder-control-loading');\n\n            this._geosearchCore._suggest(text);\n          }\n        }\n      }, 50, this), this);\n      leaflet.DomEvent.disableClickPropagation(this._wrapper); // when mouse moves over suggestions disable scroll wheel zoom if its enabled\n\n      leaflet.DomEvent.addListener(this._suggestions, 'mouseover', function (e) {\n        if (map.scrollWheelZoom.enabled() && map.options.scrollWheelZoom) {\n          map.scrollWheelZoom.disable();\n        }\n      }); // when mouse moves leaves suggestions enable scroll wheel zoom if its disabled\n\n      leaflet.DomEvent.addListener(this._suggestions, 'mouseout', function (e) {\n        if (!map.scrollWheelZoom.enabled() && map.options.scrollWheelZoom) {\n          map.scrollWheelZoom.enable();\n        }\n      });\n\n      this._geosearchCore.on('load', function (e) {\n        leaflet.DomUtil.removeClass(this._input, 'geocoder-control-loading');\n        this.clear();\n\n        this._input.blur();\n      }, this);\n\n      return this._wrapper;\n    }\n  });\n\n  function geosearch(options) {\n    return new Geosearch(options);\n  }\n\n  var FeatureLayerProvider = esriLeaflet.FeatureLayerService.extend({\n    options: {\n      label: 'Feature Layer',\n      maxResults: 5,\n      bufferRadius: 1000,\n      searchMode: 'contain',\n      formatSuggestion: function formatSuggestion(feature) {\n        return feature.properties[this.options.searchFields[0]];\n      }\n    },\n    initialize: function initialize(options) {\n      esriLeaflet.FeatureLayerService.prototype.initialize.call(this, options);\n\n      if (typeof this.options.searchFields === 'string') {\n        this.options.searchFields = [this.options.searchFields];\n      }\n\n      this._suggestionsQuery = this.query();\n      this._resultsQuery = this.query();\n    },\n    suggestions: function suggestions(text, bounds, callback) {\n      var query = this._suggestionsQuery.where(this._buildQuery(text)).returnGeometry(false);\n\n      if (bounds) {\n        query.intersects(bounds);\n      }\n\n      if (this.options.idField) {\n        query.fields([this.options.idField].concat(this.options.searchFields));\n      }\n\n      var request = query.run(function (error, results, raw) {\n        if (error) {\n          callback(error, []);\n        } else {\n          this.options.idField = raw.objectIdFieldName;\n          var suggestions = [];\n\n          for (var i = results.features.length - 1; i >= 0; i--) {\n            var feature = results.features[i];\n            suggestions.push({\n              text: this.options.formatSuggestion.call(this, feature),\n              unformattedText: feature.properties[this.options.searchFields[0]],\n              magicKey: feature.id\n            });\n          }\n\n          callback(error, suggestions.slice(0, this.options.maxResults));\n        }\n      }, this);\n      return request;\n    },\n    results: function results(text, key, bounds, callback) {\n      var query = this._resultsQuery;\n\n      if (key) {\n        delete query.params.where;\n        query.featureIds([key]);\n      } else {\n        query.where(this._buildQuery(text));\n      }\n\n      if (bounds) {\n        query.within(bounds);\n      }\n\n      return query.run(leaflet.Util.bind(function (error, features) {\n        var results = [];\n\n        for (var i = 0; i < features.features.length; i++) {\n          var feature = features.features[i];\n\n          if (feature) {\n            var bounds = this._featureBounds(feature);\n\n            var result = {\n              latlng: bounds.getCenter(),\n              bounds: bounds,\n              text: this.options.formatSuggestion.call(this, feature),\n              properties: feature.properties,\n              geojson: feature\n            };\n            results.push(result); // clear query parameters for the next search\n\n            delete this._resultsQuery.params['objectIds'];\n          }\n        }\n\n        callback(error, results);\n      }, this));\n    },\n    orderBy: function orderBy(fieldName, order) {\n      this._suggestionsQuery.orderBy(fieldName, order);\n    },\n    _buildQuery: function _buildQuery(text) {\n      var queryString = [];\n\n      for (var i = this.options.searchFields.length - 1; i >= 0; i--) {\n        var field = 'upper(\"' + this.options.searchFields[i] + '\")';\n\n        if (this.options.searchMode === 'contain') {\n          queryString.push(field + \" LIKE upper('%\" + text + \"%')\");\n        } else if (this.options.searchMode === 'startWith') {\n          queryString.push(field + \" LIKE upper('\" + text + \"%')\");\n        } else if (this.options.searchMode === 'endWith') {\n          queryString.push(field + \" LIKE upper('%\" + text + \"')\");\n        } else if (this.options.searchMode === 'strict') {\n          queryString.push(field + \" LIKE upper('\" + text + \"')\");\n        } else {\n          throw new Error('L.esri.Geocoding.featureLayerProvider: Invalid parameter for \"searchMode\". Use one of \"contain\", \"startWith\", \"endWith\", or \"strict\"');\n        }\n      }\n\n      if (this.options.where) {\n        return this.options.where + ' AND (' + queryString.join(' OR ') + ')';\n      } else {\n        return queryString.join(' OR ');\n      }\n    },\n    _featureBounds: function _featureBounds(feature) {\n      var geojson = leaflet.geoJson(feature);\n\n      if (feature.geometry.type === 'Point') {\n        var center = geojson.getBounds().getCenter();\n        var lngRadius = this.options.bufferRadius / 40075017 * 360 / Math.cos(180 / Math.PI * center.lat);\n        var latRadius = this.options.bufferRadius / 40075017 * 360;\n        return leaflet.latLngBounds([center.lat - latRadius, center.lng - lngRadius], [center.lat + latRadius, center.lng + lngRadius]);\n      } else {\n        return geojson.getBounds();\n      }\n    }\n  });\n\n  function featureLayerProvider(options) {\n    return new FeatureLayerProvider(options);\n  }\n\n  var MapServiceProvider = esriLeaflet.MapService.extend({\n    options: {\n      layers: [0],\n      label: 'Map Service',\n      bufferRadius: 1000,\n      maxResults: 5,\n      formatSuggestion: function formatSuggestion(feature) {\n        return feature.properties[feature.displayFieldName] + ' <small>' + feature.layerName + '</small>';\n      }\n    },\n    initialize: function initialize(options) {\n      esriLeaflet.MapService.prototype.initialize.call(this, options);\n\n      this._getIdFields();\n    },\n    suggestions: function suggestions(text, bounds, callback) {\n      var request = this.find().text(text).fields(this.options.searchFields).returnGeometry(false).layers(this.options.layers);\n      return request.run(function (error, results, raw) {\n        var suggestions = [];\n\n        if (!error) {\n          var count = Math.min(this.options.maxResults, results.features.length);\n          raw.results = raw.results.reverse();\n\n          for (var i = 0; i < count; i++) {\n            var feature = results.features[i];\n            var result = raw.results[i];\n            var layer = result.layerId;\n            var idField = this._idFields[layer];\n            feature.layerId = layer;\n            feature.layerName = this._layerNames[layer];\n            feature.displayFieldName = this._displayFields[layer];\n\n            if (idField) {\n              suggestions.push({\n                text: this.options.formatSuggestion.call(this, feature),\n                unformattedText: feature.properties[feature.displayFieldName],\n                magicKey: result.attributes[idField] + ':' + layer\n              });\n            }\n          }\n        }\n\n        callback(error, suggestions.reverse());\n      }, this);\n    },\n    results: function results(text, key, bounds, callback) {\n      var results = [];\n      var request;\n\n      if (key) {\n        var featureId = key.split(':')[0];\n        var layer = key.split(':')[1];\n        request = this.query().layer(layer).featureIds(featureId);\n      } else {\n        request = this.find().text(text).fields(this.options.searchFields).layers(this.options.layers);\n      }\n\n      return request.run(function (error, features, response) {\n        if (!error) {\n          if (response.results) {\n            response.results = response.results.reverse();\n          }\n\n          for (var i = 0; i < features.features.length; i++) {\n            var feature = features.features[i];\n            layer = layer || response.results[i].layerId;\n\n            if (feature && layer !== undefined) {\n              var bounds = this._featureBounds(feature);\n\n              feature.layerId = layer;\n              feature.layerName = this._layerNames[layer];\n              feature.displayFieldName = this._displayFields[layer];\n              var result = {\n                latlng: bounds.getCenter(),\n                bounds: bounds,\n                text: this.options.formatSuggestion.call(this, feature),\n                properties: feature.properties,\n                geojson: feature\n              };\n              results.push(result);\n            }\n          }\n        }\n\n        callback(error, results.reverse());\n      }, this);\n    },\n    _featureBounds: function _featureBounds(feature) {\n      var geojson = leaflet.geoJson(feature);\n\n      if (feature.geometry.type === 'Point') {\n        var center = geojson.getBounds().getCenter();\n        var lngRadius = this.options.bufferRadius / 40075017 * 360 / Math.cos(180 / Math.PI * center.lat);\n        var latRadius = this.options.bufferRadius / 40075017 * 360;\n        return leaflet.latLngBounds([center.lat - latRadius, center.lng - lngRadius], [center.lat + latRadius, center.lng + lngRadius]);\n      } else {\n        return geojson.getBounds();\n      }\n    },\n    _layerMetadataCallback: function _layerMetadataCallback(layerid) {\n      return leaflet.Util.bind(function (error, metadata) {\n        if (error) {\n          return;\n        }\n\n        this._displayFields[layerid] = metadata.displayField;\n        this._layerNames[layerid] = metadata.name;\n\n        for (var i = 0; i < metadata.fields.length; i++) {\n          var field = metadata.fields[i];\n\n          if (field.type === 'esriFieldTypeOID') {\n            this._idFields[layerid] = field.name;\n            break;\n          }\n        }\n      }, this);\n    },\n    _getIdFields: function _getIdFields() {\n      this._idFields = {};\n      this._displayFields = {};\n      this._layerNames = {};\n\n      for (var i = 0; i < this.options.layers.length; i++) {\n        var layer = this.options.layers[i];\n        this.get(layer, {}, this._layerMetadataCallback(layer));\n      }\n    }\n  });\n\n  function mapServiceProvider(options) {\n    return new MapServiceProvider(options);\n  }\n\n  var GeocodeServiceProvider = GeocodeService.extend({\n    options: {\n      label: 'Geocode Server',\n      maxResults: 5\n    },\n    suggestions: function suggestions(text, bounds, callback) {\n      if (this.options.supportsSuggest) {\n        var request = this.suggest().text(text);\n\n        if (bounds) {\n          request.within(bounds);\n        }\n\n        return request.run(function (error, results, response) {\n          var suggestions = [];\n\n          if (!error) {\n            while (response.suggestions.length && suggestions.length <= this.options.maxResults - 1) {\n              var suggestion = response.suggestions.shift();\n\n              if (!suggestion.isCollection) {\n                suggestions.push({\n                  text: suggestion.text,\n                  unformattedText: suggestion.text,\n                  magicKey: suggestion.magicKey\n                });\n              }\n            }\n          }\n\n          callback(error, suggestions);\n        }, this);\n      } else {\n        callback(undefined, []);\n        return false;\n      }\n    },\n    results: function results(text, key, bounds, callback) {\n      var request = this.geocode().text(text);\n\n      if (key) {\n        request.key(key);\n      }\n\n      request.maxLocations(this.options.maxResults);\n\n      if (bounds) {\n        request.within(bounds);\n      }\n\n      return request.run(function (error, response) {\n        callback(error, response.results);\n      }, this);\n    }\n  });\n\n  function geocodeServiceProvider(options) {\n    return new GeocodeServiceProvider(options);\n  }\n\n  exports.ArcgisOnlineProvider = ArcgisOnlineProvider;\n  exports.FeatureLayerProvider = FeatureLayerProvider;\n  exports.Geocode = Geocode;\n  exports.GeocodeService = GeocodeService;\n  exports.GeocodeServiceProvider = GeocodeServiceProvider;\n  exports.Geosearch = Geosearch;\n  exports.GeosearchCore = GeosearchCore;\n  exports.MapServiceProvider = MapServiceProvider;\n  exports.ReverseGeocode = ReverseGeocode;\n  exports.Suggest = Suggest;\n  exports.VERSION = version;\n  exports.WorldGeocodingServiceUrl = WorldGeocodingServiceUrl;\n  exports.arcgisOnlineProvider = arcgisOnlineProvider;\n  exports.featureLayerProvider = featureLayerProvider;\n  exports.geocode = _geocode;\n  exports.geocodeService = geocodeService;\n  exports.geocodeServiceProvider = geocodeServiceProvider;\n  exports.geosearch = geosearch;\n  exports.geosearchCore = geosearchCore;\n  exports.mapServiceProvider = mapServiceProvider;\n  exports.reverseGeocode = reverseGeocode;\n  exports.suggest = _suggest;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["../src/helper.js","../src/Tasks/Geocode.js","../src/Tasks/ReverseGeocode.js","../src/Tasks/Suggest.js","../src/Services/Geocode.js","../src/Classes/GeosearchCore.js","../src/Providers/ArcgisOnlineGeocoder.js","../src/Controls/Geosearch.js","../src/Providers/FeatureLayer.js","../src/Providers/MapService.js","../src/Providers/GeocodeService.js"],"names":["Task","latLngBounds","EsriUtil","latLng","Service","Evented","Util","Control","DomUtil","DomEvent","FeatureLayerService","geoJson","MapService"],"mappings":"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","sourcesContent":["export var WorldGeocodingServiceUrl = 'https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/';\r\n","import {\r\n  latLng,\r\n  latLngBounds\r\n} from 'leaflet';\r\nimport { Task, Util as EsriUtil } from 'esri-leaflet';\r\nimport { WorldGeocodingServiceUrl } from '../helper';\r\n\r\nexport var Geocode = Task.extend({\r\n  path: 'findAddressCandidates',\r\n\r\n  params: {\r\n    outSr: 4326,\r\n    forStorage: false,\r\n    outFields: '*',\r\n    maxLocations: 20\r\n  },\r\n\r\n  setters: {\r\n    'address': 'address',\r\n    'neighborhood': 'neighborhood',\r\n    'city': 'city',\r\n    'subregion': 'subregion',\r\n    'region': 'region',\r\n    'postal': 'postal',\r\n    'country': 'country',\r\n    'text': 'singleLine',\r\n    'category': 'category',\r\n    'token': 'token',\r\n    'key': 'magicKey',\r\n    'fields': 'outFields',\r\n    'forStorage': 'forStorage',\r\n    'maxLocations': 'maxLocations',\r\n    // World Geocoding Service (only works with singleLine)\r\n    'countries': 'sourceCountry'\r\n  },\r\n\r\n  initialize: function (options) {\r\n    options = options || {};\r\n    options.url = options.url || WorldGeocodingServiceUrl;\r\n    Task.prototype.initialize.call(this, options);\r\n  },\r\n\r\n  within: function (bounds) {\r\n    bounds = latLngBounds(bounds);\r\n    this.params.searchExtent = EsriUtil.boundsToExtent(bounds);\r\n    return this;\r\n  },\r\n\r\n  nearby: function (coords, radius) {\r\n    var centroid = latLng(coords);\r\n    this.params.location = centroid.lng + ',' + centroid.lat;\r\n    this.params.distance = Math.min(Math.max(radius, 2000), 50000);\r\n    return this;\r\n  },\r\n\r\n  run: function (callback, context) {\r\n    if (this.options.customParam) {\r\n      this.params[this.options.customParam] = this.params.singleLine;\r\n      delete this.params.singleLine;\r\n    }\r\n\r\n    return this.request(function (error, response) {\r\n      var processor = this._processGeocoderResponse;\r\n      var results = (!error) ? processor(response) : undefined;\r\n      callback.call(context, error, { results: results }, response);\r\n    }, this);\r\n  },\r\n\r\n  _processGeocoderResponse: function (response) {\r\n    var results = [];\r\n\r\n    for (var i = 0; i < response.candidates.length; i++) {\r\n      var candidate = response.candidates[i];\r\n      if (candidate.extent) {\r\n        var bounds = EsriUtil.extentToBounds(candidate.extent);\r\n      }\r\n\r\n      results.push({\r\n        text: candidate.address,\r\n        bounds: bounds,\r\n        score: candidate.score,\r\n        latlng: latLng(candidate.location.y, candidate.location.x),\r\n        properties: candidate.attributes\r\n      });\r\n    }\r\n    return results;\r\n  }\r\n});\r\n\r\nexport function geocode (options) {\r\n  return new Geocode(options);\r\n}\r\n\r\nexport default geocode;\r\n","import { latLng } from 'leaflet';\r\nimport { Task } from 'esri-leaflet';\r\nimport { WorldGeocodingServiceUrl } from '../helper';\r\n\r\nexport var ReverseGeocode = Task.extend({\r\n  path: 'reverseGeocode',\r\n\r\n  params: {\r\n    outSR: 4326,\r\n    returnIntersection: false\r\n  },\r\n\r\n  setters: {\r\n    'distance': 'distance',\r\n    'language': 'langCode',\r\n    'intersection': 'returnIntersection'\r\n  },\r\n\r\n  initialize: function (options) {\r\n    options = options || {};\r\n    options.url = options.url || WorldGeocodingServiceUrl;\r\n    Task.prototype.initialize.call(this, options);\r\n  },\r\n\r\n  latlng: function (coords) {\r\n    var centroid = latLng(coords);\r\n    this.params.location = centroid.lng + ',' + centroid.lat;\r\n    return this;\r\n  },\r\n\r\n  run: function (callback, context) {\r\n    return this.request(function (error, response) {\r\n      var result;\r\n\r\n      if (!error) {\r\n        result = {\r\n          latlng: latLng(response.location.y, response.location.x),\r\n          address: response.address\r\n        };\r\n      } else {\r\n        result = undefined;\r\n      }\r\n\r\n      callback.call(context, error, result, response);\r\n    }, this);\r\n  }\r\n});\r\n\r\nexport function reverseGeocode (options) {\r\n  return new ReverseGeocode(options);\r\n}\r\n\r\nexport default reverseGeocode;\r\n","import {\r\n  latLng,\r\n  latLngBounds\r\n} from 'leaflet';\r\nimport { Task, Util as EsriUtil } from 'esri-leaflet';\r\nimport { WorldGeocodingServiceUrl } from '../helper';\r\n\r\nexport var Suggest = Task.extend({\r\n  path: 'suggest',\r\n\r\n  params: {},\r\n\r\n  setters: {\r\n    text: 'text',\r\n    category: 'category',\r\n    countries: 'countryCode',\r\n    maxSuggestions: 'maxSuggestions'\r\n  },\r\n\r\n  initialize: function (options) {\r\n    options = options || {};\r\n    if (!options.url) {\r\n      options.url = WorldGeocodingServiceUrl;\r\n      options.supportsSuggest = true;\r\n    }\r\n    Task.prototype.initialize.call(this, options);\r\n  },\r\n\r\n  within: function (bounds) {\r\n    bounds = latLngBounds(bounds);\r\n    bounds = bounds.pad(0.5);\r\n    var center = bounds.getCenter();\r\n    var ne = bounds.getNorthWest();\r\n    this.params.location = center.lng + ',' + center.lat;\r\n    this.params.distance = Math.min(Math.max(center.distanceTo(ne), 2000), 50000);\r\n    this.params.searchExtent = EsriUtil.boundsToExtent(bounds);\r\n    return this;\r\n  },\r\n\r\n  nearby: function (coords, radius) {\r\n    var centroid = latLng(coords);\r\n    this.params.location = centroid.lng + ',' + centroid.lat;\r\n    this.params.distance = Math.min(Math.max(radius, 2000), 50000);\r\n    return this;\r\n  },\r\n\r\n  run: function (callback, context) {\r\n    if (this.options.supportsSuggest) {\r\n      return this.request(function (error, response) {\r\n        callback.call(context, error, response, response);\r\n      }, this);\r\n    } else {\r\n      console.warn('this geocoding service does not support asking for suggestions');\r\n    }\r\n  }\r\n\r\n});\r\n\r\nexport function suggest (options) {\r\n  return new Suggest(options);\r\n}\r\n\r\nexport default suggest;\r\n","import { Service } from 'esri-leaflet';\r\nimport { WorldGeocodingServiceUrl } from '../helper';\r\nimport geocode from '../Tasks/Geocode';\r\nimport reverseGeocode from '../Tasks/ReverseGeocode';\r\nimport suggest from '../Tasks/Suggest';\r\n\r\nexport var GeocodeService = Service.extend({\r\n  initialize: function (options) {\r\n    options = options || {};\r\n    if (options.url) {\r\n      Service.prototype.initialize.call(this, options);\r\n      this._confirmSuggestSupport();\r\n    } else {\r\n      options.url = WorldGeocodingServiceUrl;\r\n      options.supportsSuggest = true;\r\n      Service.prototype.initialize.call(this, options);\r\n    }\r\n  },\r\n\r\n  geocode: function () {\r\n    return geocode(this);\r\n  },\r\n\r\n  reverse: function () {\r\n    return reverseGeocode(this);\r\n  },\r\n\r\n  suggest: function () {\r\n    // requires either the Esri World Geocoding Service or a <10.3 ArcGIS Server Geocoding Service that supports suggest.\r\n    return suggest(this);\r\n  },\r\n\r\n  _confirmSuggestSupport: function () {\r\n    this.metadata(function (error, response) {\r\n      if (error) { return; }\r\n      // pre 10.3 geocoding services dont list capabilities (and dont support maxLocations)\r\n      // only SOME individual services have been configured to support asking for suggestions\r\n      if (!response.capabilities) {\r\n        this.options.supportsSuggest = false;\r\n      } else if (response.capabilities.indexOf('Suggest') > -1) {\r\n        this.options.supportsSuggest = true;\r\n      } else {\r\n        this.options.supportsSuggest = false;\r\n      }\r\n      // whether the service supports suggest or not, utilize the metadata response to determine the appropriate parameter name for single line geocoding requests\r\n      this.options.customParam = response.singleLineAddressField.name;\r\n    }, this);\r\n  }\r\n});\r\n\r\nexport function geocodeService (options) {\r\n  return new GeocodeService(options);\r\n}\r\n\r\nexport default geocodeService;\r\n","import { Evented, Util, latLngBounds } from 'leaflet';\r\n\r\nexport var GeosearchCore = Evented.extend({\r\n\r\n  options: {\r\n    zoomToResult: true,\r\n    useMapBounds: 12,\r\n    searchBounds: null\r\n  },\r\n\r\n  initialize: function (control, options) {\r\n    Util.setOptions(this, options);\r\n    this._control = control;\r\n\r\n    if (!options || !options.providers || !options.providers.length) {\r\n      throw new Error('You must specify at least one provider');\r\n    }\r\n\r\n    this._providers = options.providers;\r\n  },\r\n\r\n  _geocode: function (text, key, provider) {\r\n    var activeRequests = 0;\r\n    var allResults = [];\r\n    var bounds;\r\n\r\n    var callback = Util.bind(function (error, results) {\r\n      activeRequests--;\r\n      if (error) {\r\n        return;\r\n      }\r\n\r\n      if (results) {\r\n        allResults = allResults.concat(results);\r\n      }\r\n\r\n      if (activeRequests <= 0) {\r\n        bounds = this._boundsFromResults(allResults);\r\n\r\n        this.fire('results', {\r\n          results: allResults,\r\n          bounds: bounds,\r\n          latlng: (bounds) ? bounds.getCenter() : undefined,\r\n          text: text\r\n        }, true);\r\n\r\n        if (this.options.zoomToResult && bounds) {\r\n          this._control._map.fitBounds(bounds);\r\n        }\r\n\r\n        this.fire('load');\r\n      }\r\n    }, this);\r\n\r\n    if (key) {\r\n      activeRequests++;\r\n      provider.results(text, key, this._searchBounds(), callback);\r\n    } else {\r\n      for (var i = 0; i < this._providers.length; i++) {\r\n        activeRequests++;\r\n        this._providers[i].results(text, key, this._searchBounds(), callback);\r\n      }\r\n    }\r\n  },\r\n\r\n  _suggest: function (text) {\r\n    var activeRequests = this._providers.length;\r\n    var suggestionsLength = 0;\r\n\r\n    var createCallback = Util.bind(function (text, provider) {\r\n      return Util.bind(function (error, suggestions) {\r\n        activeRequests = activeRequests - 1;\r\n        suggestionsLength += suggestions.length;\r\n\r\n        if (error) {\r\n          // an error occurred for one of the providers' suggest requests\r\n          this._control._clearProviderSuggestions(provider);\r\n\r\n          // perform additional cleanup when all requests are finished\r\n          this._control._finalizeSuggestions(activeRequests, suggestionsLength);\r\n\r\n          return;\r\n        }\r\n\r\n        if (suggestions.length) {\r\n          for (var i = 0; i < suggestions.length; i++) {\r\n            suggestions[i].provider = provider;\r\n          }\r\n        } else {\r\n          // we still need to update the UI\r\n          this._control._renderSuggestions(suggestions);\r\n        }\r\n\r\n        if (provider._lastRender !== text) {\r\n          this._control._clearProviderSuggestions(provider);\r\n        }\r\n\r\n        if (suggestions.length && this._control._input.value === text) {\r\n          provider._lastRender = text;\r\n          this._control._renderSuggestions(suggestions);\r\n        }\r\n\r\n        // perform additional cleanup when all requests are finished\r\n        this._control._finalizeSuggestions(activeRequests, suggestionsLength);\r\n      }, this);\r\n    }, this);\r\n\r\n    this._pendingSuggestions = [];\r\n\r\n    for (var i = 0; i < this._providers.length; i++) {\r\n      var provider = this._providers[i];\r\n      var request = provider.suggestions(text, this._searchBounds(), createCallback(text, provider));\r\n      this._pendingSuggestions.push(request);\r\n    }\r\n  },\r\n\r\n  _searchBounds: function () {\r\n    if (this.options.searchBounds !== null) {\r\n      return this.options.searchBounds;\r\n    }\r\n\r\n    if (this.options.useMapBounds === false) {\r\n      return null;\r\n    }\r\n\r\n    if (this.options.useMapBounds === true) {\r\n      return this._control._map.getBounds();\r\n    }\r\n\r\n    if (this.options.useMapBounds <= this._control._map.getZoom()) {\r\n      return this._control._map.getBounds();\r\n    }\r\n\r\n    return null;\r\n  },\r\n\r\n  _boundsFromResults: function (results) {\r\n    if (!results.length) {\r\n      return;\r\n    }\r\n\r\n    var nullIsland = latLngBounds([0, 0], [0, 0]);\r\n    var resultBounds = [];\r\n    var resultLatlngs = [];\r\n\r\n    // collect the bounds and center of each result\r\n    for (var i = results.length - 1; i >= 0; i--) {\r\n      var result = results[i];\r\n\r\n      resultLatlngs.push(result.latlng);\r\n\r\n      // make sure bounds are valid and not 0,0. sometimes bounds are incorrect or not present\r\n      if (result.bounds && result.bounds.isValid() && !result.bounds.equals(nullIsland)) {\r\n        resultBounds.push(result.bounds);\r\n      }\r\n    }\r\n\r\n    // form a bounds object containing all center points\r\n    var bounds = latLngBounds(resultLatlngs);\r\n\r\n    // and extend it to contain all bounds objects\r\n    for (var j = 0; j < resultBounds.length; j++) {\r\n      bounds.extend(resultBounds[j]);\r\n    }\r\n\r\n    return bounds;\r\n  },\r\n\r\n  _getAttribution: function () {\r\n    var attribs = [];\r\n    var providers = this._providers;\r\n\r\n    for (var i = 0; i < providers.length; i++) {\r\n      if (providers[i].options.attribution) {\r\n        attribs.push(providers[i].options.attribution);\r\n      }\r\n    }\r\n\r\n    return attribs.join(', ');\r\n  }\r\n\r\n});\r\n\r\nexport function geosearchCore (control, options) {\r\n  return new GeosearchCore(control, options);\r\n}\r\n\r\nexport default geosearchCore;\r\n","import { GeocodeService } from '../Services/Geocode';\r\n\r\nexport var ArcgisOnlineProvider = GeocodeService.extend({\r\n  options: {\r\n    label: 'Places and Addresses',\r\n    maxResults: 5\r\n  },\r\n\r\n  suggestions: function (text, bounds, callback) {\r\n    var request = this.suggest().text(text);\r\n\r\n    if (bounds) {\r\n      request.within(bounds);\r\n    }\r\n\r\n    if (this.options.countries) {\r\n      request.countries(this.options.countries);\r\n    }\r\n\r\n    if (this.options.categories) {\r\n      request.category(this.options.categories);\r\n    }\r\n\r\n    // 15 is the maximum number of suggestions that can be returned\r\n    request.maxSuggestions(this.options.maxResults);\r\n\r\n    return request.run(function (error, results, response) {\r\n      var suggestions = [];\r\n      if (!error) {\r\n        while (response.suggestions.length && suggestions.length <= (this.options.maxResults - 1)) {\r\n          var suggestion = response.suggestions.shift();\r\n          if (!suggestion.isCollection) {\r\n            suggestions.push({\r\n              text: suggestion.text,\r\n              unformattedText: suggestion.text,\r\n              magicKey: suggestion.magicKey\r\n            });\r\n          }\r\n        }\r\n      }\r\n      callback(error, suggestions);\r\n    }, this);\r\n  },\r\n\r\n  results: function (text, key, bounds, callback) {\r\n    var request = this.geocode().text(text);\r\n\r\n    if (key) {\r\n      request.key(key);\r\n    }\r\n    // in the future Address/StreetName geocoding requests that include a magicKey will always only return one match\r\n    request.maxLocations(this.options.maxResults);\r\n\r\n    if (bounds) {\r\n      request.within(bounds);\r\n    }\r\n\r\n    if (this.options.forStorage) {\r\n      request.forStorage(true);\r\n    }\r\n\r\n    if (this.options.countries) {\r\n      request.countries(this.options.countries);\r\n    }\r\n\r\n    if (this.options.categories) {\r\n      request.category(this.options.categories);\r\n    }\r\n\r\n    return request.run(function (error, response) {\r\n      callback(error, response.results);\r\n    }, this);\r\n  }\r\n});\r\n\r\nexport function arcgisOnlineProvider (options) {\r\n  return new ArcgisOnlineProvider(options);\r\n}\r\n\r\nexport default arcgisOnlineProvider;\r\n","import {\r\n  Control,\r\n  DomEvent,\r\n  DomUtil,\r\n  Evented,\r\n  Util,\r\n  latLngBounds\r\n} from 'leaflet';\r\nimport { geosearchCore } from '../Classes/GeosearchCore';\r\nimport { arcgisOnlineProvider } from '../Providers/ArcgisOnlineGeocoder';\r\nimport { Util as EsriUtil } from 'esri-leaflet';\r\n\r\nexport var Geosearch = Control.extend({\r\n  includes: Evented.prototype,\r\n\r\n  options: {\r\n    position: 'topleft',\r\n    collapseAfterResult: true,\r\n    expanded: false,\r\n    allowMultipleResults: true,\r\n    placeholder: 'Search for places or addresses',\r\n    title: 'Location Search'\r\n  },\r\n\r\n  initialize: function (options) {\r\n    Util.setOptions(this, options);\r\n\r\n    if (!options || !options.providers || !options.providers.length) {\r\n      if (!options) {\r\n        options = {};\r\n      }\r\n      options.providers = [ arcgisOnlineProvider() ];\r\n    }\r\n\r\n    // instantiate the underlying class and pass along options\r\n    this._geosearchCore = geosearchCore(this, options);\r\n    this._geosearchCore._providers = options.providers;\r\n\r\n    // bubble each providers events to the control\r\n    this._geosearchCore.addEventParent(this);\r\n    for (var i = 0; i < this._geosearchCore._providers.length; i++) {\r\n      this._geosearchCore._providers[i].addEventParent(this);\r\n    }\r\n\r\n    this._geosearchCore._pendingSuggestions = [];\r\n\r\n    Control.prototype.initialize.call(this, options);\r\n  },\r\n\r\n  _renderSuggestions: function (suggestions) {\r\n    var currentGroup;\r\n\r\n    if (suggestions.length > 0) {\r\n      this._suggestions.style.display = 'block';\r\n    }\r\n\r\n    var list;\r\n    var header;\r\n    var suggestionTextArray = [];\r\n\r\n    for (var i = 0; i < suggestions.length; i++) {\r\n      var suggestion = suggestions[i];\r\n      if (!header && this._geosearchCore._providers.length > 1 && currentGroup !== suggestion.provider.options.label) {\r\n        header = DomUtil.create('div', 'geocoder-control-header', suggestion.provider._contentsElement);\r\n        header.textContent = suggestion.provider.options.label;\r\n        header.innerText = suggestion.provider.options.label;\r\n        currentGroup = suggestion.provider.options.label;\r\n      }\r\n\r\n      if (!list) {\r\n        list = DomUtil.create('ul', 'geocoder-control-list', suggestion.provider._contentsElement);\r\n      }\r\n\r\n      if (suggestionTextArray.indexOf(suggestion.text) === -1) {\r\n        var suggestionItem = DomUtil.create('li', 'geocoder-control-suggestion', list);\r\n\r\n        suggestionItem.innerHTML = suggestion.text;\r\n        suggestionItem.provider = suggestion.provider;\r\n        suggestionItem['data-magic-key'] = suggestion.magicKey;\r\n        suggestionItem.unformattedText = suggestion.unformattedText;\r\n      } else {\r\n        for (var j = 0; j < list.childNodes.length; j++) {\r\n          // if the same text already appears in the list of suggestions, append an additional ObjectID to its magicKey instead\r\n          if (list.childNodes[j].innerHTML === suggestion.text) {\r\n            list.childNodes[j]['data-magic-key'] += ',' + suggestion.magicKey;\r\n          }\r\n        }\r\n      }\r\n      suggestionTextArray.push(suggestion.text);\r\n    }\r\n\r\n    // when the geocoder position is either \"topleft\" or \"topright\":\r\n    // set the maxHeight of the suggestions box to:\r\n    //  map height\r\n    //  - suggestions offset (distance from top of suggestions to top of control)\r\n    //  - control offset (distance from top of control to top of map)\r\n    //  - 10 (extra padding)\r\n    if (this.getPosition().indexOf('top') > -1) {\r\n      this._suggestions.style.maxHeight = (this._map.getSize().y - this._suggestions.offsetTop - this._wrapper.offsetTop - 10) + 'px';\r\n    }\r\n\r\n    // when the geocoder position is either \"bottomleft\" or \"bottomright\":\r\n    // 1. set the maxHeight of the suggestions box to:\r\n    //  map height\r\n    //  - corner control container offsetHeight (height of container of bottom corner)\r\n    //  - control offsetHeight (height of geocoder control wrapper, the main expandable button)\r\n    // 2. to move it up, set the top of the suggestions box to:\r\n    //  negative offsetHeight of suggestions box (its own negative height now that it has children elements\r\n    //  - control offsetHeight (height of geocoder control wrapper, the main expandable button)\r\n    //  + 20 (extra spacing)\r\n    if (this.getPosition().indexOf('bottom') > -1) {\r\n      this._setSuggestionsBottomPosition();\r\n    }\r\n  },\r\n\r\n  _setSuggestionsBottomPosition: function () {\r\n    this._suggestions.style.maxHeight = (this._map.getSize().y - this._map._controlCorners[this.getPosition()].offsetHeight - this._wrapper.offsetHeight) + 'px';\r\n    this._suggestions.style.top = (-this._suggestions.offsetHeight - this._wrapper.offsetHeight + 20) + 'px';\r\n  },\r\n\r\n  _boundsFromResults: function (results) {\r\n    if (!results.length) {\r\n      return;\r\n    }\r\n\r\n    var nullIsland = latLngBounds([0, 0], [0, 0]);\r\n    var resultBounds = [];\r\n    var resultLatlngs = [];\r\n\r\n    // collect the bounds and center of each result\r\n    for (var i = results.length - 1; i >= 0; i--) {\r\n      var result = results[i];\r\n\r\n      resultLatlngs.push(result.latlng);\r\n\r\n      // make sure bounds are valid and not 0,0. sometimes bounds are incorrect or not present\r\n      if (result.bounds && result.bounds.isValid() && !result.bounds.equals(nullIsland)) {\r\n        resultBounds.push(result.bounds);\r\n      }\r\n    }\r\n\r\n    // form a bounds object containing all center points\r\n    var bounds = latLngBounds(resultLatlngs);\r\n\r\n    // and extend it to contain all bounds objects\r\n    for (var j = 0; j < resultBounds.length; j++) {\r\n      bounds.extend(resultBounds[j]);\r\n    }\r\n\r\n    return bounds;\r\n  },\r\n\r\n  clear: function () {\r\n    this._clearAllSuggestions();\r\n\r\n    if (this.options.collapseAfterResult) {\r\n      this._input.value = '';\r\n      this._lastValue = '';\r\n      this._input.placeholder = '';\r\n      DomUtil.removeClass(this._wrapper, 'geocoder-control-expanded');\r\n    }\r\n\r\n    if (!this._map.scrollWheelZoom.enabled() && this._map.options.scrollWheelZoom) {\r\n      this._map.scrollWheelZoom.enable();\r\n    }\r\n  },\r\n\r\n  _clearAllSuggestions: function () {\r\n    this._suggestions.style.display = 'none';\r\n\r\n    for (var i = 0; i < this.options.providers.length; i++) {\r\n      this._clearProviderSuggestions(this.options.providers[i]);\r\n    }\r\n  },\r\n\r\n  _clearProviderSuggestions: function (provider) {\r\n    provider._contentsElement.innerHTML = '';\r\n  },\r\n\r\n  _finalizeSuggestions: function (activeRequests, suggestionsLength) {\r\n    // check if all requests are finished to remove the loading indicator\r\n    if (!activeRequests) {\r\n      DomUtil.removeClass(this._input, 'geocoder-control-loading');\r\n\r\n      // when the geocoder position is either \"bottomleft\" or \"bottomright\",\r\n      // it is necessary in some cases to recalculate the maxHeight and top values of the this._suggestions element,\r\n      // even though this is also being done after each provider returns their own suggestions\r\n      if (this.getPosition().indexOf('bottom') > -1) {\r\n        this._setSuggestionsBottomPosition();\r\n      }\r\n\r\n      // also check if there were 0 total suggest results to clear the parent suggestions element\r\n      // otherwise its display value may be \"block\" instead of \"none\"\r\n      if (!suggestionsLength) {\r\n        this._clearAllSuggestions();\r\n      }\r\n    }\r\n  },\r\n\r\n  _setupClick: function () {\r\n    DomUtil.addClass(this._wrapper, 'geocoder-control-expanded');\r\n    this._input.focus();\r\n  },\r\n\r\n  disable: function () {\r\n    this._input.disabled = true;\r\n    DomUtil.addClass(this._input, 'geocoder-control-input-disabled');\r\n    DomEvent.removeListener(this._wrapper, 'click', this._setupClick, this);\r\n  },\r\n\r\n  enable: function () {\r\n    this._input.disabled = false;\r\n    DomUtil.removeClass(this._input, 'geocoder-control-input-disabled');\r\n    DomEvent.addListener(this._wrapper, 'click', this._setupClick, this);\r\n  },\r\n\r\n  getAttribution: function () {\r\n    var attribs = [];\r\n\r\n    for (var i = 0; i < this._providers.length; i++) {\r\n      if (this._providers[i].options.attribution) {\r\n        attribs.push(this._providers[i].options.attribution);\r\n      }\r\n    }\r\n\r\n    return attribs.join(', ');\r\n  },\r\n\r\n  geocodeSuggestion: function (e) {\r\n    var suggestionItem = e.target || e.srcElement;\r\n\r\n    if (\r\n      suggestionItem.classList.contains('geocoder-control-suggestions') ||\r\n      suggestionItem.classList.contains('geocoder-control-header')\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    // make sure and point at the actual 'geocoder-control-suggestion'\r\n    if (suggestionItem.classList.length < 1) {\r\n      suggestionItem = suggestionItem.parentNode;\r\n    }\r\n\r\n    this._geosearchCore._geocode(suggestionItem.unformattedText, suggestionItem['data-magic-key'], suggestionItem.provider);\r\n    this.clear();\r\n  },\r\n\r\n  onAdd: function (map) {\r\n    // include 'Powered by Esri' in map attribution\r\n    EsriUtil.setEsriAttribution(map);\r\n\r\n    this._map = map;\r\n    this._wrapper = DomUtil.create('div', 'geocoder-control');\r\n    this._input = DomUtil.create('input', 'geocoder-control-input leaflet-bar', this._wrapper);\r\n    this._input.title = this.options.title;\r\n\r\n    if (this.options.expanded) {\r\n      DomUtil.addClass(this._wrapper, 'geocoder-control-expanded');\r\n      this._input.placeholder = this.options.placeholder;\r\n    }\r\n\r\n    // create the main suggested results container element\r\n    this._suggestions = DomUtil.create('div', 'geocoder-control-suggestions leaflet-bar', this._wrapper);\r\n\r\n    // create a child contents container element for each provider inside of this._suggestions\r\n    // to maintain the configured order of providers for suggested results\r\n    for (var i = 0; i < this.options.providers.length; i++) {\r\n      this.options.providers[i]._contentsElement = DomUtil.create('div', null, this._suggestions);\r\n    }\r\n\r\n    var credits = this._geosearchCore._getAttribution();\r\n\r\n    if (map.attributionControl) {\r\n      map.attributionControl.addAttribution(credits);\r\n    }\r\n\r\n    DomEvent.addListener(this._input, 'focus', function (e) {\r\n      this._input.placeholder = this.options.placeholder;\r\n      DomUtil.addClass(this._wrapper, 'geocoder-control-expanded');\r\n    }, this);\r\n\r\n    DomEvent.addListener(this._wrapper, 'click', this._setupClick, this);\r\n\r\n    // make sure both click and touch spawn an address/poi search\r\n    DomEvent.addListener(this._suggestions, 'mousedown', this.geocodeSuggestion, this);\r\n\r\n    DomEvent.addListener(this._input, 'blur', function (e) {\r\n      // TODO: this is too greedy and should not \"clear\"\r\n      // when trying to use the scrollbar or clicking on a non-suggestion item (such as a provider header)\r\n      this.clear();\r\n    }, this);\r\n\r\n    DomEvent.addListener(this._input, 'keydown', function (e) {\r\n      var text = (e.target || e.srcElement).value;\r\n\r\n      DomUtil.addClass(this._wrapper, 'geocoder-control-expanded');\r\n\r\n      var list = this._suggestions.querySelectorAll('.' + 'geocoder-control-suggestion');\r\n      var selected = this._suggestions.querySelectorAll('.' + 'geocoder-control-selected')[0];\r\n      var selectedPosition;\r\n\r\n      for (var i = 0; i < list.length; i++) {\r\n        if (list[i] === selected) {\r\n          selectedPosition = i;\r\n          break;\r\n        }\r\n      }\r\n\r\n      switch (e.keyCode) {\r\n        case 13:\r\n          /*\r\n            if an item has been selected, geocode it\r\n            if focus is on the input textbox, geocode only if multiple results are allowed and more than two characters are present, or if a single suggestion is displayed.\r\n            if less than two characters have been typed, abort the geocode\r\n          */\r\n          if (selected) {\r\n            this._input.value = selected.innerText;\r\n            this._geosearchCore._geocode(selected.unformattedText, selected['data-magic-key'], selected.provider);\r\n            this.clear();\r\n          } else if (this.options.allowMultipleResults && text.length >= 2) {\r\n            this._geosearchCore._geocode(this._input.value, undefined);\r\n            this.clear();\r\n          } else {\r\n            if (list.length === 1) {\r\n              DomUtil.addClass(list[0], 'geocoder-control-selected');\r\n              this._geosearchCore._geocode(list[0].innerHTML, list[0]['data-magic-key'], list[0].provider);\r\n            } else {\r\n              this.clear();\r\n              this._input.blur();\r\n            }\r\n          }\r\n          DomEvent.preventDefault(e);\r\n          break;\r\n        case 38:\r\n          if (selected) {\r\n            DomUtil.removeClass(selected, 'geocoder-control-selected');\r\n          }\r\n\r\n          var previousItem = list[selectedPosition - 1];\r\n\r\n          if (selected && previousItem) {\r\n            DomUtil.addClass(previousItem, 'geocoder-control-selected');\r\n          } else {\r\n            DomUtil.addClass(list[list.length - 1], 'geocoder-control-selected');\r\n          }\r\n          DomEvent.preventDefault(e);\r\n          break;\r\n        case 40:\r\n          if (selected) {\r\n            DomUtil.removeClass(selected, 'geocoder-control-selected');\r\n          }\r\n\r\n          var nextItem = list[selectedPosition + 1];\r\n\r\n          if (selected && nextItem) {\r\n            DomUtil.addClass(nextItem, 'geocoder-control-selected');\r\n          } else {\r\n            DomUtil.addClass(list[0], 'geocoder-control-selected');\r\n          }\r\n          DomEvent.preventDefault(e);\r\n          break;\r\n        default:\r\n          // when the input changes we should cancel all pending suggestion requests if possible to avoid result collisions\r\n          for (var x = 0; x < this._geosearchCore._pendingSuggestions.length; x++) {\r\n            var request = this._geosearchCore._pendingSuggestions[x];\r\n            if (request && request.abort && !request.id) {\r\n              request.abort();\r\n            }\r\n          }\r\n          break;\r\n      }\r\n    }, this);\r\n\r\n    DomEvent.addListener(this._input, 'keyup', Util.throttle(function (e) {\r\n      var key = e.which || e.keyCode;\r\n      var text = (e.target || e.srcElement).value;\r\n\r\n      // require at least 2 characters for suggestions\r\n      if (text.length < 2) {\r\n        this._lastValue = this._input.value;\r\n        this._clearAllSuggestions();\r\n        DomUtil.removeClass(this._input, 'geocoder-control-loading');\r\n        return;\r\n      }\r\n\r\n      // if this is the escape key it will clear the input so clear suggestions\r\n      if (key === 27) {\r\n        this._clearAllSuggestions();\r\n        return;\r\n      }\r\n\r\n      // if this is NOT the up/down arrows or enter make a suggestion\r\n      if (key !== 13 && key !== 38 && key !== 40) {\r\n        if (this._input.value !== this._lastValue) {\r\n          this._lastValue = this._input.value;\r\n          DomUtil.addClass(this._input, 'geocoder-control-loading');\r\n          this._geosearchCore._suggest(text);\r\n        }\r\n      }\r\n    }, 50, this), this);\r\n\r\n    DomEvent.disableClickPropagation(this._wrapper);\r\n\r\n    // when mouse moves over suggestions disable scroll wheel zoom if its enabled\r\n    DomEvent.addListener(this._suggestions, 'mouseover', function (e) {\r\n      if (map.scrollWheelZoom.enabled() && map.options.scrollWheelZoom) {\r\n        map.scrollWheelZoom.disable();\r\n      }\r\n    });\r\n\r\n    // when mouse moves leaves suggestions enable scroll wheel zoom if its disabled\r\n    DomEvent.addListener(this._suggestions, 'mouseout', function (e) {\r\n      if (!map.scrollWheelZoom.enabled() && map.options.scrollWheelZoom) {\r\n        map.scrollWheelZoom.enable();\r\n      }\r\n    });\r\n\r\n    this._geosearchCore.on('load', function (e) {\r\n      DomUtil.removeClass(this._input, 'geocoder-control-loading');\r\n      this.clear();\r\n      this._input.blur();\r\n    }, this);\r\n\r\n    return this._wrapper;\r\n  }\r\n});\r\n\r\nexport function geosearch (options) {\r\n  return new Geosearch(options);\r\n}\r\n\r\nexport default geosearch;\r\n","import { Util, geoJson, latLngBounds } from 'leaflet';\r\nimport { FeatureLayerService } from 'esri-leaflet';\r\n\r\nexport var FeatureLayerProvider = FeatureLayerService.extend({\r\n  options: {\r\n    label: 'Feature Layer',\r\n    maxResults: 5,\r\n    bufferRadius: 1000,\r\n    searchMode: 'contain',\r\n    formatSuggestion: function (feature) {\r\n      return feature.properties[this.options.searchFields[0]];\r\n    }\r\n  },\r\n\r\n  initialize: function (options) {\r\n    FeatureLayerService.prototype.initialize.call(this, options);\r\n    if (typeof this.options.searchFields === 'string') {\r\n      this.options.searchFields = [this.options.searchFields];\r\n    }\r\n    this._suggestionsQuery = this.query();\r\n    this._resultsQuery = this.query();\r\n  },\r\n\r\n  suggestions: function (text, bounds, callback) {\r\n    var query = this._suggestionsQuery.where(this._buildQuery(text))\r\n      .returnGeometry(false);\r\n\r\n    if (bounds) {\r\n      query.intersects(bounds);\r\n    }\r\n\r\n    if (this.options.idField) {\r\n      query.fields([this.options.idField].concat(this.options.searchFields));\r\n    }\r\n\r\n    var request = query.run(function (error, results, raw) {\r\n      if (error) {\r\n        callback(error, []);\r\n      } else {\r\n        this.options.idField = raw.objectIdFieldName;\r\n        var suggestions = [];\r\n        for (var i = results.features.length - 1; i >= 0; i--) {\r\n          var feature = results.features[i];\r\n          suggestions.push({\r\n            text: this.options.formatSuggestion.call(this, feature),\r\n            unformattedText: feature.properties[this.options.searchFields[0]],\r\n            magicKey: feature.id\r\n          });\r\n        }\r\n        callback(error, suggestions.slice(0, this.options.maxResults));\r\n      }\r\n    }, this);\r\n\r\n    return request;\r\n  },\r\n\r\n  results: function (text, key, bounds, callback) {\r\n    var query = this._resultsQuery;\r\n\r\n    if (key) {\r\n      delete query.params.where;\r\n      query.featureIds([key]);\r\n    } else {\r\n      query.where(this._buildQuery(text));\r\n    }\r\n\r\n    if (bounds) {\r\n      query.within(bounds);\r\n    }\r\n\r\n    return query.run(Util.bind(function (error, features) {\r\n      var results = [];\r\n      for (var i = 0; i < features.features.length; i++) {\r\n        var feature = features.features[i];\r\n        if (feature) {\r\n          var bounds = this._featureBounds(feature);\r\n\r\n          var result = {\r\n            latlng: bounds.getCenter(),\r\n            bounds: bounds,\r\n            text: this.options.formatSuggestion.call(this, feature),\r\n            properties: feature.properties,\r\n            geojson: feature\r\n          };\r\n\r\n          results.push(result);\r\n\r\n          // clear query parameters for the next search\r\n          delete this._resultsQuery.params['objectIds'];\r\n        }\r\n      }\r\n      callback(error, results);\r\n    }, this));\r\n  },\r\n\r\n  orderBy: function (fieldName, order) {\r\n    this._suggestionsQuery.orderBy(fieldName, order);\r\n  },\r\n\r\n  _buildQuery: function (text) {\r\n    var queryString = [];\r\n\r\n    for (var i = this.options.searchFields.length - 1; i >= 0; i--) {\r\n      var field = 'upper(\"' + this.options.searchFields[i] + '\")';\r\n      if (this.options.searchMode === 'contain') {\r\n        queryString.push(field + \" LIKE upper('%\" + text + \"%')\");\r\n      } else if (this.options.searchMode === 'startWith') {\r\n        queryString.push(field + \" LIKE upper('\" + text + \"%')\");\r\n      } else if (this.options.searchMode === 'endWith') {\r\n        queryString.push(field + \" LIKE upper('%\" + text + \"')\");\r\n      } else if (this.options.searchMode === 'strict') {\r\n        queryString.push(field + \" LIKE upper('\" + text + \"')\");\r\n      } else {\r\n        throw new Error('L.esri.Geocoding.featureLayerProvider: Invalid parameter for \"searchMode\". Use one of \"contain\", \"startWith\", \"endWith\", or \"strict\"');\r\n      }\r\n    }\r\n    if (this.options.where) {\r\n      return this.options.where + ' AND (' + queryString.join(' OR ') + ')';\r\n    } else {\r\n      return queryString.join(' OR ');\r\n    }\r\n  },\r\n\r\n  _featureBounds: function (feature) {\r\n    var geojson = geoJson(feature);\r\n    if (feature.geometry.type === 'Point') {\r\n      var center = geojson.getBounds().getCenter();\r\n      var lngRadius = ((this.options.bufferRadius / 40075017) * 360) / Math.cos((180 / Math.PI) * center.lat);\r\n      var latRadius = (this.options.bufferRadius / 40075017) * 360;\r\n      return latLngBounds([center.lat - latRadius, center.lng - lngRadius], [center.lat + latRadius, center.lng + lngRadius]);\r\n    } else {\r\n      return geojson.getBounds();\r\n    }\r\n  }\r\n});\r\n\r\nexport function featureLayerProvider (options) {\r\n  return new FeatureLayerProvider(options);\r\n}\r\n\r\nexport default featureLayerProvider;\r\n","import { Util, geoJson, latLngBounds } from 'leaflet';\r\nimport { MapService } from 'esri-leaflet';\r\n\r\nexport var MapServiceProvider = MapService.extend({\r\n  options: {\r\n    layers: [0],\r\n    label: 'Map Service',\r\n    bufferRadius: 1000,\r\n    maxResults: 5,\r\n    formatSuggestion: function (feature) {\r\n      return feature.properties[feature.displayFieldName] + ' <small>' + feature.layerName + '</small>';\r\n    }\r\n  },\r\n\r\n  initialize: function (options) {\r\n    MapService.prototype.initialize.call(this, options);\r\n    this._getIdFields();\r\n  },\r\n\r\n  suggestions: function (text, bounds, callback) {\r\n    var request = this.find().text(text).fields(this.options.searchFields).returnGeometry(false).layers(this.options.layers);\r\n\r\n    return request.run(function (error, results, raw) {\r\n      var suggestions = [];\r\n      if (!error) {\r\n        var count = Math.min(this.options.maxResults, results.features.length);\r\n        raw.results = raw.results.reverse();\r\n        for (var i = 0; i < count; i++) {\r\n          var feature = results.features[i];\r\n          var result = raw.results[i];\r\n          var layer = result.layerId;\r\n          var idField = this._idFields[layer];\r\n          feature.layerId = layer;\r\n          feature.layerName = this._layerNames[layer];\r\n          feature.displayFieldName = this._displayFields[layer];\r\n          if (idField) {\r\n            suggestions.push({\r\n              text: this.options.formatSuggestion.call(this, feature),\r\n              unformattedText: feature.properties[feature.displayFieldName],\r\n              magicKey: result.attributes[idField] + ':' + layer\r\n            });\r\n          }\r\n        }\r\n      }\r\n      callback(error, suggestions.reverse());\r\n    }, this);\r\n  },\r\n\r\n  results: function (text, key, bounds, callback) {\r\n    var results = [];\r\n    var request;\r\n\r\n    if (key) {\r\n      var featureId = key.split(':')[0];\r\n      var layer = key.split(':')[1];\r\n      request = this.query().layer(layer).featureIds(featureId);\r\n    } else {\r\n      request = this.find().text(text).fields(this.options.searchFields).layers(this.options.layers);\r\n    }\r\n\r\n    return request.run(function (error, features, response) {\r\n      if (!error) {\r\n        if (response.results) {\r\n          response.results = response.results.reverse();\r\n        }\r\n        for (var i = 0; i < features.features.length; i++) {\r\n          var feature = features.features[i];\r\n          layer = layer || response.results[i].layerId;\r\n\r\n          if (feature && layer !== undefined) {\r\n            var bounds = this._featureBounds(feature);\r\n            feature.layerId = layer;\r\n            feature.layerName = this._layerNames[layer];\r\n            feature.displayFieldName = this._displayFields[layer];\r\n\r\n            var result = {\r\n              latlng: bounds.getCenter(),\r\n              bounds: bounds,\r\n              text: this.options.formatSuggestion.call(this, feature),\r\n              properties: feature.properties,\r\n              geojson: feature\r\n            };\r\n\r\n            results.push(result);\r\n          }\r\n        }\r\n      }\r\n      callback(error, results.reverse());\r\n    }, this);\r\n  },\r\n\r\n  _featureBounds: function (feature) {\r\n    var geojson = geoJson(feature);\r\n    if (feature.geometry.type === 'Point') {\r\n      var center = geojson.getBounds().getCenter();\r\n      var lngRadius = ((this.options.bufferRadius / 40075017) * 360) / Math.cos((180 / Math.PI) * center.lat);\r\n      var latRadius = (this.options.bufferRadius / 40075017) * 360;\r\n      return latLngBounds([center.lat - latRadius, center.lng - lngRadius], [center.lat + latRadius, center.lng + lngRadius]);\r\n    } else {\r\n      return geojson.getBounds();\r\n    }\r\n  },\r\n\r\n  _layerMetadataCallback: function (layerid) {\r\n    return Util.bind(function (error, metadata) {\r\n      if (error) { return; }\r\n      this._displayFields[layerid] = metadata.displayField;\r\n      this._layerNames[layerid] = metadata.name;\r\n      for (var i = 0; i < metadata.fields.length; i++) {\r\n        var field = metadata.fields[i];\r\n        if (field.type === 'esriFieldTypeOID') {\r\n          this._idFields[layerid] = field.name;\r\n          break;\r\n        }\r\n      }\r\n    }, this);\r\n  },\r\n\r\n  _getIdFields: function () {\r\n    this._idFields = {};\r\n    this._displayFields = {};\r\n    this._layerNames = {};\r\n    for (var i = 0; i < this.options.layers.length; i++) {\r\n      var layer = this.options.layers[i];\r\n      this.get(layer, {}, this._layerMetadataCallback(layer));\r\n    }\r\n  }\r\n});\r\n\r\nexport function mapServiceProvider (options) {\r\n  return new MapServiceProvider(options);\r\n}\r\n\r\nexport default mapServiceProvider;\r\n","import { GeocodeService } from '../Services/Geocode';\r\n\r\nexport var GeocodeServiceProvider = GeocodeService.extend({\r\n  options: {\r\n    label: 'Geocode Server',\r\n    maxResults: 5\r\n  },\r\n\r\n  suggestions: function (text, bounds, callback) {\r\n    if (this.options.supportsSuggest) {\r\n      var request = this.suggest().text(text);\r\n      if (bounds) {\r\n        request.within(bounds);\r\n      }\r\n\r\n      return request.run(function (error, results, response) {\r\n        var suggestions = [];\r\n        if (!error) {\r\n          while (response.suggestions.length && suggestions.length <= (this.options.maxResults - 1)) {\r\n            var suggestion = response.suggestions.shift();\r\n            if (!suggestion.isCollection) {\r\n              suggestions.push({\r\n                text: suggestion.text,\r\n                unformattedText: suggestion.text,\r\n                magicKey: suggestion.magicKey\r\n              });\r\n            }\r\n          }\r\n        }\r\n        callback(error, suggestions);\r\n      }, this);\r\n    } else {\r\n      callback(undefined, []);\r\n      return false;\r\n    }\r\n  },\r\n\r\n  results: function (text, key, bounds, callback) {\r\n    var request = this.geocode().text(text);\r\n\r\n    if (key) {\r\n      request.key(key);\r\n    }\r\n\r\n    request.maxLocations(this.options.maxResults);\r\n\r\n    if (bounds) {\r\n      request.within(bounds);\r\n    }\r\n\r\n    return request.run(function (error, response) {\r\n      callback(error, response.results);\r\n    }, this);\r\n  }\r\n});\r\n\r\nexport function geocodeServiceProvider (options) {\r\n  return new GeocodeServiceProvider(options);\r\n}\r\n\r\nexport default geocodeServiceProvider;\r\n"]},"metadata":{},"sourceType":"script"}