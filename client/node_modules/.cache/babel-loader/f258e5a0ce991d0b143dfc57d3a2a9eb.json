{"ast":null,"code":"import { LatLngBounds, toLatLngBounds as latLngBounds, Layer, Browser, Util, Point, Bounds } from 'leaflet';\nexport var FeatureGrid = Layer.extend({\n  // @section\n  // @aka GridLayer options\n  options: {\n    // @option cellSize: Number|Point = 256\n    // Width and height of cells in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.\n    cellSize: 512,\n    // @option updateWhenIdle: Boolean = (depends)\n    // Load new cells only when panning ends.\n    // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.\n    // `false` otherwise in order to display new cells _during_ panning, since it is easy to pan outside the\n    // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.\n    updateWhenIdle: Browser.mobile,\n    // @option updateInterval: Number = 150\n    // Cells will not update more than once every `updateInterval` milliseconds when panning.\n    updateInterval: 150,\n    // @option noWrap: Boolean = false\n    // Whether the layer is wrapped around the antimeridian. If `true`, the\n    // GridLayer will only be displayed once at low zoom levels. Has no\n    // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used\n    // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting\n    // cells outside the CRS limits.\n    noWrap: false,\n    // @option keepBuffer: Number = 1.5\n    // When panning the map, keep this many rows and columns of cells before unloading them.\n    keepBuffer: 1.5\n  },\n  initialize: function initialize(options) {\n    Util.setOptions(this, options);\n  },\n  onAdd: function onAdd(map) {\n    this._cells = {};\n    this._activeCells = {};\n\n    this._resetView();\n\n    this._update();\n  },\n  onRemove: function onRemove(map) {\n    this._removeAllCells();\n\n    this._cellZoom = undefined;\n  },\n  // @method isLoading: Boolean\n  // Returns `true` if any cell in the grid layer has not finished loading.\n  isLoading: function isLoading() {\n    return this._loading;\n  },\n  // @method redraw: this\n  // Causes the layer to clear all the cells and request them again.\n  redraw: function redraw() {\n    if (this._map) {\n      this._removeAllCells();\n\n      this._update();\n    }\n\n    return this;\n  },\n  getEvents: function getEvents() {\n    var events = {\n      viewprereset: this._invalidateAll,\n      viewreset: this._resetView,\n      zoom: this._resetView,\n      moveend: this._onMoveEnd\n    };\n\n    if (!this.options.updateWhenIdle) {\n      // update cells on move, but not more often than once per given interval\n      if (!this._onMove) {\n        this._onMove = Util.throttle(this._onMoveEnd, this.options.updateInterval, this);\n      }\n\n      events.move = this._onMove;\n    }\n\n    return events;\n  },\n  // @section Extension methods\n  // Layers extending `GridLayer` shall reimplement the following method.\n  // @method createCell(coords: Object, done?: Function): HTMLElement\n  // Called only internally, must be overridden by classes extending `GridLayer`.\n  // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback\n  // is specified, it must be called when the cell has finished loading and drawing.\n  createCell: function createCell() {\n    return document.createElement('div');\n  },\n  removeCell: function removeCell() {\n    return;\n  },\n  reuseCell: function reuseCell() {\n    return;\n  },\n  cellLeave: function cellLeave() {\n    return;\n  },\n  cellEnter: function cellEnter() {\n    return;\n  },\n  // @section\n  // @method getCellSize: Point\n  // Normalizes the [cellSize option](#gridlayer-cellsize) into a point. Used by the `createCell()` method.\n  getCellSize: function getCellSize() {\n    var s = this.options.cellSize;\n    return s instanceof Point ? s : new Point(s, s);\n  },\n  _pruneCells: function _pruneCells() {\n    if (!this._map) {\n      return;\n    }\n\n    var key, cell;\n\n    for (key in this._cells) {\n      cell = this._cells[key];\n      cell.retain = cell.current;\n    }\n\n    for (key in this._cells) {\n      cell = this._cells[key];\n\n      if (cell.current && !cell.active) {\n        var coords = cell.coords;\n\n        if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {\n          this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);\n        }\n      }\n    }\n\n    for (key in this._cells) {\n      if (!this._cells[key].retain) {\n        this._removeCell(key);\n      }\n    }\n  },\n  _removeAllCells: function _removeAllCells() {\n    for (var key in this._cells) {\n      this._removeCell(key);\n    }\n  },\n  _invalidateAll: function _invalidateAll() {\n    this._removeAllCells();\n\n    this._cellZoom = undefined;\n  },\n  _retainParent: function _retainParent(x, y, z, minZoom) {\n    var x2 = Math.floor(x / 2);\n    var y2 = Math.floor(y / 2);\n    var z2 = z - 1;\n    var coords2 = new Point(+x2, +y2);\n    coords2.z = +z2;\n\n    var key = this._cellCoordsToKey(coords2);\n\n    var cell = this._cells[key];\n\n    if (cell && cell.active) {\n      cell.retain = true;\n      return true;\n    } else if (cell && cell.loaded) {\n      cell.retain = true;\n    }\n\n    if (z2 > minZoom) {\n      return this._retainParent(x2, y2, z2, minZoom);\n    }\n\n    return false;\n  },\n  _retainChildren: function _retainChildren(x, y, z, maxZoom) {\n    for (var i = 2 * x; i < 2 * x + 2; i++) {\n      for (var j = 2 * y; j < 2 * y + 2; j++) {\n        var coords = new Point(i, j);\n        coords.z = z + 1;\n\n        var key = this._cellCoordsToKey(coords);\n\n        var cell = this._cells[key];\n\n        if (cell && cell.active) {\n          cell.retain = true;\n          continue;\n        } else if (cell && cell.loaded) {\n          cell.retain = true;\n        }\n\n        if (z + 1 < maxZoom) {\n          this._retainChildren(i, j, z + 1, maxZoom);\n        }\n      }\n    }\n  },\n  _resetView: function _resetView(e) {\n    var animating = e && (e.pinch || e.flyTo);\n\n    if (animating) {\n      return;\n    }\n\n    this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);\n  },\n  _setView: function _setView(center, zoom, noPrune, noUpdate) {\n    var cellZoom = Math.round(zoom);\n\n    if (!noUpdate) {\n      this._cellZoom = cellZoom;\n\n      if (this._abortLoading) {\n        this._abortLoading();\n      }\n\n      this._resetGrid();\n\n      if (cellZoom !== undefined) {\n        this._update(center);\n      }\n\n      if (!noPrune) {\n        this._pruneCells();\n      } // Flag to prevent _updateOpacity from pruning cells during\n      // a zoom anim or a pinch gesture\n\n\n      this._noPrune = !!noPrune;\n    }\n  },\n  _resetGrid: function _resetGrid() {\n    var map = this._map;\n    var crs = map.options.crs;\n    var cellSize = this._cellSize = this.getCellSize();\n    var cellZoom = this._cellZoom;\n\n    var bounds = this._map.getPixelWorldBounds(this._cellZoom);\n\n    if (bounds) {\n      this._globalCellRange = this._pxBoundsToCellRange(bounds);\n    }\n\n    this._wrapX = crs.wrapLng && !this.options.noWrap && [Math.floor(map.project([0, crs.wrapLng[0]], cellZoom).x / cellSize.x), Math.ceil(map.project([0, crs.wrapLng[1]], cellZoom).x / cellSize.y)];\n    this._wrapY = crs.wrapLat && !this.options.noWrap && [Math.floor(map.project([crs.wrapLat[0], 0], cellZoom).y / cellSize.x), Math.ceil(map.project([crs.wrapLat[1], 0], cellZoom).y / cellSize.y)];\n  },\n  _onMoveEnd: function _onMoveEnd(e) {\n    var animating = e && (e.pinch || e.flyTo);\n\n    if (animating || !this._map || this._map._animatingZoom) {\n      return;\n    }\n\n    this._update();\n  },\n  _getCelldPixelBounds: function _getCelldPixelBounds(center) {\n    var map = this._map;\n    var mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom();\n    var scale = map.getZoomScale(mapZoom, this._cellZoom);\n    var pixelCenter = map.project(center, this._cellZoom).floor();\n    var halfSize = map.getSize().divideBy(scale * 2);\n    return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\n  },\n  // Private method to load cells in the grid's active zoom level according to map bounds\n  _update: function _update(center) {\n    var map = this._map;\n\n    if (!map) {\n      return;\n    }\n\n    var zoom = Math.round(map.getZoom());\n\n    if (center === undefined) {\n      center = map.getCenter();\n    }\n\n    var pixelBounds = this._getCelldPixelBounds(center);\n\n    var cellRange = this._pxBoundsToCellRange(pixelBounds);\n\n    var cellCenter = cellRange.getCenter();\n    var queue = [];\n    var margin = this.options.keepBuffer;\n    var noPruneRange = new Bounds(cellRange.getBottomLeft().subtract([margin, -margin]), cellRange.getTopRight().add([margin, -margin])); // Sanity check: panic if the cell range contains Infinity somewhere.\n\n    if (!(isFinite(cellRange.min.x) && isFinite(cellRange.min.y) && isFinite(cellRange.max.x) && isFinite(cellRange.max.y))) {\n      throw new Error('Attempted to load an infinite number of cells');\n    }\n\n    for (var key in this._cells) {\n      var c = this._cells[key].coords;\n\n      if (c.z !== this._cellZoom || !noPruneRange.contains(new Point(c.x, c.y))) {\n        this._cells[key].current = false;\n      }\n    } // _update just loads more cells. If the cell zoom level differs too much\n    // from the map's, let _setView reset levels and prune old cells.\n\n\n    if (Math.abs(zoom - this._cellZoom) > 1) {\n      this._setView(center, zoom);\n\n      return;\n    } // create a queue of coordinates to load cells from\n\n\n    for (var j = cellRange.min.y; j <= cellRange.max.y; j++) {\n      for (var i = cellRange.min.x; i <= cellRange.max.x; i++) {\n        var coords = new Point(i, j);\n        coords.z = this._cellZoom;\n\n        if (!this._isValidCell(coords)) {\n          continue;\n        }\n\n        var cell = this._cells[this._cellCoordsToKey(coords)];\n\n        if (cell) {\n          cell.current = true;\n        } else {\n          queue.push(coords);\n        }\n      }\n    } // sort cell queue to load cells in order of their distance to center\n\n\n    queue.sort(function (a, b) {\n      return a.distanceTo(cellCenter) - b.distanceTo(cellCenter);\n    });\n\n    if (queue.length !== 0) {\n      // if it's the first batch of cells to load\n      if (!this._loading) {\n        this._loading = true;\n      }\n\n      for (i = 0; i < queue.length; i++) {\n        var _key = this._cellCoordsToKey(queue[i]);\n\n        var _coords = this._keyToCellCoords(_key);\n\n        if (this._activeCells[_coords]) {\n          this._reuseCell(queue[i]);\n        } else {\n          this._createCell(queue[i]);\n        }\n      }\n    }\n  },\n  _isValidCell: function _isValidCell(coords) {\n    var crs = this._map.options.crs;\n\n    if (!crs.infinite) {\n      // don't load cell if it's out of bounds and not wrapped\n      var bounds = this._globalCellRange;\n\n      if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {\n        return false;\n      }\n    }\n\n    if (!this.options.bounds) {\n      return true;\n    } // don't load cell if it doesn't intersect the bounds in options\n\n\n    var cellBounds = this._cellCoordsToBounds(coords);\n\n    return latLngBounds(this.options.bounds).overlaps(cellBounds);\n  },\n  _keyToBounds: function _keyToBounds(key) {\n    return this._cellCoordsToBounds(this._keyToCellCoords(key));\n  },\n  _cellCoordsToNwSe: function _cellCoordsToNwSe(coords) {\n    var map = this._map;\n    var cellSize = this.getCellSize();\n    var nwPoint = coords.scaleBy(cellSize);\n    var sePoint = nwPoint.add(cellSize);\n    var nw = map.unproject(nwPoint, coords.z);\n    var se = map.unproject(sePoint, coords.z);\n    return [nw, se];\n  },\n  // converts cell coordinates to its geographical bounds\n  _cellCoordsToBounds: function _cellCoordsToBounds(coords) {\n    var bp = this._cellCoordsToNwSe(coords);\n\n    var bounds = new LatLngBounds(bp[0], bp[1]);\n\n    if (!this.options.noWrap) {\n      bounds = this._map.wrapLatLngBounds(bounds);\n    }\n\n    return bounds;\n  },\n  // converts cell coordinates to key for the cell cache\n  _cellCoordsToKey: function _cellCoordsToKey(coords) {\n    return coords.x + ':' + coords.y + ':' + coords.z;\n  },\n  // converts cell cache key to coordinates\n  _keyToCellCoords: function _keyToCellCoords(key) {\n    var k = key.split(':');\n    var coords = new Point(+k[0], +k[1]);\n    coords.z = +k[2];\n    return coords;\n  },\n  _removeCell: function _removeCell(key) {\n    var cell = this._cells[key];\n\n    if (!cell) {\n      return;\n    }\n\n    var coords = this._keyToCellCoords(key);\n\n    var wrappedCoords = this._wrapCoords(coords);\n\n    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));\n\n    cell.current = false;\n    delete this._cells[key];\n    this._activeCells[key] = cell;\n    this.cellLeave(cellBounds, wrappedCoords, key);\n    this.fire('cellleave', {\n      key: key,\n      coords: wrappedCoords,\n      bounds: cellBounds\n    });\n  },\n  _reuseCell: function _reuseCell(coords) {\n    var key = this._cellCoordsToKey(coords); // save cell in cache\n\n\n    this._cells[key] = this._activeCells[key];\n    this._cells[key].current = true;\n\n    var wrappedCoords = this._wrapCoords(coords);\n\n    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));\n\n    this.cellEnter(cellBounds, wrappedCoords, key);\n    this.fire('cellenter', {\n      key: key,\n      coords: wrappedCoords,\n      bounds: cellBounds\n    });\n  },\n  _createCell: function _createCell(coords) {\n    var key = this._cellCoordsToKey(coords);\n\n    var wrappedCoords = this._wrapCoords(coords);\n\n    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));\n\n    this.createCell(cellBounds, wrappedCoords, key);\n    this.fire('cellcreate', {\n      key: key,\n      coords: wrappedCoords,\n      bounds: cellBounds\n    }); // save cell in cache\n\n    this._cells[key] = {\n      coords: coords,\n      current: true\n    };\n    Util.requestAnimFrame(this._pruneCells, this);\n  },\n  _cellReady: function _cellReady(coords, err, cell) {\n    var key = this._cellCoordsToKey(coords);\n\n    cell = this._cells[key];\n\n    if (!cell) {\n      return;\n    }\n\n    cell.loaded = +new Date();\n    cell.active = true;\n  },\n  _getCellPos: function _getCellPos(coords) {\n    return coords.scaleBy(this.getCellSize());\n  },\n  _wrapCoords: function _wrapCoords(coords) {\n    var newCoords = new Point(this._wrapX ? Util.wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? Util.wrapNum(coords.y, this._wrapY) : coords.y);\n    newCoords.z = coords.z;\n    return newCoords;\n  },\n  _pxBoundsToCellRange: function _pxBoundsToCellRange(bounds) {\n    var cellSize = this.getCellSize();\n    return new Bounds(bounds.min.unscaleBy(cellSize).floor(), bounds.max.unscaleBy(cellSize).ceil().subtract([1, 1]));\n  }\n});","map":{"version":3,"sources":["D:/Web/mohi/client/node_modules/esri-leaflet/src/Layers/FeatureLayer/FeatureGrid.js"],"names":["LatLngBounds","toLatLngBounds","latLngBounds","Layer","Browser","Util","Point","Bounds","FeatureGrid","extend","options","cellSize","updateWhenIdle","mobile","updateInterval","noWrap","keepBuffer","initialize","setOptions","onAdd","map","_cells","_activeCells","_resetView","_update","onRemove","_removeAllCells","_cellZoom","undefined","isLoading","_loading","redraw","_map","getEvents","events","viewprereset","_invalidateAll","viewreset","zoom","moveend","_onMoveEnd","_onMove","throttle","move","createCell","document","createElement","removeCell","reuseCell","cellLeave","cellEnter","getCellSize","s","_pruneCells","key","cell","retain","current","active","coords","_retainParent","x","y","z","_retainChildren","_removeCell","minZoom","x2","Math","floor","y2","z2","coords2","_cellCoordsToKey","loaded","maxZoom","i","j","e","animating","pinch","flyTo","_setView","getCenter","getZoom","center","noPrune","noUpdate","cellZoom","round","_abortLoading","_resetGrid","_noPrune","crs","_cellSize","bounds","getPixelWorldBounds","_globalCellRange","_pxBoundsToCellRange","_wrapX","wrapLng","project","ceil","_wrapY","wrapLat","_animatingZoom","_getCelldPixelBounds","mapZoom","max","_animateToZoom","scale","getZoomScale","pixelCenter","halfSize","getSize","divideBy","subtract","add","pixelBounds","cellRange","cellCenter","queue","margin","noPruneRange","getBottomLeft","getTopRight","isFinite","min","Error","c","contains","abs","_isValidCell","push","sort","a","b","distanceTo","length","_key","_coords","_keyToCellCoords","_reuseCell","_createCell","infinite","cellBounds","_cellCoordsToBounds","overlaps","_keyToBounds","_cellCoordsToNwSe","nwPoint","scaleBy","sePoint","nw","unproject","se","bp","wrapLatLngBounds","k","split","wrappedCoords","_wrapCoords","fire","requestAnimFrame","_cellReady","err","Date","_getCellPos","newCoords","wrapNum","unscaleBy"],"mappings":"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","sourcesContent":["import {\r\n  LatLngBounds,\r\n  toLatLngBounds as latLngBounds,\r\n  Layer,\r\n  Browser,\r\n  Util,\r\n  Point,\r\n  Bounds\r\n} from 'leaflet';\r\n\r\nexport var FeatureGrid = Layer.extend({\r\n  // @section\r\n  // @aka GridLayer options\r\n  options: {\r\n    // @option cellSize: Number|Point = 256\r\n    // Width and height of cells in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.\r\n    cellSize: 512,\r\n\r\n    // @option updateWhenIdle: Boolean = (depends)\r\n    // Load new cells only when panning ends.\r\n    // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.\r\n    // `false` otherwise in order to display new cells _during_ panning, since it is easy to pan outside the\r\n    // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.\r\n    updateWhenIdle: Browser.mobile,\r\n\r\n    // @option updateInterval: Number = 150\r\n    // Cells will not update more than once every `updateInterval` milliseconds when panning.\r\n    updateInterval: 150,\r\n\r\n    // @option noWrap: Boolean = false\r\n    // Whether the layer is wrapped around the antimeridian. If `true`, the\r\n    // GridLayer will only be displayed once at low zoom levels. Has no\r\n    // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used\r\n    // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting\r\n    // cells outside the CRS limits.\r\n    noWrap: false,\r\n\r\n    // @option keepBuffer: Number = 1.5\r\n    // When panning the map, keep this many rows and columns of cells before unloading them.\r\n    keepBuffer: 1.5\r\n  },\r\n\r\n  initialize: function (options) {\r\n    Util.setOptions(this, options);\r\n  },\r\n\r\n  onAdd: function (map) {\r\n    this._cells = {};\r\n    this._activeCells = {};\r\n    this._resetView();\r\n    this._update();\r\n  },\r\n\r\n  onRemove: function (map) {\r\n    this._removeAllCells();\r\n    this._cellZoom = undefined;\r\n  },\r\n\r\n  // @method isLoading: Boolean\r\n  // Returns `true` if any cell in the grid layer has not finished loading.\r\n  isLoading: function () {\r\n    return this._loading;\r\n  },\r\n\r\n  // @method redraw: this\r\n  // Causes the layer to clear all the cells and request them again.\r\n  redraw: function () {\r\n    if (this._map) {\r\n      this._removeAllCells();\r\n      this._update();\r\n    }\r\n    return this;\r\n  },\r\n\r\n  getEvents: function () {\r\n    var events = {\r\n      viewprereset: this._invalidateAll,\r\n      viewreset: this._resetView,\r\n      zoom: this._resetView,\r\n      moveend: this._onMoveEnd\r\n    };\r\n\r\n    if (!this.options.updateWhenIdle) {\r\n      // update cells on move, but not more often than once per given interval\r\n      if (!this._onMove) {\r\n        this._onMove = Util.throttle(\r\n          this._onMoveEnd,\r\n          this.options.updateInterval,\r\n          this\r\n        );\r\n      }\r\n\r\n      events.move = this._onMove;\r\n    }\r\n\r\n    return events;\r\n  },\r\n\r\n  // @section Extension methods\r\n  // Layers extending `GridLayer` shall reimplement the following method.\r\n  // @method createCell(coords: Object, done?: Function): HTMLElement\r\n  // Called only internally, must be overridden by classes extending `GridLayer`.\r\n  // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback\r\n  // is specified, it must be called when the cell has finished loading and drawing.\r\n  createCell: function () {\r\n    return document.createElement('div');\r\n  },\r\n\r\n  removeCell: function () {\r\n    return;\r\n  },\r\n\r\n  reuseCell: function () {\r\n    return;\r\n  },\r\n\r\n  cellLeave: function () {\r\n    return;\r\n  },\r\n\r\n  cellEnter: function () {\r\n    return;\r\n  },\r\n  // @section\r\n  // @method getCellSize: Point\r\n  // Normalizes the [cellSize option](#gridlayer-cellsize) into a point. Used by the `createCell()` method.\r\n  getCellSize: function () {\r\n    var s = this.options.cellSize;\r\n    return s instanceof Point ? s : new Point(s, s);\r\n  },\r\n\r\n  _pruneCells: function () {\r\n    if (!this._map) {\r\n      return;\r\n    }\r\n\r\n    var key, cell;\r\n\r\n    for (key in this._cells) {\r\n      cell = this._cells[key];\r\n      cell.retain = cell.current;\r\n    }\r\n\r\n    for (key in this._cells) {\r\n      cell = this._cells[key];\r\n      if (cell.current && !cell.active) {\r\n        var coords = cell.coords;\r\n        if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {\r\n          this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);\r\n        }\r\n      }\r\n    }\r\n\r\n    for (key in this._cells) {\r\n      if (!this._cells[key].retain) {\r\n        this._removeCell(key);\r\n      }\r\n    }\r\n  },\r\n\r\n  _removeAllCells: function () {\r\n    for (var key in this._cells) {\r\n      this._removeCell(key);\r\n    }\r\n  },\r\n\r\n  _invalidateAll: function () {\r\n    this._removeAllCells();\r\n\r\n    this._cellZoom = undefined;\r\n  },\r\n\r\n  _retainParent: function (x, y, z, minZoom) {\r\n    var x2 = Math.floor(x / 2);\r\n    var y2 = Math.floor(y / 2);\r\n    var z2 = z - 1;\r\n    var coords2 = new Point(+x2, +y2);\r\n    coords2.z = +z2;\r\n\r\n    var key = this._cellCoordsToKey(coords2);\r\n    var cell = this._cells[key];\r\n\r\n    if (cell && cell.active) {\r\n      cell.retain = true;\r\n      return true;\r\n    } else if (cell && cell.loaded) {\r\n      cell.retain = true;\r\n    }\r\n\r\n    if (z2 > minZoom) {\r\n      return this._retainParent(x2, y2, z2, minZoom);\r\n    }\r\n\r\n    return false;\r\n  },\r\n\r\n  _retainChildren: function (x, y, z, maxZoom) {\r\n    for (var i = 2 * x; i < 2 * x + 2; i++) {\r\n      for (var j = 2 * y; j < 2 * y + 2; j++) {\r\n        var coords = new Point(i, j);\r\n        coords.z = z + 1;\r\n\r\n        var key = this._cellCoordsToKey(coords);\r\n        var cell = this._cells[key];\r\n\r\n        if (cell && cell.active) {\r\n          cell.retain = true;\r\n          continue;\r\n        } else if (cell && cell.loaded) {\r\n          cell.retain = true;\r\n        }\r\n\r\n        if (z + 1 < maxZoom) {\r\n          this._retainChildren(i, j, z + 1, maxZoom);\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  _resetView: function (e) {\r\n    var animating = e && (e.pinch || e.flyTo);\r\n\r\n    if (animating) {\r\n      return;\r\n    }\r\n\r\n    this._setView(\r\n      this._map.getCenter(),\r\n      this._map.getZoom(),\r\n      animating,\r\n      animating\r\n    );\r\n  },\r\n\r\n  _setView: function (center, zoom, noPrune, noUpdate) {\r\n    var cellZoom = Math.round(zoom);\r\n\r\n    if (!noUpdate) {\r\n      this._cellZoom = cellZoom;\r\n\r\n      if (this._abortLoading) {\r\n        this._abortLoading();\r\n      }\r\n\r\n      this._resetGrid();\r\n\r\n      if (cellZoom !== undefined) {\r\n        this._update(center);\r\n      }\r\n\r\n      if (!noPrune) {\r\n        this._pruneCells();\r\n      }\r\n\r\n      // Flag to prevent _updateOpacity from pruning cells during\r\n      // a zoom anim or a pinch gesture\r\n      this._noPrune = !!noPrune;\r\n    }\r\n  },\r\n\r\n  _resetGrid: function () {\r\n    var map = this._map;\r\n    var crs = map.options.crs;\r\n    var cellSize = (this._cellSize = this.getCellSize());\r\n    var cellZoom = this._cellZoom;\r\n\r\n    var bounds = this._map.getPixelWorldBounds(this._cellZoom);\r\n    if (bounds) {\r\n      this._globalCellRange = this._pxBoundsToCellRange(bounds);\r\n    }\r\n\r\n    this._wrapX = crs.wrapLng &&\r\n      !this.options.noWrap && [\r\n        Math.floor(map.project([0, crs.wrapLng[0]], cellZoom).x / cellSize.x),\r\n        Math.ceil(map.project([0, crs.wrapLng[1]], cellZoom).x / cellSize.y)\r\n      ];\r\n    this._wrapY = crs.wrapLat &&\r\n      !this.options.noWrap && [\r\n        Math.floor(map.project([crs.wrapLat[0], 0], cellZoom).y / cellSize.x),\r\n        Math.ceil(map.project([crs.wrapLat[1], 0], cellZoom).y / cellSize.y)\r\n      ];\r\n  },\r\n\r\n  _onMoveEnd: function (e) {\r\n    var animating = e && (e.pinch || e.flyTo);\r\n\r\n    if (animating || !this._map || this._map._animatingZoom) {\r\n      return;\r\n    }\r\n\r\n    this._update();\r\n  },\r\n\r\n  _getCelldPixelBounds: function (center) {\r\n    var map = this._map;\r\n    var mapZoom = map._animatingZoom\r\n      ? Math.max(map._animateToZoom, map.getZoom())\r\n      : map.getZoom();\r\n    var scale = map.getZoomScale(mapZoom, this._cellZoom);\r\n    var pixelCenter = map.project(center, this._cellZoom).floor();\r\n    var halfSize = map.getSize().divideBy(scale * 2);\r\n\r\n    return new Bounds(\r\n      pixelCenter.subtract(halfSize),\r\n      pixelCenter.add(halfSize)\r\n    );\r\n  },\r\n\r\n  // Private method to load cells in the grid's active zoom level according to map bounds\r\n  _update: function (center) {\r\n    var map = this._map;\r\n    if (!map) {\r\n      return;\r\n    }\r\n    var zoom = Math.round(map.getZoom());\r\n\r\n    if (center === undefined) {\r\n      center = map.getCenter();\r\n    }\r\n\r\n    var pixelBounds = this._getCelldPixelBounds(center);\r\n    var cellRange = this._pxBoundsToCellRange(pixelBounds);\r\n    var cellCenter = cellRange.getCenter();\r\n    var queue = [];\r\n    var margin = this.options.keepBuffer;\r\n    var noPruneRange = new Bounds(\r\n      cellRange.getBottomLeft().subtract([margin, -margin]),\r\n      cellRange.getTopRight().add([margin, -margin])\r\n    );\r\n\r\n    // Sanity check: panic if the cell range contains Infinity somewhere.\r\n    if (\r\n      !(\r\n        isFinite(cellRange.min.x) &&\r\n        isFinite(cellRange.min.y) &&\r\n        isFinite(cellRange.max.x) &&\r\n        isFinite(cellRange.max.y)\r\n      )\r\n    ) {\r\n      throw new Error('Attempted to load an infinite number of cells');\r\n    }\r\n\r\n    for (var key in this._cells) {\r\n      var c = this._cells[key].coords;\r\n      if (\r\n        c.z !== this._cellZoom ||\r\n        !noPruneRange.contains(new Point(c.x, c.y))\r\n      ) {\r\n        this._cells[key].current = false;\r\n      }\r\n    }\r\n\r\n    // _update just loads more cells. If the cell zoom level differs too much\r\n    // from the map's, let _setView reset levels and prune old cells.\r\n    if (Math.abs(zoom - this._cellZoom) > 1) {\r\n      this._setView(center, zoom);\r\n      return;\r\n    }\r\n\r\n    // create a queue of coordinates to load cells from\r\n    for (var j = cellRange.min.y; j <= cellRange.max.y; j++) {\r\n      for (var i = cellRange.min.x; i <= cellRange.max.x; i++) {\r\n        var coords = new Point(i, j);\r\n        coords.z = this._cellZoom;\r\n\r\n        if (!this._isValidCell(coords)) {\r\n          continue;\r\n        }\r\n\r\n        var cell = this._cells[this._cellCoordsToKey(coords)];\r\n        if (cell) {\r\n          cell.current = true;\r\n        } else {\r\n          queue.push(coords);\r\n        }\r\n      }\r\n    }\r\n\r\n    // sort cell queue to load cells in order of their distance to center\r\n    queue.sort(function (a, b) {\r\n      return a.distanceTo(cellCenter) - b.distanceTo(cellCenter);\r\n    });\r\n\r\n    if (queue.length !== 0) {\r\n      // if it's the first batch of cells to load\r\n      if (!this._loading) {\r\n        this._loading = true;\r\n      }\r\n\r\n      for (i = 0; i < queue.length; i++) {\r\n        var _key = this._cellCoordsToKey(queue[i]);\r\n        var _coords = this._keyToCellCoords(_key);\r\n        if (this._activeCells[_coords]) {\r\n          this._reuseCell(queue[i]);\r\n        } else {\r\n          this._createCell(queue[i]);\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  _isValidCell: function (coords) {\r\n    var crs = this._map.options.crs;\r\n\r\n    if (!crs.infinite) {\r\n      // don't load cell if it's out of bounds and not wrapped\r\n      var bounds = this._globalCellRange;\r\n      if (\r\n        (!crs.wrapLng &&\r\n          (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||\r\n        (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))\r\n      ) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    if (!this.options.bounds) {\r\n      return true;\r\n    }\r\n\r\n    // don't load cell if it doesn't intersect the bounds in options\r\n    var cellBounds = this._cellCoordsToBounds(coords);\r\n    return latLngBounds(this.options.bounds).overlaps(cellBounds);\r\n  },\r\n\r\n  _keyToBounds: function (key) {\r\n    return this._cellCoordsToBounds(this._keyToCellCoords(key));\r\n  },\r\n\r\n  _cellCoordsToNwSe: function (coords) {\r\n    var map = this._map;\r\n    var cellSize = this.getCellSize();\r\n    var nwPoint = coords.scaleBy(cellSize);\r\n    var sePoint = nwPoint.add(cellSize);\r\n    var nw = map.unproject(nwPoint, coords.z);\r\n    var se = map.unproject(sePoint, coords.z);\r\n\r\n    return [nw, se];\r\n  },\r\n\r\n  // converts cell coordinates to its geographical bounds\r\n  _cellCoordsToBounds: function (coords) {\r\n    var bp = this._cellCoordsToNwSe(coords);\r\n    var bounds = new LatLngBounds(bp[0], bp[1]);\r\n\r\n    if (!this.options.noWrap) {\r\n      bounds = this._map.wrapLatLngBounds(bounds);\r\n    }\r\n    return bounds;\r\n  },\r\n  // converts cell coordinates to key for the cell cache\r\n  _cellCoordsToKey: function (coords) {\r\n    return coords.x + ':' + coords.y + ':' + coords.z;\r\n  },\r\n\r\n  // converts cell cache key to coordinates\r\n  _keyToCellCoords: function (key) {\r\n    var k = key.split(':');\r\n    var coords = new Point(+k[0], +k[1]);\r\n\r\n    coords.z = +k[2];\r\n    return coords;\r\n  },\r\n\r\n  _removeCell: function (key) {\r\n    var cell = this._cells[key];\r\n\r\n    if (!cell) {\r\n      return;\r\n    }\r\n\r\n    var coords = this._keyToCellCoords(key);\r\n    var wrappedCoords = this._wrapCoords(coords);\r\n    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));\r\n\r\n    cell.current = false;\r\n\r\n    delete this._cells[key];\r\n    this._activeCells[key] = cell;\r\n\r\n    this.cellLeave(cellBounds, wrappedCoords, key);\r\n\r\n    this.fire('cellleave', {\r\n      key: key,\r\n      coords: wrappedCoords,\r\n      bounds: cellBounds\r\n    });\r\n  },\r\n\r\n  _reuseCell: function (coords) {\r\n    var key = this._cellCoordsToKey(coords);\r\n\r\n    // save cell in cache\r\n    this._cells[key] = this._activeCells[key];\r\n    this._cells[key].current = true;\r\n\r\n    var wrappedCoords = this._wrapCoords(coords);\r\n    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));\r\n\r\n    this.cellEnter(cellBounds, wrappedCoords, key);\r\n\r\n    this.fire('cellenter', {\r\n      key: key,\r\n      coords: wrappedCoords,\r\n      bounds: cellBounds\r\n    });\r\n  },\r\n\r\n  _createCell: function (coords) {\r\n    var key = this._cellCoordsToKey(coords);\r\n\r\n    var wrappedCoords = this._wrapCoords(coords);\r\n    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));\r\n\r\n    this.createCell(cellBounds, wrappedCoords, key);\r\n\r\n    this.fire('cellcreate', {\r\n      key: key,\r\n      coords: wrappedCoords,\r\n      bounds: cellBounds\r\n    });\r\n\r\n    // save cell in cache\r\n    this._cells[key] = {\r\n      coords: coords,\r\n      current: true\r\n    };\r\n\r\n    Util.requestAnimFrame(this._pruneCells, this);\r\n  },\r\n\r\n  _cellReady: function (coords, err, cell) {\r\n    var key = this._cellCoordsToKey(coords);\r\n\r\n    cell = this._cells[key];\r\n\r\n    if (!cell) {\r\n      return;\r\n    }\r\n\r\n    cell.loaded = +new Date();\r\n\r\n    cell.active = true;\r\n  },\r\n\r\n  _getCellPos: function (coords) {\r\n    return coords.scaleBy(this.getCellSize());\r\n  },\r\n\r\n  _wrapCoords: function (coords) {\r\n    var newCoords = new Point(\r\n      this._wrapX ? Util.wrapNum(coords.x, this._wrapX) : coords.x,\r\n      this._wrapY ? Util.wrapNum(coords.y, this._wrapY) : coords.y\r\n    );\r\n    newCoords.z = coords.z;\r\n    return newCoords;\r\n  },\r\n\r\n  _pxBoundsToCellRange: function (bounds) {\r\n    var cellSize = this.getCellSize();\r\n    return new Bounds(\r\n      bounds.min.unscaleBy(cellSize).floor(),\r\n      bounds.max.unscaleBy(cellSize).ceil().subtract([1, 1])\r\n    );\r\n  }\r\n});\r\n"]},"metadata":{},"sourceType":"module"}