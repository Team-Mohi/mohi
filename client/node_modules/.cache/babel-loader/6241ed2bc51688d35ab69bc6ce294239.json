{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @format\r\n * \r\n * @emails oncall+draft_js\r\n */\n'use strict';\n\nvar DOMObserver = require(\"./DOMObserver\");\n\nvar DraftModifier = require(\"./DraftModifier\");\n\nvar DraftOffsetKey = require(\"./DraftOffsetKey\");\n\nvar EditorState = require(\"./EditorState\");\n\nvar Keys = require(\"fbjs/lib/Keys\");\n\nvar UserAgent = require(\"fbjs/lib/UserAgent\");\n\nvar editOnSelect = require(\"./editOnSelect\");\n\nvar getContentEditableContainer = require(\"./getContentEditableContainer\");\n\nvar getDraftEditorSelection = require(\"./getDraftEditorSelection\");\n\nvar getEntityKeyForSelection = require(\"./getEntityKeyForSelection\");\n\nvar nullthrows = require(\"fbjs/lib/nullthrows\");\n\nvar isIE = UserAgent.isBrowser('IE');\n/**\r\n * Millisecond delay to allow `compositionstart` to fire again upon\r\n * `compositionend`.\r\n *\r\n * This is used for Korean input to ensure that typing can continue without\r\n * the editor trying to render too quickly. More specifically, Safari 7.1+\r\n * triggers `compositionstart` a little slower than Chrome/FF, which\r\n * leads to composed characters being resolved and re-render occurring\r\n * sooner than we want.\r\n */\n\nvar RESOLVE_DELAY = 20;\n/**\r\n * A handful of variables used to track the current composition and its\r\n * resolution status. These exist at the module level because it is not\r\n * possible to have compositions occurring in multiple editors simultaneously,\r\n * and it simplifies state management with respect to the DraftEditor component.\r\n */\n\nvar resolved = false;\nvar stillComposing = false;\nvar domObserver = null;\n\nfunction startDOMObserver(editor) {\n  if (!domObserver) {\n    domObserver = new DOMObserver(getContentEditableContainer(editor));\n    domObserver.start();\n  }\n}\n\nvar DraftEditorCompositionHandler = {\n  /**\r\n   * A `compositionstart` event has fired while we're still in composition\r\n   * mode. Continue the current composition session to prevent a re-render.\r\n   */\n  onCompositionStart: function onCompositionStart(editor) {\n    stillComposing = true;\n    startDOMObserver(editor);\n  },\n\n  /**\r\n   * Attempt to end the current composition session.\r\n   *\r\n   * Defer handling because browser will still insert the chars into active\r\n   * element after `compositionend`. If a `compositionstart` event fires\r\n   * before `resolveComposition` executes, our composition session will\r\n   * continue.\r\n   *\r\n   * The `resolved` flag is useful because certain IME interfaces fire the\r\n   * `compositionend` event multiple times, thus queueing up multiple attempts\r\n   * at handling the composition. Since handling the same composition event\r\n   * twice could break the DOM, we only use the first event. Example: Arabic\r\n   * Google Input Tools on Windows 8.1 fires `compositionend` three times.\r\n   */\n  onCompositionEnd: function onCompositionEnd(editor) {\n    resolved = false;\n    stillComposing = false;\n    setTimeout(function () {\n      if (!resolved) {\n        DraftEditorCompositionHandler.resolveComposition(editor);\n      }\n    }, RESOLVE_DELAY);\n  },\n  onSelect: editOnSelect,\n\n  /**\r\n   * In Safari, keydown events may fire when committing compositions. If\r\n   * the arrow keys are used to commit, prevent default so that the cursor\r\n   * doesn't move, otherwise it will jump back noticeably on re-render.\r\n   */\n  onKeyDown: function onKeyDown(editor, e) {\n    if (!stillComposing) {\n      // If a keydown event is received after compositionend but before the\n      // 20ms timer expires (ex: type option-E then backspace, or type A then\n      // backspace in 2-Set Korean), we should immediately resolve the\n      // composition and reinterpret the key press in edit mode.\n      DraftEditorCompositionHandler.resolveComposition(editor);\n\n      editor._onKeyDown(e);\n\n      return;\n    }\n\n    if (e.which === Keys.RIGHT || e.which === Keys.LEFT) {\n      e.preventDefault();\n    }\n  },\n\n  /**\r\n   * Keypress events may fire when committing compositions. In Firefox,\r\n   * pressing RETURN commits the composition and inserts extra newline\r\n   * characters that we do not want. `preventDefault` allows the composition\r\n   * to be committed while preventing the extra characters.\r\n   */\n  onKeyPress: function onKeyPress(_editor, e) {\n    if (e.which === Keys.RETURN) {\n      e.preventDefault();\n    }\n  },\n\n  /**\r\n   * Attempt to insert composed characters into the document.\r\n   *\r\n   * If we are still in a composition session, do nothing. Otherwise, insert\r\n   * the characters into the document and terminate the composition session.\r\n   *\r\n   * If no characters were composed -- for instance, the user\r\n   * deleted all composed characters and committed nothing new --\r\n   * force a re-render. We also re-render when the composition occurs\r\n   * at the beginning of a leaf, to ensure that if the browser has\r\n   * created a new text node for the composition, we will discard it.\r\n   *\r\n   * Resetting innerHTML will move focus to the beginning of the editor,\r\n   * so we update to force it back to the correct place.\r\n   */\n  resolveComposition: function resolveComposition(editor) {\n    if (stillComposing) {\n      return;\n    }\n\n    var mutations = nullthrows(domObserver).stopAndFlushMutations();\n    domObserver = null;\n    resolved = true;\n    var editorState = EditorState.set(editor._latestEditorState, {\n      inCompositionMode: false\n    });\n    editor.exitCurrentMode();\n\n    if (!mutations.size) {\n      editor.update(editorState);\n      return;\n    } // TODO, check if Facebook still needs this flag or if it could be removed.\n    // Since there can be multiple mutations providing a `composedChars` doesn't\n    // apply well on this new model.\n    // if (\n    //   gkx('draft_handlebeforeinput_composed_text') &&\n    //   editor.props.handleBeforeInput &&\n    //   isEventHandled(\n    //     editor.props.handleBeforeInput(\n    //       composedChars,\n    //       editorState,\n    //       event.timeStamp,\n    //     ),\n    //   )\n    // ) {\n    //   return;\n    // }\n\n\n    var contentState = editorState.getCurrentContent();\n    mutations.forEach(function (composedChars, offsetKey) {\n      var _DraftOffsetKey$decod = DraftOffsetKey.decode(offsetKey),\n          blockKey = _DraftOffsetKey$decod.blockKey,\n          decoratorKey = _DraftOffsetKey$decod.decoratorKey,\n          leafKey = _DraftOffsetKey$decod.leafKey;\n\n      var _editorState$getBlock = editorState.getBlockTree(blockKey).getIn([decoratorKey, 'leaves', leafKey]),\n          start = _editorState$getBlock.start,\n          end = _editorState$getBlock.end;\n\n      var replacementRange = editorState.getSelection().merge({\n        anchorKey: blockKey,\n        focusKey: blockKey,\n        anchorOffset: start,\n        focusOffset: end,\n        isBackward: false\n      });\n      var entityKey = getEntityKeyForSelection(contentState, replacementRange);\n      var currentStyle = contentState.getBlockForKey(blockKey).getInlineStyleAt(start);\n      contentState = DraftModifier.replaceText(contentState, replacementRange, composedChars, currentStyle, entityKey); // We need to update the editorState so the leaf node ranges are properly\n      // updated and multiple mutations are correctly applied.\n\n      editorState = EditorState.set(editorState, {\n        currentContent: contentState\n      });\n    }); // When we apply the text changes to the ContentState, the selection always\n    // goes to the end of the field, but it should just stay where it is\n    // after compositionEnd.\n\n    var documentSelection = getDraftEditorSelection(editorState, getContentEditableContainer(editor));\n    var compositionEndSelectionState = documentSelection.selectionState;\n    editor.restoreEditorDOM(); // See:\n    // - https://github.com/facebook/draft-js/issues/2093\n    // - https://github.com/facebook/draft-js/pull/2094\n    // Apply this fix only in IE for now. We can test it in\n    // other browsers in the future to ensure no regressions\n\n    var editorStateWithUpdatedSelection = isIE ? EditorState.forceSelection(editorState, compositionEndSelectionState) : EditorState.acceptSelection(editorState, compositionEndSelectionState);\n    editor.update(EditorState.push(editorStateWithUpdatedSelection, contentState, 'insert-characters'));\n  }\n};\nmodule.exports = DraftEditorCompositionHandler;","map":{"version":3,"sources":["D:/mohi/mohi/client/node_modules/draft-js/lib/DraftEditorCompositionHandler.js"],"names":["DOMObserver","require","DraftModifier","DraftOffsetKey","EditorState","Keys","UserAgent","editOnSelect","getContentEditableContainer","getDraftEditorSelection","getEntityKeyForSelection","nullthrows","isIE","isBrowser","RESOLVE_DELAY","resolved","stillComposing","domObserver","startDOMObserver","editor","start","DraftEditorCompositionHandler","onCompositionStart","onCompositionEnd","setTimeout","resolveComposition","onSelect","onKeyDown","e","_onKeyDown","which","RIGHT","LEFT","preventDefault","onKeyPress","_editor","RETURN","mutations","stopAndFlushMutations","editorState","set","_latestEditorState","inCompositionMode","exitCurrentMode","size","update","contentState","getCurrentContent","forEach","composedChars","offsetKey","_DraftOffsetKey$decod","decode","blockKey","decoratorKey","leafKey","_editorState$getBlock","getBlockTree","getIn","end","replacementRange","getSelection","merge","anchorKey","focusKey","anchorOffset","focusOffset","isBackward","entityKey","currentStyle","getBlockForKey","getInlineStyleAt","replaceText","currentContent","documentSelection","compositionEndSelectionState","selectionState","restoreEditorDOM","editorStateWithUpdatedSelection","forceSelection","acceptSelection","push","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @format\r\n * \r\n * @emails oncall+draft_js\r\n */\r\n'use strict';\r\n\r\nvar DOMObserver = require(\"./DOMObserver\");\r\n\r\nvar DraftModifier = require(\"./DraftModifier\");\r\n\r\nvar DraftOffsetKey = require(\"./DraftOffsetKey\");\r\n\r\nvar EditorState = require(\"./EditorState\");\r\n\r\nvar Keys = require(\"fbjs/lib/Keys\");\r\n\r\nvar UserAgent = require(\"fbjs/lib/UserAgent\");\r\n\r\nvar editOnSelect = require(\"./editOnSelect\");\r\n\r\nvar getContentEditableContainer = require(\"./getContentEditableContainer\");\r\n\r\nvar getDraftEditorSelection = require(\"./getDraftEditorSelection\");\r\n\r\nvar getEntityKeyForSelection = require(\"./getEntityKeyForSelection\");\r\n\r\nvar nullthrows = require(\"fbjs/lib/nullthrows\");\r\n\r\nvar isIE = UserAgent.isBrowser('IE');\r\n/**\r\n * Millisecond delay to allow `compositionstart` to fire again upon\r\n * `compositionend`.\r\n *\r\n * This is used for Korean input to ensure that typing can continue without\r\n * the editor trying to render too quickly. More specifically, Safari 7.1+\r\n * triggers `compositionstart` a little slower than Chrome/FF, which\r\n * leads to composed characters being resolved and re-render occurring\r\n * sooner than we want.\r\n */\r\n\r\nvar RESOLVE_DELAY = 20;\r\n/**\r\n * A handful of variables used to track the current composition and its\r\n * resolution status. These exist at the module level because it is not\r\n * possible to have compositions occurring in multiple editors simultaneously,\r\n * and it simplifies state management with respect to the DraftEditor component.\r\n */\r\n\r\nvar resolved = false;\r\nvar stillComposing = false;\r\nvar domObserver = null;\r\n\r\nfunction startDOMObserver(editor) {\r\n  if (!domObserver) {\r\n    domObserver = new DOMObserver(getContentEditableContainer(editor));\r\n    domObserver.start();\r\n  }\r\n}\r\n\r\nvar DraftEditorCompositionHandler = {\r\n  /**\r\n   * A `compositionstart` event has fired while we're still in composition\r\n   * mode. Continue the current composition session to prevent a re-render.\r\n   */\r\n  onCompositionStart: function onCompositionStart(editor) {\r\n    stillComposing = true;\r\n    startDOMObserver(editor);\r\n  },\r\n\r\n  /**\r\n   * Attempt to end the current composition session.\r\n   *\r\n   * Defer handling because browser will still insert the chars into active\r\n   * element after `compositionend`. If a `compositionstart` event fires\r\n   * before `resolveComposition` executes, our composition session will\r\n   * continue.\r\n   *\r\n   * The `resolved` flag is useful because certain IME interfaces fire the\r\n   * `compositionend` event multiple times, thus queueing up multiple attempts\r\n   * at handling the composition. Since handling the same composition event\r\n   * twice could break the DOM, we only use the first event. Example: Arabic\r\n   * Google Input Tools on Windows 8.1 fires `compositionend` three times.\r\n   */\r\n  onCompositionEnd: function onCompositionEnd(editor) {\r\n    resolved = false;\r\n    stillComposing = false;\r\n    setTimeout(function () {\r\n      if (!resolved) {\r\n        DraftEditorCompositionHandler.resolveComposition(editor);\r\n      }\r\n    }, RESOLVE_DELAY);\r\n  },\r\n  onSelect: editOnSelect,\r\n\r\n  /**\r\n   * In Safari, keydown events may fire when committing compositions. If\r\n   * the arrow keys are used to commit, prevent default so that the cursor\r\n   * doesn't move, otherwise it will jump back noticeably on re-render.\r\n   */\r\n  onKeyDown: function onKeyDown(editor, e) {\r\n    if (!stillComposing) {\r\n      // If a keydown event is received after compositionend but before the\r\n      // 20ms timer expires (ex: type option-E then backspace, or type A then\r\n      // backspace in 2-Set Korean), we should immediately resolve the\r\n      // composition and reinterpret the key press in edit mode.\r\n      DraftEditorCompositionHandler.resolveComposition(editor);\r\n\r\n      editor._onKeyDown(e);\r\n\r\n      return;\r\n    }\r\n\r\n    if (e.which === Keys.RIGHT || e.which === Keys.LEFT) {\r\n      e.preventDefault();\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Keypress events may fire when committing compositions. In Firefox,\r\n   * pressing RETURN commits the composition and inserts extra newline\r\n   * characters that we do not want. `preventDefault` allows the composition\r\n   * to be committed while preventing the extra characters.\r\n   */\r\n  onKeyPress: function onKeyPress(_editor, e) {\r\n    if (e.which === Keys.RETURN) {\r\n      e.preventDefault();\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Attempt to insert composed characters into the document.\r\n   *\r\n   * If we are still in a composition session, do nothing. Otherwise, insert\r\n   * the characters into the document and terminate the composition session.\r\n   *\r\n   * If no characters were composed -- for instance, the user\r\n   * deleted all composed characters and committed nothing new --\r\n   * force a re-render. We also re-render when the composition occurs\r\n   * at the beginning of a leaf, to ensure that if the browser has\r\n   * created a new text node for the composition, we will discard it.\r\n   *\r\n   * Resetting innerHTML will move focus to the beginning of the editor,\r\n   * so we update to force it back to the correct place.\r\n   */\r\n  resolveComposition: function resolveComposition(editor) {\r\n    if (stillComposing) {\r\n      return;\r\n    }\r\n\r\n    var mutations = nullthrows(domObserver).stopAndFlushMutations();\r\n    domObserver = null;\r\n    resolved = true;\r\n    var editorState = EditorState.set(editor._latestEditorState, {\r\n      inCompositionMode: false\r\n    });\r\n    editor.exitCurrentMode();\r\n\r\n    if (!mutations.size) {\r\n      editor.update(editorState);\r\n      return;\r\n    } // TODO, check if Facebook still needs this flag or if it could be removed.\r\n    // Since there can be multiple mutations providing a `composedChars` doesn't\r\n    // apply well on this new model.\r\n    // if (\r\n    //   gkx('draft_handlebeforeinput_composed_text') &&\r\n    //   editor.props.handleBeforeInput &&\r\n    //   isEventHandled(\r\n    //     editor.props.handleBeforeInput(\r\n    //       composedChars,\r\n    //       editorState,\r\n    //       event.timeStamp,\r\n    //     ),\r\n    //   )\r\n    // ) {\r\n    //   return;\r\n    // }\r\n\r\n\r\n    var contentState = editorState.getCurrentContent();\r\n    mutations.forEach(function (composedChars, offsetKey) {\r\n      var _DraftOffsetKey$decod = DraftOffsetKey.decode(offsetKey),\r\n          blockKey = _DraftOffsetKey$decod.blockKey,\r\n          decoratorKey = _DraftOffsetKey$decod.decoratorKey,\r\n          leafKey = _DraftOffsetKey$decod.leafKey;\r\n\r\n      var _editorState$getBlock = editorState.getBlockTree(blockKey).getIn([decoratorKey, 'leaves', leafKey]),\r\n          start = _editorState$getBlock.start,\r\n          end = _editorState$getBlock.end;\r\n\r\n      var replacementRange = editorState.getSelection().merge({\r\n        anchorKey: blockKey,\r\n        focusKey: blockKey,\r\n        anchorOffset: start,\r\n        focusOffset: end,\r\n        isBackward: false\r\n      });\r\n      var entityKey = getEntityKeyForSelection(contentState, replacementRange);\r\n      var currentStyle = contentState.getBlockForKey(blockKey).getInlineStyleAt(start);\r\n      contentState = DraftModifier.replaceText(contentState, replacementRange, composedChars, currentStyle, entityKey); // We need to update the editorState so the leaf node ranges are properly\r\n      // updated and multiple mutations are correctly applied.\r\n\r\n      editorState = EditorState.set(editorState, {\r\n        currentContent: contentState\r\n      });\r\n    }); // When we apply the text changes to the ContentState, the selection always\r\n    // goes to the end of the field, but it should just stay where it is\r\n    // after compositionEnd.\r\n\r\n    var documentSelection = getDraftEditorSelection(editorState, getContentEditableContainer(editor));\r\n    var compositionEndSelectionState = documentSelection.selectionState;\r\n    editor.restoreEditorDOM(); // See:\r\n    // - https://github.com/facebook/draft-js/issues/2093\r\n    // - https://github.com/facebook/draft-js/pull/2094\r\n    // Apply this fix only in IE for now. We can test it in\r\n    // other browsers in the future to ensure no regressions\r\n\r\n    var editorStateWithUpdatedSelection = isIE ? EditorState.forceSelection(editorState, compositionEndSelectionState) : EditorState.acceptSelection(editorState, compositionEndSelectionState);\r\n    editor.update(EditorState.push(editorStateWithUpdatedSelection, contentState, 'insert-characters'));\r\n  }\r\n};\r\nmodule.exports = DraftEditorCompositionHandler;"]},"metadata":{},"sourceType":"script"}