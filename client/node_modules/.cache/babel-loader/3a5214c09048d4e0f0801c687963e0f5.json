{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @format\r\n * \r\n * @emails oncall+draft_js\r\n */\n'use strict';\n\nvar BlockMapBuilder = require(\"./BlockMapBuilder\");\n\nvar CharacterMetadata = require(\"./CharacterMetadata\");\n\nvar DataTransfer = require(\"fbjs/lib/DataTransfer\");\n\nvar DraftModifier = require(\"./DraftModifier\");\n\nvar DraftPasteProcessor = require(\"./DraftPasteProcessor\");\n\nvar EditorState = require(\"./EditorState\");\n\nvar RichTextEditorUtil = require(\"./RichTextEditorUtil\");\n\nvar getEntityKeyForSelection = require(\"./getEntityKeyForSelection\");\n\nvar getTextContentFromFiles = require(\"./getTextContentFromFiles\");\n\nvar isEventHandled = require(\"./isEventHandled\");\n\nvar splitTextIntoTextBlocks = require(\"./splitTextIntoTextBlocks\");\n/**\r\n * Paste content.\r\n */\n\n\nfunction editOnPaste(editor, e) {\n  e.preventDefault();\n  var data = new DataTransfer(e.clipboardData); // Get files, unless this is likely to be a string the user wants inline.\n\n  if (!data.isRichText()) {\n    var files = data.getFiles();\n    var defaultFileText = data.getText();\n\n    if (files.length > 0) {\n      // Allow customized paste handling for images, etc. Otherwise, fall\n      // through to insert text contents into the editor.\n      if (editor.props.handlePastedFiles && isEventHandled(editor.props.handlePastedFiles(files))) {\n        return;\n      }\n      /* $FlowFixMe[incompatible-call] This comment suppresses an error found\r\n       * DataTransfer was typed. getFiles() returns an array of <Files extends\r\n       * Blob>, not Blob */\n\n\n      getTextContentFromFiles(files, function (\n      /*string*/\n      fileText) {\n        fileText = fileText || defaultFileText;\n\n        if (!fileText) {\n          return;\n        }\n\n        var editorState = editor._latestEditorState;\n        var blocks = splitTextIntoTextBlocks(fileText);\n        var character = CharacterMetadata.create({\n          style: editorState.getCurrentInlineStyle(),\n          entity: getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection())\n        });\n        var currentBlockType = RichTextEditorUtil.getCurrentBlockType(editorState);\n        var text = DraftPasteProcessor.processText(blocks, character, currentBlockType);\n        var fragment = BlockMapBuilder.createFromArray(text);\n        var withInsertedText = DraftModifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment);\n        editor.update(EditorState.push(editorState, withInsertedText, 'insert-fragment'));\n      });\n      return;\n    }\n  }\n\n  var textBlocks = [];\n  var text = data.getText();\n  var html = data.getHTML();\n  var editorState = editor._latestEditorState;\n\n  if (editor.props.formatPastedText) {\n    var _editor$props$formatP = editor.props.formatPastedText(text, html),\n        formattedText = _editor$props$formatP.text,\n        formattedHtml = _editor$props$formatP.html;\n\n    text = formattedText;\n    html = formattedHtml;\n  }\n\n  if (editor.props.handlePastedText && isEventHandled(editor.props.handlePastedText(text, html, editorState))) {\n    return;\n  }\n\n  if (text) {\n    textBlocks = splitTextIntoTextBlocks(text);\n  }\n\n  if (!editor.props.stripPastedStyles) {\n    // If the text from the paste event is rich content that matches what we\n    // already have on the internal clipboard, assume that we should just use\n    // the clipboard fragment for the paste. This will allow us to preserve\n    // styling and entities, if any are present. Note that newlines are\n    // stripped during comparison -- this is because copy/paste within the\n    // editor in Firefox and IE will not include empty lines. The resulting\n    // paste will preserve the newlines correctly.\n    var internalClipboard = editor.getClipboard();\n\n    if (!editor.props.formatPastedText && data.isRichText() && internalClipboard) {\n      var _html;\n\n      if ( // If the editorKey is present in the pasted HTML, it should be safe to\n      // assume this is an internal paste.\n      ((_html = html) === null || _html === void 0 ? void 0 : _html.indexOf(editor.getEditorKey())) !== -1 || // The copy may have been made within a single block, in which case the\n      // editor key won't be part of the paste. In this case, just check\n      // whether the pasted text matches the internal clipboard.\n      textBlocks.length === 1 && internalClipboard.size === 1 && internalClipboard.first().getText() === text) {\n        editor.update(insertFragment(editor._latestEditorState, internalClipboard));\n        return;\n      }\n    } else if (internalClipboard && data.types.includes('com.apple.webarchive') && !data.types.includes('text/html') && areTextBlocksAndClipboardEqual(textBlocks, internalClipboard)) {\n      // Safari does not properly store text/html in some cases.\n      // Use the internalClipboard if present and equal to what is on\n      // the clipboard. See https://bugs.webkit.org/show_bug.cgi?id=19893.\n      editor.update(insertFragment(editor._latestEditorState, internalClipboard));\n      return;\n    } // If there is html paste data, try to parse that.\n\n\n    if (html) {\n      var htmlFragment = DraftPasteProcessor.processHTML(html, editor.props.blockRenderMap);\n\n      if (htmlFragment) {\n        var contentBlocks = htmlFragment.contentBlocks,\n            entityMap = htmlFragment.entityMap;\n\n        if (contentBlocks) {\n          var htmlMap = BlockMapBuilder.createFromArray(contentBlocks);\n          editor.update(insertFragment(editor._latestEditorState, htmlMap, entityMap));\n          return;\n        }\n      }\n    } // Otherwise, create a new fragment from our pasted text. Also\n    // empty the internal clipboard, since it's no longer valid.\n\n\n    editor.setClipboard(null);\n  }\n\n  if (textBlocks.length) {\n    var character = CharacterMetadata.create({\n      style: editorState.getCurrentInlineStyle(),\n      entity: getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection())\n    });\n    var currentBlockType = RichTextEditorUtil.getCurrentBlockType(editorState);\n    var textFragment = DraftPasteProcessor.processText(textBlocks, character, currentBlockType);\n    var textMap = BlockMapBuilder.createFromArray(textFragment);\n    editor.update(insertFragment(editor._latestEditorState, textMap));\n  }\n}\n\nfunction insertFragment(editorState, fragment, entityMap) {\n  var newContent = DraftModifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment); // TODO: merge the entity map once we stop using DraftEntity\n  // like this:\n  // const mergedEntityMap = newContent.getEntityMap().merge(entityMap);\n\n  return EditorState.push(editorState, newContent.set('entityMap', entityMap), 'insert-fragment');\n}\n\nfunction areTextBlocksAndClipboardEqual(textBlocks, blockMap) {\n  return textBlocks.length === blockMap.size && blockMap.valueSeq().every(function (block, ii) {\n    return block.getText() === textBlocks[ii];\n  });\n}\n\nmodule.exports = editOnPaste;","map":{"version":3,"sources":["D:/Web/mohi/client/node_modules/draft-js/lib/editOnPaste.js"],"names":["BlockMapBuilder","require","CharacterMetadata","DataTransfer","DraftModifier","DraftPasteProcessor","EditorState","RichTextEditorUtil","getEntityKeyForSelection","getTextContentFromFiles","isEventHandled","splitTextIntoTextBlocks","editOnPaste","editor","e","preventDefault","data","clipboardData","isRichText","files","getFiles","defaultFileText","getText","length","props","handlePastedFiles","fileText","editorState","_latestEditorState","blocks","character","create","style","getCurrentInlineStyle","entity","getCurrentContent","getSelection","currentBlockType","getCurrentBlockType","text","processText","fragment","createFromArray","withInsertedText","replaceWithFragment","update","push","textBlocks","html","getHTML","formatPastedText","_editor$props$formatP","formattedText","formattedHtml","handlePastedText","stripPastedStyles","internalClipboard","getClipboard","_html","indexOf","getEditorKey","size","first","insertFragment","types","includes","areTextBlocksAndClipboardEqual","htmlFragment","processHTML","blockRenderMap","contentBlocks","entityMap","htmlMap","setClipboard","textFragment","textMap","newContent","set","blockMap","valueSeq","every","block","ii","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @format\r\n * \r\n * @emails oncall+draft_js\r\n */\r\n'use strict';\r\n\r\nvar BlockMapBuilder = require(\"./BlockMapBuilder\");\r\n\r\nvar CharacterMetadata = require(\"./CharacterMetadata\");\r\n\r\nvar DataTransfer = require(\"fbjs/lib/DataTransfer\");\r\n\r\nvar DraftModifier = require(\"./DraftModifier\");\r\n\r\nvar DraftPasteProcessor = require(\"./DraftPasteProcessor\");\r\n\r\nvar EditorState = require(\"./EditorState\");\r\n\r\nvar RichTextEditorUtil = require(\"./RichTextEditorUtil\");\r\n\r\nvar getEntityKeyForSelection = require(\"./getEntityKeyForSelection\");\r\n\r\nvar getTextContentFromFiles = require(\"./getTextContentFromFiles\");\r\n\r\nvar isEventHandled = require(\"./isEventHandled\");\r\n\r\nvar splitTextIntoTextBlocks = require(\"./splitTextIntoTextBlocks\");\r\n/**\r\n * Paste content.\r\n */\r\n\r\n\r\nfunction editOnPaste(editor, e) {\r\n  e.preventDefault();\r\n  var data = new DataTransfer(e.clipboardData); // Get files, unless this is likely to be a string the user wants inline.\r\n\r\n  if (!data.isRichText()) {\r\n    var files = data.getFiles();\r\n    var defaultFileText = data.getText();\r\n\r\n    if (files.length > 0) {\r\n      // Allow customized paste handling for images, etc. Otherwise, fall\r\n      // through to insert text contents into the editor.\r\n      if (editor.props.handlePastedFiles && isEventHandled(editor.props.handlePastedFiles(files))) {\r\n        return;\r\n      }\r\n      /* $FlowFixMe[incompatible-call] This comment suppresses an error found\r\n       * DataTransfer was typed. getFiles() returns an array of <Files extends\r\n       * Blob>, not Blob */\r\n\r\n\r\n      getTextContentFromFiles(files, function (\r\n      /*string*/\r\n      fileText) {\r\n        fileText = fileText || defaultFileText;\r\n\r\n        if (!fileText) {\r\n          return;\r\n        }\r\n\r\n        var editorState = editor._latestEditorState;\r\n        var blocks = splitTextIntoTextBlocks(fileText);\r\n        var character = CharacterMetadata.create({\r\n          style: editorState.getCurrentInlineStyle(),\r\n          entity: getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection())\r\n        });\r\n        var currentBlockType = RichTextEditorUtil.getCurrentBlockType(editorState);\r\n        var text = DraftPasteProcessor.processText(blocks, character, currentBlockType);\r\n        var fragment = BlockMapBuilder.createFromArray(text);\r\n        var withInsertedText = DraftModifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment);\r\n        editor.update(EditorState.push(editorState, withInsertedText, 'insert-fragment'));\r\n      });\r\n      return;\r\n    }\r\n  }\r\n\r\n  var textBlocks = [];\r\n  var text = data.getText();\r\n  var html = data.getHTML();\r\n  var editorState = editor._latestEditorState;\r\n\r\n  if (editor.props.formatPastedText) {\r\n    var _editor$props$formatP = editor.props.formatPastedText(text, html),\r\n        formattedText = _editor$props$formatP.text,\r\n        formattedHtml = _editor$props$formatP.html;\r\n\r\n    text = formattedText;\r\n    html = formattedHtml;\r\n  }\r\n\r\n  if (editor.props.handlePastedText && isEventHandled(editor.props.handlePastedText(text, html, editorState))) {\r\n    return;\r\n  }\r\n\r\n  if (text) {\r\n    textBlocks = splitTextIntoTextBlocks(text);\r\n  }\r\n\r\n  if (!editor.props.stripPastedStyles) {\r\n    // If the text from the paste event is rich content that matches what we\r\n    // already have on the internal clipboard, assume that we should just use\r\n    // the clipboard fragment for the paste. This will allow us to preserve\r\n    // styling and entities, if any are present. Note that newlines are\r\n    // stripped during comparison -- this is because copy/paste within the\r\n    // editor in Firefox and IE will not include empty lines. The resulting\r\n    // paste will preserve the newlines correctly.\r\n    var internalClipboard = editor.getClipboard();\r\n\r\n    if (!editor.props.formatPastedText && data.isRichText() && internalClipboard) {\r\n      var _html;\r\n\r\n      if ( // If the editorKey is present in the pasted HTML, it should be safe to\r\n      // assume this is an internal paste.\r\n      ((_html = html) === null || _html === void 0 ? void 0 : _html.indexOf(editor.getEditorKey())) !== -1 || // The copy may have been made within a single block, in which case the\r\n      // editor key won't be part of the paste. In this case, just check\r\n      // whether the pasted text matches the internal clipboard.\r\n      textBlocks.length === 1 && internalClipboard.size === 1 && internalClipboard.first().getText() === text) {\r\n        editor.update(insertFragment(editor._latestEditorState, internalClipboard));\r\n        return;\r\n      }\r\n    } else if (internalClipboard && data.types.includes('com.apple.webarchive') && !data.types.includes('text/html') && areTextBlocksAndClipboardEqual(textBlocks, internalClipboard)) {\r\n      // Safari does not properly store text/html in some cases.\r\n      // Use the internalClipboard if present and equal to what is on\r\n      // the clipboard. See https://bugs.webkit.org/show_bug.cgi?id=19893.\r\n      editor.update(insertFragment(editor._latestEditorState, internalClipboard));\r\n      return;\r\n    } // If there is html paste data, try to parse that.\r\n\r\n\r\n    if (html) {\r\n      var htmlFragment = DraftPasteProcessor.processHTML(html, editor.props.blockRenderMap);\r\n\r\n      if (htmlFragment) {\r\n        var contentBlocks = htmlFragment.contentBlocks,\r\n            entityMap = htmlFragment.entityMap;\r\n\r\n        if (contentBlocks) {\r\n          var htmlMap = BlockMapBuilder.createFromArray(contentBlocks);\r\n          editor.update(insertFragment(editor._latestEditorState, htmlMap, entityMap));\r\n          return;\r\n        }\r\n      }\r\n    } // Otherwise, create a new fragment from our pasted text. Also\r\n    // empty the internal clipboard, since it's no longer valid.\r\n\r\n\r\n    editor.setClipboard(null);\r\n  }\r\n\r\n  if (textBlocks.length) {\r\n    var character = CharacterMetadata.create({\r\n      style: editorState.getCurrentInlineStyle(),\r\n      entity: getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection())\r\n    });\r\n    var currentBlockType = RichTextEditorUtil.getCurrentBlockType(editorState);\r\n    var textFragment = DraftPasteProcessor.processText(textBlocks, character, currentBlockType);\r\n    var textMap = BlockMapBuilder.createFromArray(textFragment);\r\n    editor.update(insertFragment(editor._latestEditorState, textMap));\r\n  }\r\n}\r\n\r\nfunction insertFragment(editorState, fragment, entityMap) {\r\n  var newContent = DraftModifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment); // TODO: merge the entity map once we stop using DraftEntity\r\n  // like this:\r\n  // const mergedEntityMap = newContent.getEntityMap().merge(entityMap);\r\n\r\n  return EditorState.push(editorState, newContent.set('entityMap', entityMap), 'insert-fragment');\r\n}\r\n\r\nfunction areTextBlocksAndClipboardEqual(textBlocks, blockMap) {\r\n  return textBlocks.length === blockMap.size && blockMap.valueSeq().every(function (block, ii) {\r\n    return block.getText() === textBlocks[ii];\r\n  });\r\n}\r\n\r\nmodule.exports = editOnPaste;"]},"metadata":{},"sourceType":"script"}