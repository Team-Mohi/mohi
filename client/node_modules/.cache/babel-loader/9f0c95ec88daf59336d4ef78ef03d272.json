{"ast":null,"code":"/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * A lightweight readable stream implemention that handles event dispatching.\n * Objects that inherit from streams should call init in their constructors.\n */\n'use strict';\n\nvar Stream = function () {\n  this.init = function () {\n    var listeners = {};\n    /**\n     * Add a listener for a specified event type.\n     * @param type {string} the event name\n     * @param listener {function} the callback to be invoked when an event of\n     * the specified type occurs\n     */\n\n    this.on = function (type, listener) {\n      if (!listeners[type]) {\n        listeners[type] = [];\n      }\n\n      listeners[type] = listeners[type].concat(listener);\n    };\n    /**\n     * Remove a listener for a specified event type.\n     * @param type {string} the event name\n     * @param listener {function} a function previously registered for this\n     * type of event through `on`\n     */\n\n\n    this.off = function (type, listener) {\n      var index;\n\n      if (!listeners[type]) {\n        return false;\n      }\n\n      index = listeners[type].indexOf(listener);\n      listeners[type] = listeners[type].slice();\n      listeners[type].splice(index, 1);\n      return index > -1;\n    };\n    /**\n     * Trigger an event of the specified type on this stream. Any additional\n     * arguments to this function are passed as parameters to event listeners.\n     * @param type {string} the event name\n     */\n\n\n    this.trigger = function (type) {\n      var callbacks, i, length, args;\n      callbacks = listeners[type];\n\n      if (!callbacks) {\n        return;\n      } // Slicing the arguments on every invocation of this method\n      // can add a significant amount of overhead. Avoid the\n      // intermediate object creation for the common case of a\n      // single callback argument\n\n\n      if (arguments.length === 2) {\n        length = callbacks.length;\n\n        for (i = 0; i < length; ++i) {\n          callbacks[i].call(this, arguments[1]);\n        }\n      } else {\n        args = [];\n        i = arguments.length;\n\n        for (i = 1; i < arguments.length; ++i) {\n          args.push(arguments[i]);\n        }\n\n        length = callbacks.length;\n\n        for (i = 0; i < length; ++i) {\n          callbacks[i].apply(this, args);\n        }\n      }\n    };\n    /**\n     * Destroys the stream and cleans up.\n     */\n\n\n    this.dispose = function () {\n      listeners = {};\n    };\n  };\n};\n/**\n * Forwards all `data` events on this stream to the destination stream. The\n * destination stream should provide a method `push` to receive the data\n * events as they arrive.\n * @param destination {stream} the stream that will receive all `data` events\n * @param autoFlush {boolean} if false, we will not call `flush` on the destination\n *                            when the current stream emits a 'done' event\n * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n */\n\n\nStream.prototype.pipe = function (destination) {\n  this.on('data', function (data) {\n    destination.push(data);\n  });\n  this.on('done', function (flushSource) {\n    destination.flush(flushSource);\n  });\n  this.on('partialdone', function (flushSource) {\n    destination.partialFlush(flushSource);\n  });\n  this.on('endedtimeline', function (flushSource) {\n    destination.endTimeline(flushSource);\n  });\n  this.on('reset', function (flushSource) {\n    destination.reset(flushSource);\n  });\n  return destination;\n}; // Default stream functions that are expected to be overridden to perform\n// actual work. These are provided by the prototype as a sort of no-op\n// implementation so that we don't have to check for their existence in the\n// `pipe` function above.\n\n\nStream.prototype.push = function (data) {\n  this.trigger('data', data);\n};\n\nStream.prototype.flush = function (flushSource) {\n  this.trigger('done', flushSource);\n};\n\nStream.prototype.partialFlush = function (flushSource) {\n  this.trigger('partialdone', flushSource);\n};\n\nStream.prototype.endTimeline = function (flushSource) {\n  this.trigger('endedtimeline', flushSource);\n};\n\nStream.prototype.reset = function (flushSource) {\n  this.trigger('reset', flushSource);\n};\n\nmodule.exports = Stream;","map":{"version":3,"sources":["D:/Web/mohi/client/node_modules/mux.js/lib/utils/stream.js"],"names":["Stream","init","listeners","on","type","listener","concat","off","index","indexOf","slice","splice","trigger","callbacks","i","length","args","arguments","call","push","apply","dispose","prototype","pipe","destination","data","flushSource","flush","partialFlush","endTimeline","reset","module","exports"],"mappings":"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","sourcesContent":["/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * A lightweight readable stream implemention that handles event dispatching.\n * Objects that inherit from streams should call init in their constructors.\n */\n'use strict';\n\nvar Stream = function() {\n  this.init = function() {\n    var listeners = {};\n    /**\n     * Add a listener for a specified event type.\n     * @param type {string} the event name\n     * @param listener {function} the callback to be invoked when an event of\n     * the specified type occurs\n     */\n    this.on = function(type, listener) {\n      if (!listeners[type]) {\n        listeners[type] = [];\n      }\n      listeners[type] = listeners[type].concat(listener);\n    };\n    /**\n     * Remove a listener for a specified event type.\n     * @param type {string} the event name\n     * @param listener {function} a function previously registered for this\n     * type of event through `on`\n     */\n    this.off = function(type, listener) {\n      var index;\n      if (!listeners[type]) {\n        return false;\n      }\n      index = listeners[type].indexOf(listener);\n      listeners[type] = listeners[type].slice();\n      listeners[type].splice(index, 1);\n      return index > -1;\n    };\n    /**\n     * Trigger an event of the specified type on this stream. Any additional\n     * arguments to this function are passed as parameters to event listeners.\n     * @param type {string} the event name\n     */\n    this.trigger = function(type) {\n      var callbacks, i, length, args;\n      callbacks = listeners[type];\n      if (!callbacks) {\n        return;\n      }\n      // Slicing the arguments on every invocation of this method\n      // can add a significant amount of overhead. Avoid the\n      // intermediate object creation for the common case of a\n      // single callback argument\n      if (arguments.length === 2) {\n        length = callbacks.length;\n        for (i = 0; i < length; ++i) {\n          callbacks[i].call(this, arguments[1]);\n        }\n      } else {\n        args = [];\n        i = arguments.length;\n        for (i = 1; i < arguments.length; ++i) {\n          args.push(arguments[i]);\n        }\n        length = callbacks.length;\n        for (i = 0; i < length; ++i) {\n          callbacks[i].apply(this, args);\n        }\n      }\n    };\n    /**\n     * Destroys the stream and cleans up.\n     */\n    this.dispose = function() {\n      listeners = {};\n    };\n  };\n};\n\n/**\n * Forwards all `data` events on this stream to the destination stream. The\n * destination stream should provide a method `push` to receive the data\n * events as they arrive.\n * @param destination {stream} the stream that will receive all `data` events\n * @param autoFlush {boolean} if false, we will not call `flush` on the destination\n *                            when the current stream emits a 'done' event\n * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n */\nStream.prototype.pipe = function(destination) {\n  this.on('data', function(data) {\n    destination.push(data);\n  });\n\n  this.on('done', function(flushSource) {\n    destination.flush(flushSource);\n  });\n\n  this.on('partialdone', function(flushSource) {\n    destination.partialFlush(flushSource);\n  });\n\n  this.on('endedtimeline', function(flushSource) {\n    destination.endTimeline(flushSource);\n  });\n\n  this.on('reset', function(flushSource) {\n    destination.reset(flushSource);\n  });\n\n  return destination;\n};\n\n// Default stream functions that are expected to be overridden to perform\n// actual work. These are provided by the prototype as a sort of no-op\n// implementation so that we don't have to check for their existence in the\n// `pipe` function above.\nStream.prototype.push = function(data) {\n  this.trigger('data', data);\n};\n\nStream.prototype.flush = function(flushSource) {\n  this.trigger('done', flushSource);\n};\n\nStream.prototype.partialFlush = function(flushSource) {\n  this.trigger('partialdone', flushSource);\n};\n\nStream.prototype.endTimeline = function(flushSource) {\n  this.trigger('endedtimeline', flushSource);\n};\n\nStream.prototype.reset = function(flushSource) {\n  this.trigger('reset', flushSource);\n};\n\nmodule.exports = Stream;\n"]},"metadata":{},"sourceType":"script"}