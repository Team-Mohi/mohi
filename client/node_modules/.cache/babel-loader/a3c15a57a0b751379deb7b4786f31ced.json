{"ast":null,"code":"/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @format\r\n * \r\n * @emails oncall+draft_js\r\n */\n'use strict';\n\nvar DraftModifier = require(\"./DraftModifier\");\n\nvar DraftOffsetKey = require(\"./DraftOffsetKey\");\n\nvar EditorState = require(\"./EditorState\");\n\nvar UserAgent = require(\"fbjs/lib/UserAgent\");\n\nvar _require = require(\"./draftKeyUtils\"),\n    notEmptyKey = _require.notEmptyKey;\n\nvar findAncestorOffsetKey = require(\"./findAncestorOffsetKey\");\n\nvar keyCommandPlainBackspace = require(\"./keyCommandPlainBackspace\");\n\nvar nullthrows = require(\"fbjs/lib/nullthrows\");\n\nvar isGecko = UserAgent.isEngine('Gecko');\nvar DOUBLE_NEWLINE = '\\n\\n';\n\nfunction onInputType(inputType, editorState) {\n  switch (inputType) {\n    case 'deleteContentBackward':\n      return keyCommandPlainBackspace(editorState);\n  }\n\n  return editorState;\n}\n/**\r\n * This function serves two purposes\r\n *\r\n * 1. To update the editorState and call onChange method with the new\r\n * editorState. This editorState is calculated in editOnBeforeInput but the\r\n * onChange method is not called with the new state until this method does it.\r\n * It is done to handle a specific case where certain character inputs might\r\n * be replaced with something else. E.g. snippets ('rc' might be replaced\r\n * with boilerplate code for react component). More information on the\r\n * exact problem can be found here -\r\n * https://github.com/facebook/draft-js/commit/07892ba479bd4dfc6afd1e0ed179aaf51cd138b1\r\n *\r\n * 2. intended to handle spellcheck and autocorrect changes,\r\n * which occur in the DOM natively without any opportunity to observe or\r\n * interpret the changes before they occur.\r\n *\r\n * The `input` event fires in contentEditable elements reliably for non-IE\r\n * browsers, immediately after changes occur to the editor DOM. Since our other\r\n * handlers override or otherwise handle cover other varieties of text input,\r\n * the DOM state should match the model in all controlled input cases. Thus,\r\n * when an `input` change leads to a DOM/model mismatch, the change should be\r\n * due to a spellcheck change, and we can incorporate it into our model.\r\n */\n\n\nfunction editOnInput(editor, e) {\n  if (editor._pendingStateFromBeforeInput !== undefined) {\n    editor.update(editor._pendingStateFromBeforeInput);\n    editor._pendingStateFromBeforeInput = undefined;\n  } // at this point editor is not null for sure (after input)\n\n\n  var castedEditorElement = editor.editor;\n  var domSelection = castedEditorElement.ownerDocument.defaultView.getSelection();\n  var anchorNode = domSelection.anchorNode,\n      isCollapsed = domSelection.isCollapsed;\n  var isNotTextOrElementNode = (anchorNode === null || anchorNode === void 0 ? void 0 : anchorNode.nodeType) !== Node.TEXT_NODE && (anchorNode === null || anchorNode === void 0 ? void 0 : anchorNode.nodeType) !== Node.ELEMENT_NODE;\n\n  if (anchorNode == null || isNotTextOrElementNode) {\n    // TODO: (t16149272) figure out context for this change\n    return;\n  }\n\n  if (anchorNode.nodeType === Node.TEXT_NODE && (anchorNode.previousSibling !== null || anchorNode.nextSibling !== null)) {\n    // When typing at the beginning of a visual line, Chrome splits the text\n    // nodes into two. Why? No one knows. This commit is suspicious:\n    // https://chromium.googlesource.com/chromium/src/+/a3b600981286b135632371477f902214c55a1724\n    // To work around, we'll merge the sibling text nodes back into this one.\n    var span = anchorNode.parentNode;\n\n    if (span == null) {\n      // Handle null-parent case.\n      return;\n    }\n\n    anchorNode.nodeValue = span.textContent;\n\n    for (var child = span.firstChild; child != null; child = child.nextSibling) {\n      if (child !== anchorNode) {\n        span.removeChild(child);\n      }\n    }\n  }\n\n  var domText = anchorNode.textContent;\n  var editorState = editor._latestEditorState;\n  var offsetKey = nullthrows(findAncestorOffsetKey(anchorNode));\n\n  var _DraftOffsetKey$decod = DraftOffsetKey.decode(offsetKey),\n      blockKey = _DraftOffsetKey$decod.blockKey,\n      decoratorKey = _DraftOffsetKey$decod.decoratorKey,\n      leafKey = _DraftOffsetKey$decod.leafKey;\n\n  var _editorState$getBlock = editorState.getBlockTree(blockKey).getIn([decoratorKey, 'leaves', leafKey]),\n      start = _editorState$getBlock.start,\n      end = _editorState$getBlock.end;\n\n  var content = editorState.getCurrentContent();\n  var block = content.getBlockForKey(blockKey);\n  var modelText = block.getText().slice(start, end); // Special-case soft newlines here. If the DOM text ends in a soft newline,\n  // we will have manually inserted an extra soft newline in DraftEditorLeaf.\n  // We want to remove this extra newline for the purpose of our comparison\n  // of DOM and model text.\n\n  if (domText.endsWith(DOUBLE_NEWLINE)) {\n    domText = domText.slice(0, -1);\n  } // No change -- the DOM is up to date. Nothing to do here.\n\n\n  if (domText === modelText) {\n    // This can be buggy for some Android keyboards because they don't fire\n    // standard onkeydown/pressed events and only fired editOnInput\n    // so domText is already changed by the browser and ends up being equal\n    // to modelText unexpectedly.\n    // Newest versions of Android support the dom-inputevent-inputtype\n    // and we can use the `inputType` to properly apply the state changes.\n\n    /* $FlowFixMe[prop-missing] inputType is only defined on a draft of a\r\n     * standard. https://w3c.github.io/input-events/#dom-inputevent-inputtype\r\n     */\n    var inputType = e.nativeEvent.inputType;\n\n    if (inputType) {\n      var newEditorState = onInputType(inputType, editorState);\n\n      if (newEditorState !== editorState) {\n        editor.restoreEditorDOM();\n        editor.update(newEditorState);\n        return;\n      }\n    }\n\n    return;\n  }\n\n  var selection = editorState.getSelection(); // We'll replace the entire leaf with the text content of the target.\n\n  var targetRange = selection.merge({\n    anchorOffset: start,\n    focusOffset: end,\n    isBackward: false\n  });\n  var entityKey = block.getEntityAt(start);\n  var entity = notEmptyKey(entityKey) ? content.getEntity(entityKey) : null;\n  var entityType = entity != null ? entity.getMutability() : null;\n  var preserveEntity = entityType === 'MUTABLE'; // Immutable or segmented entities cannot properly be handled by the\n  // default browser undo, so we have to use a different change type to\n  // force using our internal undo method instead of falling through to the\n  // native browser undo.\n\n  var changeType = preserveEntity ? 'spellcheck-change' : 'apply-entity';\n  var newContent = DraftModifier.replaceText(content, targetRange, domText, block.getInlineStyleAt(start), preserveEntity ? block.getEntityAt(start) : null);\n  var anchorOffset, focusOffset, startOffset, endOffset;\n\n  if (isGecko) {\n    // Firefox selection does not change while the context menu is open, so\n    // we preserve the anchor and focus values of the DOM selection.\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n    startOffset = start + Math.min(anchorOffset, focusOffset);\n    endOffset = startOffset + Math.abs(anchorOffset - focusOffset);\n    anchorOffset = startOffset;\n    focusOffset = endOffset;\n  } else {\n    // Browsers other than Firefox may adjust DOM selection while the context\n    // menu is open, and Safari autocorrect is prone to providing an inaccurate\n    // DOM selection. Don't trust it. Instead, use our existing SelectionState\n    // and adjust it based on the number of characters changed during the\n    // mutation.\n    var charDelta = domText.length - modelText.length;\n    startOffset = selection.getStartOffset();\n    endOffset = selection.getEndOffset();\n    anchorOffset = isCollapsed ? endOffset + charDelta : startOffset;\n    focusOffset = endOffset + charDelta;\n  } // Segmented entities are completely or partially removed when their\n  // text content changes. For this case we do not want any text to be selected\n  // after the change, so we are not merging the selection.\n\n\n  var contentWithAdjustedDOMSelection = newContent.merge({\n    selectionBefore: content.getSelectionAfter(),\n    selectionAfter: selection.merge({\n      anchorOffset: anchorOffset,\n      focusOffset: focusOffset\n    })\n  });\n  editor.update(EditorState.push(editorState, contentWithAdjustedDOMSelection, changeType));\n}\n\nmodule.exports = editOnInput;","map":{"version":3,"sources":["D:/Web/mohi/client/node_modules/draft-js/lib/editOnInput.js"],"names":["DraftModifier","require","DraftOffsetKey","EditorState","UserAgent","_require","notEmptyKey","findAncestorOffsetKey","keyCommandPlainBackspace","nullthrows","isGecko","isEngine","DOUBLE_NEWLINE","onInputType","inputType","editorState","editOnInput","editor","e","_pendingStateFromBeforeInput","undefined","update","castedEditorElement","domSelection","ownerDocument","defaultView","getSelection","anchorNode","isCollapsed","isNotTextOrElementNode","nodeType","Node","TEXT_NODE","ELEMENT_NODE","previousSibling","nextSibling","span","parentNode","nodeValue","textContent","child","firstChild","removeChild","domText","_latestEditorState","offsetKey","_DraftOffsetKey$decod","decode","blockKey","decoratorKey","leafKey","_editorState$getBlock","getBlockTree","getIn","start","end","content","getCurrentContent","block","getBlockForKey","modelText","getText","slice","endsWith","nativeEvent","newEditorState","restoreEditorDOM","selection","targetRange","merge","anchorOffset","focusOffset","isBackward","entityKey","getEntityAt","entity","getEntity","entityType","getMutability","preserveEntity","changeType","newContent","replaceText","getInlineStyleAt","startOffset","endOffset","Math","min","abs","charDelta","length","getStartOffset","getEndOffset","contentWithAdjustedDOMSelection","selectionBefore","getSelectionAfter","selectionAfter","push","module","exports"],"mappings":"AAAA;;;;;;;;;;AAUA;;AAEA,IAAIA,aAAa,GAAGC,OAAO,CAAC,iBAAD,CAA3B;;AAEA,IAAIC,cAAc,GAAGD,OAAO,CAAC,kBAAD,CAA5B;;AAEA,IAAIE,WAAW,GAAGF,OAAO,CAAC,eAAD,CAAzB;;AAEA,IAAIG,SAAS,GAAGH,OAAO,CAAC,oBAAD,CAAvB;;AAEA,IAAII,QAAQ,GAAGJ,OAAO,CAAC,iBAAD,CAAtB;AAAA,IACIK,WAAW,GAAGD,QAAQ,CAACC,WAD3B;;AAGA,IAAIC,qBAAqB,GAAGN,OAAO,CAAC,yBAAD,CAAnC;;AAEA,IAAIO,wBAAwB,GAAGP,OAAO,CAAC,4BAAD,CAAtC;;AAEA,IAAIQ,UAAU,GAAGR,OAAO,CAAC,qBAAD,CAAxB;;AAEA,IAAIS,OAAO,GAAGN,SAAS,CAACO,QAAV,CAAmB,OAAnB,CAAd;AACA,IAAIC,cAAc,GAAG,MAArB;;AAEA,SAASC,WAAT,CAAqBC,SAArB,EAAgCC,WAAhC,EAA6C;AAC3C,UAAQD,SAAR;AACE,SAAK,uBAAL;AACE,aAAON,wBAAwB,CAACO,WAAD,CAA/B;AAFJ;;AAKA,SAAOA,WAAP;AACD;AACD;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,SAASC,WAAT,CAAqBC,MAArB,EAA6BC,CAA7B,EAAgC;AAC9B,MAAID,MAAM,CAACE,4BAAP,KAAwCC,SAA5C,EAAuD;AACrDH,IAAAA,MAAM,CAACI,MAAP,CAAcJ,MAAM,CAACE,4BAArB;AACAF,IAAAA,MAAM,CAACE,4BAAP,GAAsCC,SAAtC;AACD,GAJ6B,CAI5B;;;AAGF,MAAIE,mBAAmB,GAAGL,MAAM,CAACA,MAAjC;AACA,MAAIM,YAAY,GAAGD,mBAAmB,CAACE,aAApB,CAAkCC,WAAlC,CAA8CC,YAA9C,EAAnB;AACA,MAAIC,UAAU,GAAGJ,YAAY,CAACI,UAA9B;AAAA,MACIC,WAAW,GAAGL,YAAY,CAACK,WAD/B;AAEA,MAAIC,sBAAsB,GAAG,CAACF,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAK,KAAK,CAA3C,GAA+C,KAAK,CAApD,GAAwDA,UAAU,CAACG,QAApE,MAAkFC,IAAI,CAACC,SAAvF,IAAoG,CAACL,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAK,KAAK,CAA3C,GAA+C,KAAK,CAApD,GAAwDA,UAAU,CAACG,QAApE,MAAkFC,IAAI,CAACE,YAAxN;;AAEA,MAAIN,UAAU,IAAI,IAAd,IAAsBE,sBAA1B,EAAkD;AAChD;AACA;AACD;;AAED,MAAIF,UAAU,CAACG,QAAX,KAAwBC,IAAI,CAACC,SAA7B,KAA2CL,UAAU,CAACO,eAAX,KAA+B,IAA/B,IAAuCP,UAAU,CAACQ,WAAX,KAA2B,IAA7G,CAAJ,EAAwH;AACtH;AACA;AACA;AACA;AACA,QAAIC,IAAI,GAAGT,UAAU,CAACU,UAAtB;;AAEA,QAAID,IAAI,IAAI,IAAZ,EAAkB;AAChB;AACA;AACD;;AAEDT,IAAAA,UAAU,CAACW,SAAX,GAAuBF,IAAI,CAACG,WAA5B;;AAEA,SAAK,IAAIC,KAAK,GAAGJ,IAAI,CAACK,UAAtB,EAAkCD,KAAK,IAAI,IAA3C,EAAiDA,KAAK,GAAGA,KAAK,CAACL,WAA/D,EAA4E;AAC1E,UAAIK,KAAK,KAAKb,UAAd,EAA0B;AACxBS,QAAAA,IAAI,CAACM,WAAL,CAAiBF,KAAjB;AACD;AACF;AACF;;AAED,MAAIG,OAAO,GAAGhB,UAAU,CAACY,WAAzB;AACA,MAAIxB,WAAW,GAAGE,MAAM,CAAC2B,kBAAzB;AACA,MAAIC,SAAS,GAAGpC,UAAU,CAACF,qBAAqB,CAACoB,UAAD,CAAtB,CAA1B;;AAEA,MAAImB,qBAAqB,GAAG5C,cAAc,CAAC6C,MAAf,CAAsBF,SAAtB,CAA5B;AAAA,MACIG,QAAQ,GAAGF,qBAAqB,CAACE,QADrC;AAAA,MAEIC,YAAY,GAAGH,qBAAqB,CAACG,YAFzC;AAAA,MAGIC,OAAO,GAAGJ,qBAAqB,CAACI,OAHpC;;AAKA,MAAIC,qBAAqB,GAAGpC,WAAW,CAACqC,YAAZ,CAAyBJ,QAAzB,EAAmCK,KAAnC,CAAyC,CAACJ,YAAD,EAAe,QAAf,EAAyBC,OAAzB,CAAzC,CAA5B;AAAA,MACII,KAAK,GAAGH,qBAAqB,CAACG,KADlC;AAAA,MAEIC,GAAG,GAAGJ,qBAAqB,CAACI,GAFhC;;AAIA,MAAIC,OAAO,GAAGzC,WAAW,CAAC0C,iBAAZ,EAAd;AACA,MAAIC,KAAK,GAAGF,OAAO,CAACG,cAAR,CAAuBX,QAAvB,CAAZ;AACA,MAAIY,SAAS,GAAGF,KAAK,CAACG,OAAN,GAAgBC,KAAhB,CAAsBR,KAAtB,EAA6BC,GAA7B,CAAhB,CAtD8B,CAsDqB;AACnD;AACA;AACA;;AAEA,MAAIZ,OAAO,CAACoB,QAAR,CAAiBnD,cAAjB,CAAJ,EAAsC;AACpC+B,IAAAA,OAAO,GAAGA,OAAO,CAACmB,KAAR,CAAc,CAAd,EAAiB,CAAC,CAAlB,CAAV;AACD,GA7D6B,CA6D5B;;;AAGF,MAAInB,OAAO,KAAKiB,SAAhB,EAA2B;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,QAAI9C,SAAS,GAAGI,CAAC,CAAC8C,WAAF,CAAclD,SAA9B;;AAEA,QAAIA,SAAJ,EAAe;AACb,UAAImD,cAAc,GAAGpD,WAAW,CAACC,SAAD,EAAYC,WAAZ,CAAhC;;AAEA,UAAIkD,cAAc,KAAKlD,WAAvB,EAAoC;AAClCE,QAAAA,MAAM,CAACiD,gBAAP;AACAjD,QAAAA,MAAM,CAACI,MAAP,CAAc4C,cAAd;AACA;AACD;AACF;;AAED;AACD;;AAED,MAAIE,SAAS,GAAGpD,WAAW,CAACW,YAAZ,EAAhB,CA1F8B,CA0Fc;;AAE5C,MAAI0C,WAAW,GAAGD,SAAS,CAACE,KAAV,CAAgB;AAChCC,IAAAA,YAAY,EAAEhB,KADkB;AAEhCiB,IAAAA,WAAW,EAAEhB,GAFmB;AAGhCiB,IAAAA,UAAU,EAAE;AAHoB,GAAhB,CAAlB;AAKA,MAAIC,SAAS,GAAGf,KAAK,CAACgB,WAAN,CAAkBpB,KAAlB,CAAhB;AACA,MAAIqB,MAAM,GAAGrE,WAAW,CAACmE,SAAD,CAAX,GAAyBjB,OAAO,CAACoB,SAAR,CAAkBH,SAAlB,CAAzB,GAAwD,IAArE;AACA,MAAII,UAAU,GAAGF,MAAM,IAAI,IAAV,GAAiBA,MAAM,CAACG,aAAP,EAAjB,GAA0C,IAA3D;AACA,MAAIC,cAAc,GAAGF,UAAU,KAAK,SAApC,CApG8B,CAoGiB;AAC/C;AACA;AACA;;AAEA,MAAIG,UAAU,GAAGD,cAAc,GAAG,mBAAH,GAAyB,cAAxD;AACA,MAAIE,UAAU,GAAGjF,aAAa,CAACkF,WAAd,CAA0B1B,OAA1B,EAAmCY,WAAnC,EAAgDzB,OAAhD,EAAyDe,KAAK,CAACyB,gBAAN,CAAuB7B,KAAvB,CAAzD,EAAwFyB,cAAc,GAAGrB,KAAK,CAACgB,WAAN,CAAkBpB,KAAlB,CAAH,GAA8B,IAApI,CAAjB;AACA,MAAIgB,YAAJ,EAAkBC,WAAlB,EAA+Ba,WAA/B,EAA4CC,SAA5C;;AAEA,MAAI3E,OAAJ,EAAa;AACX;AACA;AACA4D,IAAAA,YAAY,GAAG/C,YAAY,CAAC+C,YAA5B;AACAC,IAAAA,WAAW,GAAGhD,YAAY,CAACgD,WAA3B;AACAa,IAAAA,WAAW,GAAG9B,KAAK,GAAGgC,IAAI,CAACC,GAAL,CAASjB,YAAT,EAAuBC,WAAvB,CAAtB;AACAc,IAAAA,SAAS,GAAGD,WAAW,GAAGE,IAAI,CAACE,GAAL,CAASlB,YAAY,GAAGC,WAAxB,CAA1B;AACAD,IAAAA,YAAY,GAAGc,WAAf;AACAb,IAAAA,WAAW,GAAGc,SAAd;AACD,GATD,MASO;AACL;AACA;AACA;AACA;AACA;AACA,QAAII,SAAS,GAAG9C,OAAO,CAAC+C,MAAR,GAAiB9B,SAAS,CAAC8B,MAA3C;AACAN,IAAAA,WAAW,GAAGjB,SAAS,CAACwB,cAAV,EAAd;AACAN,IAAAA,SAAS,GAAGlB,SAAS,CAACyB,YAAV,EAAZ;AACAtB,IAAAA,YAAY,GAAG1C,WAAW,GAAGyD,SAAS,GAAGI,SAAf,GAA2BL,WAArD;AACAb,IAAAA,WAAW,GAAGc,SAAS,GAAGI,SAA1B;AACD,GAjI6B,CAiI5B;AACF;AACA;;;AAGA,MAAII,+BAA+B,GAAGZ,UAAU,CAACZ,KAAX,CAAiB;AACrDyB,IAAAA,eAAe,EAAEtC,OAAO,CAACuC,iBAAR,EADoC;AAErDC,IAAAA,cAAc,EAAE7B,SAAS,CAACE,KAAV,CAAgB;AAC9BC,MAAAA,YAAY,EAAEA,YADgB;AAE9BC,MAAAA,WAAW,EAAEA;AAFiB,KAAhB;AAFqC,GAAjB,CAAtC;AAOAtD,EAAAA,MAAM,CAACI,MAAP,CAAclB,WAAW,CAAC8F,IAAZ,CAAiBlF,WAAjB,EAA8B8E,+BAA9B,EAA+Db,UAA/D,CAAd;AACD;;AAEDkB,MAAM,CAACC,OAAP,GAAiBnF,WAAjB","sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @format\r\n * \r\n * @emails oncall+draft_js\r\n */\r\n'use strict';\r\n\r\nvar DraftModifier = require(\"./DraftModifier\");\r\n\r\nvar DraftOffsetKey = require(\"./DraftOffsetKey\");\r\n\r\nvar EditorState = require(\"./EditorState\");\r\n\r\nvar UserAgent = require(\"fbjs/lib/UserAgent\");\r\n\r\nvar _require = require(\"./draftKeyUtils\"),\r\n    notEmptyKey = _require.notEmptyKey;\r\n\r\nvar findAncestorOffsetKey = require(\"./findAncestorOffsetKey\");\r\n\r\nvar keyCommandPlainBackspace = require(\"./keyCommandPlainBackspace\");\r\n\r\nvar nullthrows = require(\"fbjs/lib/nullthrows\");\r\n\r\nvar isGecko = UserAgent.isEngine('Gecko');\r\nvar DOUBLE_NEWLINE = '\\n\\n';\r\n\r\nfunction onInputType(inputType, editorState) {\r\n  switch (inputType) {\r\n    case 'deleteContentBackward':\r\n      return keyCommandPlainBackspace(editorState);\r\n  }\r\n\r\n  return editorState;\r\n}\r\n/**\r\n * This function serves two purposes\r\n *\r\n * 1. To update the editorState and call onChange method with the new\r\n * editorState. This editorState is calculated in editOnBeforeInput but the\r\n * onChange method is not called with the new state until this method does it.\r\n * It is done to handle a specific case where certain character inputs might\r\n * be replaced with something else. E.g. snippets ('rc' might be replaced\r\n * with boilerplate code for react component). More information on the\r\n * exact problem can be found here -\r\n * https://github.com/facebook/draft-js/commit/07892ba479bd4dfc6afd1e0ed179aaf51cd138b1\r\n *\r\n * 2. intended to handle spellcheck and autocorrect changes,\r\n * which occur in the DOM natively without any opportunity to observe or\r\n * interpret the changes before they occur.\r\n *\r\n * The `input` event fires in contentEditable elements reliably for non-IE\r\n * browsers, immediately after changes occur to the editor DOM. Since our other\r\n * handlers override or otherwise handle cover other varieties of text input,\r\n * the DOM state should match the model in all controlled input cases. Thus,\r\n * when an `input` change leads to a DOM/model mismatch, the change should be\r\n * due to a spellcheck change, and we can incorporate it into our model.\r\n */\r\n\r\n\r\nfunction editOnInput(editor, e) {\r\n  if (editor._pendingStateFromBeforeInput !== undefined) {\r\n    editor.update(editor._pendingStateFromBeforeInput);\r\n    editor._pendingStateFromBeforeInput = undefined;\r\n  } // at this point editor is not null for sure (after input)\r\n\r\n\r\n  var castedEditorElement = editor.editor;\r\n  var domSelection = castedEditorElement.ownerDocument.defaultView.getSelection();\r\n  var anchorNode = domSelection.anchorNode,\r\n      isCollapsed = domSelection.isCollapsed;\r\n  var isNotTextOrElementNode = (anchorNode === null || anchorNode === void 0 ? void 0 : anchorNode.nodeType) !== Node.TEXT_NODE && (anchorNode === null || anchorNode === void 0 ? void 0 : anchorNode.nodeType) !== Node.ELEMENT_NODE;\r\n\r\n  if (anchorNode == null || isNotTextOrElementNode) {\r\n    // TODO: (t16149272) figure out context for this change\r\n    return;\r\n  }\r\n\r\n  if (anchorNode.nodeType === Node.TEXT_NODE && (anchorNode.previousSibling !== null || anchorNode.nextSibling !== null)) {\r\n    // When typing at the beginning of a visual line, Chrome splits the text\r\n    // nodes into two. Why? No one knows. This commit is suspicious:\r\n    // https://chromium.googlesource.com/chromium/src/+/a3b600981286b135632371477f902214c55a1724\r\n    // To work around, we'll merge the sibling text nodes back into this one.\r\n    var span = anchorNode.parentNode;\r\n\r\n    if (span == null) {\r\n      // Handle null-parent case.\r\n      return;\r\n    }\r\n\r\n    anchorNode.nodeValue = span.textContent;\r\n\r\n    for (var child = span.firstChild; child != null; child = child.nextSibling) {\r\n      if (child !== anchorNode) {\r\n        span.removeChild(child);\r\n      }\r\n    }\r\n  }\r\n\r\n  var domText = anchorNode.textContent;\r\n  var editorState = editor._latestEditorState;\r\n  var offsetKey = nullthrows(findAncestorOffsetKey(anchorNode));\r\n\r\n  var _DraftOffsetKey$decod = DraftOffsetKey.decode(offsetKey),\r\n      blockKey = _DraftOffsetKey$decod.blockKey,\r\n      decoratorKey = _DraftOffsetKey$decod.decoratorKey,\r\n      leafKey = _DraftOffsetKey$decod.leafKey;\r\n\r\n  var _editorState$getBlock = editorState.getBlockTree(blockKey).getIn([decoratorKey, 'leaves', leafKey]),\r\n      start = _editorState$getBlock.start,\r\n      end = _editorState$getBlock.end;\r\n\r\n  var content = editorState.getCurrentContent();\r\n  var block = content.getBlockForKey(blockKey);\r\n  var modelText = block.getText().slice(start, end); // Special-case soft newlines here. If the DOM text ends in a soft newline,\r\n  // we will have manually inserted an extra soft newline in DraftEditorLeaf.\r\n  // We want to remove this extra newline for the purpose of our comparison\r\n  // of DOM and model text.\r\n\r\n  if (domText.endsWith(DOUBLE_NEWLINE)) {\r\n    domText = domText.slice(0, -1);\r\n  } // No change -- the DOM is up to date. Nothing to do here.\r\n\r\n\r\n  if (domText === modelText) {\r\n    // This can be buggy for some Android keyboards because they don't fire\r\n    // standard onkeydown/pressed events and only fired editOnInput\r\n    // so domText is already changed by the browser and ends up being equal\r\n    // to modelText unexpectedly.\r\n    // Newest versions of Android support the dom-inputevent-inputtype\r\n    // and we can use the `inputType` to properly apply the state changes.\r\n\r\n    /* $FlowFixMe[prop-missing] inputType is only defined on a draft of a\r\n     * standard. https://w3c.github.io/input-events/#dom-inputevent-inputtype\r\n     */\r\n    var inputType = e.nativeEvent.inputType;\r\n\r\n    if (inputType) {\r\n      var newEditorState = onInputType(inputType, editorState);\r\n\r\n      if (newEditorState !== editorState) {\r\n        editor.restoreEditorDOM();\r\n        editor.update(newEditorState);\r\n        return;\r\n      }\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  var selection = editorState.getSelection(); // We'll replace the entire leaf with the text content of the target.\r\n\r\n  var targetRange = selection.merge({\r\n    anchorOffset: start,\r\n    focusOffset: end,\r\n    isBackward: false\r\n  });\r\n  var entityKey = block.getEntityAt(start);\r\n  var entity = notEmptyKey(entityKey) ? content.getEntity(entityKey) : null;\r\n  var entityType = entity != null ? entity.getMutability() : null;\r\n  var preserveEntity = entityType === 'MUTABLE'; // Immutable or segmented entities cannot properly be handled by the\r\n  // default browser undo, so we have to use a different change type to\r\n  // force using our internal undo method instead of falling through to the\r\n  // native browser undo.\r\n\r\n  var changeType = preserveEntity ? 'spellcheck-change' : 'apply-entity';\r\n  var newContent = DraftModifier.replaceText(content, targetRange, domText, block.getInlineStyleAt(start), preserveEntity ? block.getEntityAt(start) : null);\r\n  var anchorOffset, focusOffset, startOffset, endOffset;\r\n\r\n  if (isGecko) {\r\n    // Firefox selection does not change while the context menu is open, so\r\n    // we preserve the anchor and focus values of the DOM selection.\r\n    anchorOffset = domSelection.anchorOffset;\r\n    focusOffset = domSelection.focusOffset;\r\n    startOffset = start + Math.min(anchorOffset, focusOffset);\r\n    endOffset = startOffset + Math.abs(anchorOffset - focusOffset);\r\n    anchorOffset = startOffset;\r\n    focusOffset = endOffset;\r\n  } else {\r\n    // Browsers other than Firefox may adjust DOM selection while the context\r\n    // menu is open, and Safari autocorrect is prone to providing an inaccurate\r\n    // DOM selection. Don't trust it. Instead, use our existing SelectionState\r\n    // and adjust it based on the number of characters changed during the\r\n    // mutation.\r\n    var charDelta = domText.length - modelText.length;\r\n    startOffset = selection.getStartOffset();\r\n    endOffset = selection.getEndOffset();\r\n    anchorOffset = isCollapsed ? endOffset + charDelta : startOffset;\r\n    focusOffset = endOffset + charDelta;\r\n  } // Segmented entities are completely or partially removed when their\r\n  // text content changes. For this case we do not want any text to be selected\r\n  // after the change, so we are not merging the selection.\r\n\r\n\r\n  var contentWithAdjustedDOMSelection = newContent.merge({\r\n    selectionBefore: content.getSelectionAfter(),\r\n    selectionAfter: selection.merge({\r\n      anchorOffset: anchorOffset,\r\n      focusOffset: focusOffset\r\n    })\r\n  });\r\n  editor.update(EditorState.push(editorState, contentWithAdjustedDOMSelection, changeType));\r\n}\r\n\r\nmodule.exports = editOnInput;"]},"metadata":{},"sourceType":"script"}