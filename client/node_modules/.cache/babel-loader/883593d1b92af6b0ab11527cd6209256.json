{"ast":null,"code":"/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @typechecks\r\n */\n\n/**\r\n * Unicode-enabled replacesments for basic String functions.\r\n *\r\n * All the functions in this module assume that the input string is a valid\r\n * UTF-16 encoding of a Unicode sequence. If it's not the case, the behavior\r\n * will be undefined.\r\n *\r\n * WARNING: Since this module is typechecks-enforced, you may find new bugs\r\n * when replacing normal String functions with ones provided here.\r\n */\n'use strict';\n\nvar invariant = require(\"./invariant\"); // These two ranges are consecutive so anything in [HIGH_START, LOW_END] is a\n// surrogate code unit.\n\n\nvar SURROGATE_HIGH_START = 0xD800;\nvar SURROGATE_HIGH_END = 0xDBFF;\nvar SURROGATE_LOW_START = 0xDC00;\nvar SURROGATE_LOW_END = 0xDFFF;\nvar SURROGATE_UNITS_REGEX = /[\\uD800-\\uDFFF]/;\n/**\r\n * @param {number} codeUnit   A Unicode code-unit, in range [0, 0x10FFFF]\r\n * @return {boolean}          Whether code-unit is in a surrogate (hi/low) range\r\n */\n\nfunction isCodeUnitInSurrogateRange(codeUnit) {\n  return SURROGATE_HIGH_START <= codeUnit && codeUnit <= SURROGATE_LOW_END;\n}\n/**\r\n * Returns whether the two characters starting at `index` form a surrogate pair.\r\n * For example, given the string s = \"\\uD83D\\uDE0A\", (s, 0) returns true and\r\n * (s, 1) returns false.\r\n *\r\n * @param {string} str\r\n * @param {number} index\r\n * @return {boolean}\r\n */\n\n\nfunction isSurrogatePair(str, index) {\n  !(0 <= index && index < str.length) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'isSurrogatePair: Invalid index %s for string length %s.', index, str.length) : invariant(false) : void 0;\n\n  if (index + 1 === str.length) {\n    return false;\n  }\n\n  var first = str.charCodeAt(index);\n  var second = str.charCodeAt(index + 1);\n  return SURROGATE_HIGH_START <= first && first <= SURROGATE_HIGH_END && SURROGATE_LOW_START <= second && second <= SURROGATE_LOW_END;\n}\n/**\r\n * @param {string} str  Non-empty string\r\n * @return {boolean}    True if the input includes any surrogate code units\r\n */\n\n\nfunction hasSurrogateUnit(str) {\n  return SURROGATE_UNITS_REGEX.test(str);\n}\n/**\r\n * Return the length of the original Unicode character at given position in the\r\n * String by looking into the UTF-16 code unit; that is equal to 1 for any\r\n * non-surrogate characters in BMP ([U+0000..U+D7FF] and [U+E000, U+FFFF]); and\r\n * returns 2 for the hi/low surrogates ([U+D800..U+DFFF]), which are in fact\r\n * representing non-BMP characters ([U+10000..U+10FFFF]).\r\n *\r\n * Examples:\r\n * - '\\u0020' => 1\r\n * - '\\u3020' => 1\r\n * - '\\uD835' => 2\r\n * - '\\uD835\\uDDEF' => 2\r\n * - '\\uDDEF' => 2\r\n *\r\n * @param {string} str  Non-empty string\r\n * @param {number} pos  Position in the string to look for one code unit\r\n * @return {number}      Number 1 or 2\r\n */\n\n\nfunction getUTF16Length(str, pos) {\n  return 1 + isCodeUnitInSurrogateRange(str.charCodeAt(pos));\n}\n/**\r\n * Fully Unicode-enabled replacement for String#length\r\n *\r\n * @param {string} str  Valid Unicode string\r\n * @return {number}     The number of Unicode characters in the string\r\n */\n\n\nfunction strlen(str) {\n  // Call the native functions if there's no surrogate char\n  if (!hasSurrogateUnit(str)) {\n    return str.length;\n  }\n\n  var len = 0;\n\n  for (var pos = 0; pos < str.length; pos += getUTF16Length(str, pos)) {\n    len++;\n  }\n\n  return len;\n}\n/**\r\n * Fully Unicode-enabled replacement for String#substr()\r\n *\r\n * @param {string} str      Valid Unicode string\r\n * @param {number} start    Location in Unicode sequence to begin extracting\r\n * @param {?number} length  The number of Unicode characters to extract\r\n *                          (default: to the end of the string)\r\n * @return {string}         Extracted sub-string\r\n */\n\n\nfunction substr(str, start, length) {\n  start = start || 0;\n  length = length === undefined ? Infinity : length || 0; // Call the native functions if there's no surrogate char\n\n  if (!hasSurrogateUnit(str)) {\n    return str.substr(start, length);\n  } // Obvious cases\n\n\n  var size = str.length;\n\n  if (size <= 0 || start > size || length <= 0) {\n    return '';\n  } // Find the actual starting position\n\n\n  var posA = 0;\n\n  if (start > 0) {\n    for (; start > 0 && posA < size; start--) {\n      posA += getUTF16Length(str, posA);\n    }\n\n    if (posA >= size) {\n      return '';\n    }\n  } else if (start < 0) {\n    for (posA = size; start < 0 && 0 < posA; start++) {\n      posA -= getUTF16Length(str, posA - 1);\n    }\n\n    if (posA < 0) {\n      posA = 0;\n    }\n  } // Find the actual ending position\n\n\n  var posB = size;\n\n  if (length < size) {\n    for (posB = posA; length > 0 && posB < size; length--) {\n      posB += getUTF16Length(str, posB);\n    }\n  }\n\n  return str.substring(posA, posB);\n}\n/**\r\n * Fully Unicode-enabled replacement for String#substring()\r\n *\r\n * @param {string} str    Valid Unicode string\r\n * @param {number} start  Location in Unicode sequence to begin extracting\r\n * @param {?number} end   Location in Unicode sequence to end extracting\r\n *                        (default: end of the string)\r\n * @return {string}       Extracted sub-string\r\n */\n\n\nfunction substring(str, start, end) {\n  start = start || 0;\n  end = end === undefined ? Infinity : end || 0;\n\n  if (start < 0) {\n    start = 0;\n  }\n\n  if (end < 0) {\n    end = 0;\n  }\n\n  var length = Math.abs(end - start);\n  start = start < end ? start : end;\n  return substr(str, start, length);\n}\n/**\r\n * Get a list of Unicode code-points from a String\r\n *\r\n * @param {string} str        Valid Unicode string\r\n * @return {array<number>}    A list of code-points in [0..0x10FFFF]\r\n */\n\n\nfunction getCodePoints(str) {\n  var codePoints = [];\n\n  for (var pos = 0; pos < str.length; pos += getUTF16Length(str, pos)) {\n    codePoints.push(str.codePointAt(pos));\n  }\n\n  return codePoints;\n}\n\nvar UnicodeUtils = {\n  getCodePoints: getCodePoints,\n  getUTF16Length: getUTF16Length,\n  hasSurrogateUnit: hasSurrogateUnit,\n  isCodeUnitInSurrogateRange: isCodeUnitInSurrogateRange,\n  isSurrogatePair: isSurrogatePair,\n  strlen: strlen,\n  substring: substring,\n  substr: substr\n};\nmodule.exports = UnicodeUtils;","map":{"version":3,"sources":["D:/Web/mohi/client/node_modules/fbjs/lib/UnicodeUtils.js"],"names":["invariant","require","SURROGATE_HIGH_START","SURROGATE_HIGH_END","SURROGATE_LOW_START","SURROGATE_LOW_END","SURROGATE_UNITS_REGEX","isCodeUnitInSurrogateRange","codeUnit","isSurrogatePair","str","index","length","process","env","NODE_ENV","first","charCodeAt","second","hasSurrogateUnit","test","getUTF16Length","pos","strlen","len","substr","start","undefined","Infinity","size","posA","posB","substring","end","Math","abs","getCodePoints","codePoints","push","codePointAt","UnicodeUtils","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @typechecks\r\n */\r\n\r\n/**\r\n * Unicode-enabled replacesments for basic String functions.\r\n *\r\n * All the functions in this module assume that the input string is a valid\r\n * UTF-16 encoding of a Unicode sequence. If it's not the case, the behavior\r\n * will be undefined.\r\n *\r\n * WARNING: Since this module is typechecks-enforced, you may find new bugs\r\n * when replacing normal String functions with ones provided here.\r\n */\r\n'use strict';\r\n\r\nvar invariant = require(\"./invariant\"); // These two ranges are consecutive so anything in [HIGH_START, LOW_END] is a\r\n// surrogate code unit.\r\n\r\n\r\nvar SURROGATE_HIGH_START = 0xD800;\r\nvar SURROGATE_HIGH_END = 0xDBFF;\r\nvar SURROGATE_LOW_START = 0xDC00;\r\nvar SURROGATE_LOW_END = 0xDFFF;\r\nvar SURROGATE_UNITS_REGEX = /[\\uD800-\\uDFFF]/;\r\n/**\r\n * @param {number} codeUnit   A Unicode code-unit, in range [0, 0x10FFFF]\r\n * @return {boolean}          Whether code-unit is in a surrogate (hi/low) range\r\n */\r\n\r\nfunction isCodeUnitInSurrogateRange(codeUnit) {\r\n  return SURROGATE_HIGH_START <= codeUnit && codeUnit <= SURROGATE_LOW_END;\r\n}\r\n/**\r\n * Returns whether the two characters starting at `index` form a surrogate pair.\r\n * For example, given the string s = \"\\uD83D\\uDE0A\", (s, 0) returns true and\r\n * (s, 1) returns false.\r\n *\r\n * @param {string} str\r\n * @param {number} index\r\n * @return {boolean}\r\n */\r\n\r\n\r\nfunction isSurrogatePair(str, index) {\r\n  !(0 <= index && index < str.length) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'isSurrogatePair: Invalid index %s for string length %s.', index, str.length) : invariant(false) : void 0;\r\n\r\n  if (index + 1 === str.length) {\r\n    return false;\r\n  }\r\n\r\n  var first = str.charCodeAt(index);\r\n  var second = str.charCodeAt(index + 1);\r\n  return SURROGATE_HIGH_START <= first && first <= SURROGATE_HIGH_END && SURROGATE_LOW_START <= second && second <= SURROGATE_LOW_END;\r\n}\r\n/**\r\n * @param {string} str  Non-empty string\r\n * @return {boolean}    True if the input includes any surrogate code units\r\n */\r\n\r\n\r\nfunction hasSurrogateUnit(str) {\r\n  return SURROGATE_UNITS_REGEX.test(str);\r\n}\r\n/**\r\n * Return the length of the original Unicode character at given position in the\r\n * String by looking into the UTF-16 code unit; that is equal to 1 for any\r\n * non-surrogate characters in BMP ([U+0000..U+D7FF] and [U+E000, U+FFFF]); and\r\n * returns 2 for the hi/low surrogates ([U+D800..U+DFFF]), which are in fact\r\n * representing non-BMP characters ([U+10000..U+10FFFF]).\r\n *\r\n * Examples:\r\n * - '\\u0020' => 1\r\n * - '\\u3020' => 1\r\n * - '\\uD835' => 2\r\n * - '\\uD835\\uDDEF' => 2\r\n * - '\\uDDEF' => 2\r\n *\r\n * @param {string} str  Non-empty string\r\n * @param {number} pos  Position in the string to look for one code unit\r\n * @return {number}      Number 1 or 2\r\n */\r\n\r\n\r\nfunction getUTF16Length(str, pos) {\r\n  return 1 + isCodeUnitInSurrogateRange(str.charCodeAt(pos));\r\n}\r\n/**\r\n * Fully Unicode-enabled replacement for String#length\r\n *\r\n * @param {string} str  Valid Unicode string\r\n * @return {number}     The number of Unicode characters in the string\r\n */\r\n\r\n\r\nfunction strlen(str) {\r\n  // Call the native functions if there's no surrogate char\r\n  if (!hasSurrogateUnit(str)) {\r\n    return str.length;\r\n  }\r\n\r\n  var len = 0;\r\n\r\n  for (var pos = 0; pos < str.length; pos += getUTF16Length(str, pos)) {\r\n    len++;\r\n  }\r\n\r\n  return len;\r\n}\r\n/**\r\n * Fully Unicode-enabled replacement for String#substr()\r\n *\r\n * @param {string} str      Valid Unicode string\r\n * @param {number} start    Location in Unicode sequence to begin extracting\r\n * @param {?number} length  The number of Unicode characters to extract\r\n *                          (default: to the end of the string)\r\n * @return {string}         Extracted sub-string\r\n */\r\n\r\n\r\nfunction substr(str, start, length) {\r\n  start = start || 0;\r\n  length = length === undefined ? Infinity : length || 0; // Call the native functions if there's no surrogate char\r\n\r\n  if (!hasSurrogateUnit(str)) {\r\n    return str.substr(start, length);\r\n  } // Obvious cases\r\n\r\n\r\n  var size = str.length;\r\n\r\n  if (size <= 0 || start > size || length <= 0) {\r\n    return '';\r\n  } // Find the actual starting position\r\n\r\n\r\n  var posA = 0;\r\n\r\n  if (start > 0) {\r\n    for (; start > 0 && posA < size; start--) {\r\n      posA += getUTF16Length(str, posA);\r\n    }\r\n\r\n    if (posA >= size) {\r\n      return '';\r\n    }\r\n  } else if (start < 0) {\r\n    for (posA = size; start < 0 && 0 < posA; start++) {\r\n      posA -= getUTF16Length(str, posA - 1);\r\n    }\r\n\r\n    if (posA < 0) {\r\n      posA = 0;\r\n    }\r\n  } // Find the actual ending position\r\n\r\n\r\n  var posB = size;\r\n\r\n  if (length < size) {\r\n    for (posB = posA; length > 0 && posB < size; length--) {\r\n      posB += getUTF16Length(str, posB);\r\n    }\r\n  }\r\n\r\n  return str.substring(posA, posB);\r\n}\r\n/**\r\n * Fully Unicode-enabled replacement for String#substring()\r\n *\r\n * @param {string} str    Valid Unicode string\r\n * @param {number} start  Location in Unicode sequence to begin extracting\r\n * @param {?number} end   Location in Unicode sequence to end extracting\r\n *                        (default: end of the string)\r\n * @return {string}       Extracted sub-string\r\n */\r\n\r\n\r\nfunction substring(str, start, end) {\r\n  start = start || 0;\r\n  end = end === undefined ? Infinity : end || 0;\r\n\r\n  if (start < 0) {\r\n    start = 0;\r\n  }\r\n\r\n  if (end < 0) {\r\n    end = 0;\r\n  }\r\n\r\n  var length = Math.abs(end - start);\r\n  start = start < end ? start : end;\r\n  return substr(str, start, length);\r\n}\r\n/**\r\n * Get a list of Unicode code-points from a String\r\n *\r\n * @param {string} str        Valid Unicode string\r\n * @return {array<number>}    A list of code-points in [0..0x10FFFF]\r\n */\r\n\r\n\r\nfunction getCodePoints(str) {\r\n  var codePoints = [];\r\n\r\n  for (var pos = 0; pos < str.length; pos += getUTF16Length(str, pos)) {\r\n    codePoints.push(str.codePointAt(pos));\r\n  }\r\n\r\n  return codePoints;\r\n}\r\n\r\nvar UnicodeUtils = {\r\n  getCodePoints: getCodePoints,\r\n  getUTF16Length: getUTF16Length,\r\n  hasSurrogateUnit: hasSurrogateUnit,\r\n  isCodeUnitInSurrogateRange: isCodeUnitInSurrogateRange,\r\n  isSurrogatePair: isSurrogatePair,\r\n  strlen: strlen,\r\n  substring: substring,\r\n  substr: substr\r\n};\r\nmodule.exports = UnicodeUtils;"]},"metadata":{},"sourceType":"script"}