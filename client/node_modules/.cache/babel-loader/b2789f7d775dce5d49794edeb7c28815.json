{"ast":null,"code":"import React, { useEffect, useMemo, useLayoutEffect, useRef, useState, useCallback, createElement, Fragment } from 'react';\nimport { createPortal } from 'react-dom';\n\nfunction useEvent(element, event, callback, enabled = true, capture = false) {\n  return useEffect(() => {\n    if (!enabled || !element) {\n      return;\n    }\n\n    const cb = callback;\n    const el = Array.isArray(element) ? element : [element];\n    const ev = Array.isArray(event) ? event : [event];\n    el.forEach(e => {\n      ev.forEach(event => {\n        e.addEventListener(event, cb, capture);\n      });\n    });\n    return () => {\n      el.forEach(e => {\n        ev.forEach(event => {\n          e.removeEventListener(event, cb, capture);\n        });\n      });\n    };\n  }, [callback, element, enabled, event, capture]);\n}\n\nconst OutsideClickContext = /*#__PURE__*/React.createContext({});\n\nfunction isChildOf(parent, target) {\n  if (parent === target) {\n    return true;\n  }\n\n  const hasChildren = parent.children && parent.children.length > 0;\n\n  if (hasChildren) {\n    // tslint:disable-next-line\n    for (let i = 0; i < parent.children.length; i++) {\n      const child = parent.children[i];\n\n      if (child && isChildOf(child, target)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction OutsideClickGroupProvider({\n  refs,\n  children\n}) {\n  const isPartOfGroup = typeof React.useContext(OutsideClickContext) === \"function\";\n\n  if (isPartOfGroup) {\n    return children;\n  }\n\n  return /*#__PURE__*/React.createElement(OutsideClickContext.Provider, {\n    value: React.useCallback(layerRef => {\n      refs.current.add(layerRef);\n    }, [])\n  }, children);\n}\n\nfunction useRegisterGroup(refs) {\n  const registerRefToGroup = React.useContext(OutsideClickContext);\n  React.useEffect(() => {\n    const [layerRef] = refs.current.values();\n\n    if (typeof registerRefToGroup === \"function\" && layerRef) {\n      registerRefToGroup(layerRef);\n    }\n  }, [registerRefToGroup, refs]);\n}\n\nfunction useOutsideClick(refs, callback) {\n  const [events] = React.useState([\"click\"]);\n  useRegisterGroup(refs);\n  useEvent(typeof document !== \"undefined\" ? document : null, events, React.useCallback(evt => {\n    for (const ref of refs.current) {\n      if (!ref.current) {\n        continue;\n      }\n\n      if (isChildOf(ref.current, evt.target)) {\n        return;\n      }\n    }\n\n    callback();\n  }, [callback]), true, true);\n}\n\nfunction useOnScroll(elements, onScroll, environment, trackScroll = true) {\n  const memoElements = useMemo(() => typeof environment !== \"undefined\" ? [environment, ...elements] : [], [elements]);\n  useEvent(memoElements, \"scroll\", onScroll, trackScroll);\n}\n\nfunction useOnWindowResize(onResize, environment, trackResize = true) {\n  useEvent(typeof environment !== \"undefined\" ? environment : null, \"resize\", onResize, trackResize);\n}\n\nconst useIsomorphicLayoutEffect = typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n\nfunction useTrackElementResize(injectedResizeObserver, layerRef, triggerElement, isOpen, callback, environment) {\n  const callbackRef = useRef(callback);\n  callbackRef.current = callback;\n  const ResizeObserver = injectedResizeObserver || (typeof environment === \"undefined\" ? class ResizeObserver {} : environment.ResizeObserver);\n\n  if (!ResizeObserver) {\n    throw new Error(\"This browser does not support `ResizeObserver` out of the box. Please provide a polyfill as a prop.\");\n  }\n\n  const resizeObserver = useRef(new ResizeObserver(() => {\n    if (layerRef.current) {\n      callbackRef.current();\n    }\n  }));\n  useIsomorphicLayoutEffect(() => {\n    if (isOpen) {\n      if (triggerElement) {\n        resizeObserver.current.observe(triggerElement);\n      }\n    } else {\n      if (triggerElement) {\n        resizeObserver.current.unobserve(triggerElement);\n      }\n\n      if (layerRef.current) {\n        resizeObserver.current.unobserve(layerRef.current);\n      }\n    }\n  }, [isOpen, triggerElement]);\n  useEffect(() => {\n    return () => {\n      resizeObserver.current.disconnect();\n    };\n  }, []);\n  return resizeObserver.current;\n}\n\nconst EMPTY_STYLE = {};\n\nfunction isSet(value) {\n  return value !== undefined && value !== null;\n}\n\nfunction areStylesTheSame(a, b) {\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n\n  if (aKeys.length !== bKeys.length) {\n    return false;\n  }\n\n  for (let i = 0; i < Math.max(aKeys.length, bKeys.length); i++) {\n    const key = aKeys[i] || bKeys[i];\n\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction shouldUpdateStyles(prev, next) {\n  if (areStylesTheSame(prev.layer, next.layer) && areStylesTheSame(prev.arrow, next.arrow)) {\n    return false;\n  }\n\n  return true;\n} // creates a ClientRect-like object from the viewport's dimensions\n\n\nfunction getWindowClientRect(environment) {\n  return {\n    top: 0,\n    left: 0,\n    right: environment ? environment.innerWidth : 0,\n    bottom: environment ? environment.innerHeight : 0,\n    height: environment ? environment.innerHeight : 0,\n    width: environment ? environment.innerWidth : 0\n  };\n}\n\nconst convertFloat = value => parseFloat(value.replace(\"px\", \"\")); // get the outer width / height of an element\n// We effectively want the same width / height that `getBoundingClientRect()`\n// gives, minus optional `scale` transforms\n\n\nfunction getContentBox(element, environment) {\n  if (!environment) {\n    return {\n      width: 0,\n      height: 0\n    };\n  }\n\n  const {\n    width,\n    height,\n    boxSizing,\n    borderLeft,\n    borderRight,\n    borderTop,\n    borderBottom,\n    paddingLeft,\n    paddingRight,\n    paddingTop,\n    paddingBottom\n  } = environment.getComputedStyle(element);\n  return {\n    width: boxSizing === \"border-box\" ? convertFloat(width) : [width, borderLeft, borderRight, paddingLeft, paddingRight].reduce((total, value) => total + (value ? convertFloat(value) : 0), 0),\n    height: boxSizing === \"border-box\" ? convertFloat(height) : [height, borderTop, borderBottom, paddingTop, paddingBottom].reduce((total, value) => total + (value ? convertFloat(value) : 0), 0)\n  };\n} // converts a ClientRect (or DOMRect) to a plain js-object\n// usefull for destructuring for instance\n\n\nfunction clientRectToObject(clientRect) {\n  return {\n    top: clientRect.top,\n    left: clientRect.left,\n    right: clientRect.right,\n    bottom: clientRect.bottom,\n    width: clientRect.width,\n    height: clientRect.height\n  };\n}\n\nfunction getElementFromAnchorNode(anchorNode) {\n  let currentElement = anchorNode;\n\n  while (!currentElement.getBoundingClientRect) {\n    if (!currentElement.parentElement) {\n      return null;\n    }\n\n    currentElement = currentElement.parentElement;\n  }\n\n  return currentElement;\n}\n\nfunction minMax(value, {\n  min,\n  max\n}) {\n  return value < min ? min : value > max ? max : value;\n}\n\nfunction useStyleState(anchor) {\n  const [INITIAL_STYLES] = useState({\n    layer: EMPTY_STYLE,\n    arrow: EMPTY_STYLE,\n    layerSide: anchor.split(\"_\")[0].toLowerCase()\n  });\n  const [styles, setStyles] = useState(INITIAL_STYLES);\n  const lastStyles = useRef(styles);\n  return {\n    styles,\n    lastStyles,\n    setStyles,\n    resetLastStyles: () => {\n      lastStyles.current = INITIAL_STYLES;\n    }\n  };\n}\n\nconst Anchor = {\n  BOTTOM_LEFT: \"BOTTOM_LEFT\",\n  BOTTOM_RIGHT: \"BOTTOM_RIGHT\",\n  BOTTOM_CENTER: \"BOTTOM_CENTER\",\n  TOP_LEFT: \"TOP_LEFT\",\n  TOP_CENTER: \"TOP_CENTER\",\n  TOP_RIGHT: \"TOP_RIGHT\",\n  LEFT_BOTTOM: \"LEFT_BOTTOM\",\n  LEFT_CENTER: \"LEFT_CENTER\",\n  LEFT_TOP: \"LEFT_TOP\",\n  RIGHT_BOTTOM: \"RIGHT_BOTTOM\",\n  RIGHT_CENTER: \"RIGHT_CENTER\",\n  RIGHT_TOP: \"RIGHT_TOP\"\n};\nconst POSSIBLE_ANCHORS = Object.keys(Anchor);\n\nfunction getPrimaryDirection(anchor) {\n  return anchor.startsWith(\"TOP_\") || anchor.startsWith(\"BOTTOM_\") ? \"Y\" : \"X\";\n}\n\nfunction primaryIsY(primary) {\n  return primary === \"TOP\" || primary === \"BOTTOM\";\n}\n\nfunction getPrimaryByIndex(index, preferedPrimary, preferedX, preferedY) {\n  const prefferedIsY = primaryIsY(preferedPrimary);\n\n  if (index < 3) {\n    return preferedPrimary;\n  }\n\n  if (index < 6) {\n    return prefferedIsY ? preferedX : preferedY;\n  }\n\n  if (index < 9) {\n    if (prefferedIsY) {\n      return [\"LEFT\", \"RIGHT\"].filter(x => x !== preferedX)[0];\n    } else {\n      return [\"TOP\", \"BOTTOM\"].filter(x => x !== preferedY)[0];\n    }\n  }\n\n  if (prefferedIsY) {\n    return [\"TOP\", \"BOTTOM\"].filter(x => x !== preferedPrimary)[0];\n  } else {\n    return [\"LEFT\", \"RIGHT\"].filter(x => x !== preferedPrimary)[0];\n  }\n}\n\nfunction getSecondaryByIndex(index, preferedPrimary, preferedSecondary, rects) {\n  const prefferedIsY = primaryIsY(preferedPrimary);\n  const triggerHasBiggerHeight = rects.trigger.height > rects.layer.height;\n  const triggerHasBiggerWidth = rects.trigger.width > rects.layer.width;\n\n  switch (index) {\n    case 9:\n    case 0:\n      return preferedSecondary;\n\n    case 1:\n    case 10:\n      {\n        if (preferedSecondary === \"CENTER\") {\n          return prefferedIsY ? \"RIGHT\" : \"BOTTOM\";\n        }\n\n        return \"CENTER\";\n      }\n\n    case 4:\n    case 7:\n      return \"CENTER\";\n\n    case 2:\n    case 11:\n      {\n        if (prefferedIsY) {\n          return [\"LEFT\", \"RIGHT\"].filter(x => x !== preferedSecondary)[0];\n        } else {\n          return [\"TOP\", \"BOTTOM\"].filter(x => x !== preferedSecondary)[0];\n        }\n      }\n\n    case 3:\n    case 6:\n      {\n        if (prefferedIsY) {\n          return preferedPrimary === \"BOTTOM\" ? triggerHasBiggerHeight ? \"BOTTOM\" : \"TOP\" : triggerHasBiggerHeight ? \"TOP\" : \"BOTTOM\";\n        }\n\n        return preferedPrimary === \"LEFT\" ? triggerHasBiggerWidth ? \"LEFT\" : \"RIGHT\" : triggerHasBiggerWidth ? \"RIGHT\" : \"LEFT\";\n      }\n\n    case 5:\n    case 8:\n      {\n        if (prefferedIsY) {\n          return preferedPrimary === \"BOTTOM\" ? triggerHasBiggerHeight ? \"TOP\" : \"BOTTOM\" : triggerHasBiggerHeight ? \"BOTTOM\" : \"TOP\";\n        }\n\n        return preferedPrimary === \"LEFT\" ? triggerHasBiggerWidth ? \"RIGHT\" : \"LEFT\" : triggerHasBiggerWidth ? \"LEFT\" : \"RIGHT\";\n      }\n  }\n  /* istanbul ignore next */\n\n\n  return \"LEFT\";\n}\n\nfunction getSecondaryAnchorOptionsByPrimary(primary, anchorOptions) {\n  return anchorOptions.filter(anchor => anchor.startsWith(primary));\n}\n\nfunction splitAnchor(anchor) {\n  const [primary, secondary] = anchor.split(\"_\");\n  return {\n    primary,\n    secondary\n  };\n}\n\nfunction getLayerSideByAnchor(anchor) {\n  if (anchor === \"CENTER\") {\n    return \"center\";\n  }\n\n  return splitAnchor(anchor).primary.toLowerCase();\n}\n\nfunction getAnchorPriority(preferedAnchor, possibleAnchors, preferedX, preferedY, rects) {\n  const {\n    primary,\n    secondary\n  } = preferedAnchor !== \"CENTER\" ? splitAnchor(preferedAnchor) : {\n    primary: preferedY,\n    secondary: \"CENTER\"\n  };\n  let anchors = POSSIBLE_ANCHORS.map((_, index) => {\n    return getPrimaryByIndex(index, primary, preferedX, preferedY) + \"_\" + getSecondaryByIndex(index, primary, secondary, rects);\n  }).filter(anchor => possibleAnchors.indexOf(anchor) > -1); // include prefered anchor if not included in possibleAnchors\n\n  if (anchors.indexOf(preferedAnchor) === -1) {\n    /* istanbul ignore next */\n    anchors = [preferedAnchor, ...anchors];\n  }\n\n  return anchors;\n}\n\nfunction getPrimaryStyle(primary, rects, scroll, triggerOffset) {\n  const prop = primary === \"TOP\" || primary === \"BOTTOM\" ? \"top\" : \"left\";\n  const size = primary === \"TOP\" || primary === \"BOTTOM\" ? \"height\" : \"width\";\n\n  if (primary === \"TOP\" || primary === \"LEFT\") {\n    return {\n      [prop]: rects.trigger[prop] - rects.layer[size] - (rects.relativeParent[prop] - scroll[prop]) - triggerOffset\n    };\n  }\n\n  return {\n    [prop]: rects.trigger[prop] + rects.trigger[size] - (rects.relativeParent[prop] - scroll[prop]) + triggerOffset\n  };\n}\n\nfunction getCenter(rects, scroll, offsetSecondary, prop, size) {\n  return minMax(rects.trigger[prop] - rects.relativeParent[prop] + scroll[prop] + rects.trigger[size] / 2 - rects.layer[size] / 2 - offsetSecondary, getLimits(rects, scroll)[prop]);\n}\n\nfunction getLimits(rects, scroll) {\n  const topBase = rects.trigger.top - rects.relativeParent.top + scroll.top;\n  const leftBase = rects.trigger.left - rects.relativeParent.left + scroll.left;\n  return {\n    top: {\n      min: topBase - (rects.layer.height - rects.arrow.height),\n      max: topBase + (rects.trigger.height - rects.arrow.height)\n    },\n    left: {\n      min: leftBase - (rects.layer.width - rects.arrow.width),\n      max: leftBase + (rects.trigger.width - rects.arrow.width)\n    }\n  };\n}\n\nfunction getSecondaryStyle(secondary, rects, scroll, offsetSecondary, primaryDirection) {\n  if (secondary === \"CENTER\") {\n    const prop = primaryDirection === \"X\" ? \"top\" : \"left\";\n    const size = primaryDirection === \"X\" ? \"height\" : \"width\";\n    return {\n      [prop]: getCenter(rects, scroll, offsetSecondary, prop, size)\n    };\n  }\n\n  const prop = secondary === \"TOP\" || secondary === \"BOTTOM\" ? \"top\" : \"left\";\n  const size = secondary === \"TOP\" || secondary === \"BOTTOM\" ? \"height\" : \"width\";\n\n  if (secondary === \"TOP\" || secondary === \"LEFT\") {\n    return {\n      [prop]: minMax(rects.trigger[prop] - rects.relativeParent[prop] + scroll[prop] + offsetSecondary, getLimits(rects, scroll)[prop])\n    };\n  }\n\n  return {\n    [prop]: minMax(rects.trigger[prop] + rects.trigger[size] - rects.layer[size] - (rects.relativeParent[prop] - scroll[prop]) - offsetSecondary, getLimits(rects, scroll)[prop])\n  };\n}\n\nfunction getAbsolutePositions({\n  anchor,\n  rects,\n  triggerOffset,\n  offsetSecondary,\n  scrollLeft,\n  scrollTop\n}) {\n  const scroll = {\n    left: scrollLeft,\n    top: scrollTop\n  };\n\n  if (anchor === \"CENTER\") {\n    return {\n      top: getCenter(rects, scroll, 0, \"top\", \"height\"),\n      left: getCenter(rects, scroll, 0, \"left\", \"width\")\n    };\n  }\n\n  const {\n    primary,\n    secondary\n  } = splitAnchor(anchor);\n  const primaryDirection = getPrimaryDirection(anchor);\n  return { ...getPrimaryStyle(primary, rects, scroll, triggerOffset),\n    ...getSecondaryStyle(secondary, rects, scroll, offsetSecondary, primaryDirection)\n  };\n} // anticipate the width / height based on the current anchor\n\n\nfunction fixLayerDimensions(originalLayer, anchor, layerDimensions) {\n  const dimensions = typeof layerDimensions === \"function\" ? layerDimensions(getLayerSideByAnchor(anchor)) : layerDimensions;\n  return { ...clientRectToObject(originalLayer),\n    ...dimensions\n  };\n}\n\nconst propMap = {\n  TOP: {\n    side1: \"bottom\",\n    side2: \"top\",\n    size: \"height\",\n    factor: -1\n  },\n  BOTTOM: {\n    side1: \"top\",\n    side2: \"bottom\",\n    size: \"height\",\n    factor: 1\n  },\n  LEFT: {\n    side1: \"right\",\n    side2: \"left\",\n    size: \"width\",\n    factor: -1\n  },\n  RIGHT: {\n    side1: \"left\",\n    side2: \"right\",\n    size: \"width\",\n    factor: 1\n  }\n};\n\nfunction getPrimaryRect(primary, trigger, layer, triggerOffset) {\n  const {\n    side1,\n    side2,\n    size,\n    factor\n  } = propMap[primary];\n  const value = trigger[side2] + triggerOffset * factor;\n  return {\n    [side1]: value,\n    [side2]: value + layer[size] * factor\n  };\n}\n\nfunction getCenter$1(trigger, layer, offsetSecondary, prop, size) {\n  const value = trigger[prop] + trigger[size] / 2 - layer[size] / 2 - offsetSecondary;\n  return {\n    [prop]: value,\n    [prop === \"left\" ? \"right\" : \"bottom\"]: value + layer[size]\n  };\n}\n\nfunction getSecondaryRect(secondary, trigger, layer, offsetSecondary, primaryDirection) {\n  if (secondary === \"CENTER\") {\n    const prop = primaryDirection === \"X\" ? \"top\" : \"left\";\n    const size = primaryDirection === \"X\" ? \"height\" : \"width\";\n    return getCenter$1(trigger, layer, offsetSecondary, prop, size);\n  }\n\n  const {\n    side1,\n    side2,\n    size,\n    factor\n  } = propMap[secondary];\n  const value = trigger[side2] - offsetSecondary * factor;\n  return {\n    [side2]: value,\n    [side1]: value - layer[size] * factor\n  };\n}\n\nfunction getLayerRectByAnchor({\n  trigger,\n  layer,\n  anchor,\n  triggerOffset,\n  scrollOffset = 0,\n  offsetSecondary = 0,\n  layerDimensions\n}) {\n  let primaryRect;\n  let secondaryRect; // get the correct anticipated ClientRect based on the provided Anchor\n\n  const layerRect = layerDimensions ? fixLayerDimensions(layer, anchor, layerDimensions) : layer;\n\n  if (anchor === \"CENTER\") {\n    primaryRect = getCenter$1(trigger, layerRect, 0, \"top\", \"height\");\n    secondaryRect = getCenter$1(trigger, layerRect, 0, \"left\", \"width\");\n  } else {\n    const {\n      primary,\n      secondary\n    } = splitAnchor(anchor);\n    const primaryDirection = getPrimaryDirection(anchor);\n    primaryRect = getPrimaryRect(primary, trigger, layerRect, triggerOffset);\n    secondaryRect = getSecondaryRect(secondary, trigger, layerRect, offsetSecondary, primaryDirection);\n  }\n\n  const result = { ...layerRect,\n    ...primaryRect,\n    ...secondaryRect\n  }; // correct scrollOffsets\n\n  result.top = result.top - scrollOffset;\n  result.right = result.right + scrollOffset;\n  result.left = result.left - scrollOffset;\n  result.bottom = result.bottom + scrollOffset;\n  return result;\n}\n\nconst ALL_OFFSET_SIDES = [\"bottom\", \"top\", \"left\", \"right\"];\n\nfunction getLayerOffsetsToParent(layer, parent) {\n  return {\n    top: layer.top - parent.top,\n    bottom: parent.bottom - layer.bottom,\n    left: layer.left - parent.left,\n    right: parent.right - layer.right\n  };\n}\n\nfunction getLayerOffsetsToParents(layer, parents) {\n  return parents.map(parent => getLayerOffsetsToParent(layer, parent));\n}\n\nfunction isLayerCompletelyInvisible(layer, parents) {\n  return parents.some(parent => {\n    return layer.bottom <= parent.top || layer.right <= parent.left || layer.top >= parent.bottom || layer.left >= parent.right;\n  });\n}\n\nfunction doesEntireLayerFitWithinScrollParents(layer, parents) {\n  const parentOffsets = getLayerOffsetsToParents(layer, parents);\n  return parentOffsets.every(offsets => {\n    return ALL_OFFSET_SIDES.every(side => offsets[side] >= 0);\n  });\n}\n\nfunction reduceOffsets(parentOffsets) {\n  const parentOffsetsCombined = parentOffsets.reduce((result, offsets) => {\n    ALL_OFFSET_SIDES.forEach(side => {\n      result[side] = [...result[side], offsets[side]];\n    });\n    return result;\n  }, {\n    top: [],\n    bottom: [],\n    left: [],\n    right: []\n  });\n  return ALL_OFFSET_SIDES.reduce((result, side) => {\n    result[side] = parentOffsetsCombined[side].sort((a, b) => a - b)[0];\n    return result;\n  }, {});\n}\n\nfunction getNegativeOffsetSides(parentOffsets) {\n  const offsets = reduceOffsets(parentOffsets);\n  return ALL_OFFSET_SIDES.filter(side => offsets[side] < 0);\n}\n\nfunction getVisibleLayerSurface(layer, parent) {\n  const offsets = getLayerOffsetsToParent(layer, parent);\n  const {\n    width,\n    height\n  } = ALL_OFFSET_SIDES.filter(side => offsets[side] < 0).reduce((rect, side) => {\n    const affectedProperty = side === \"top\" || side === \"bottom\" ? \"height\" : \"width\";\n    return { ...rect,\n      [affectedProperty]: rect[affectedProperty] + offsets[side]\n    };\n  }, layer);\n  const result = width * height;\n  return width < 0 && height < 0 ? -result : result;\n}\n\nfunction getVisibleLayerSurfaceWithinScrollParent(layer, parents) {\n  const surfaces = parents.map(parent => getVisibleLayerSurface(layer, parent)); // pick smallest\n\n  return surfaces.sort((a, b) => a - b)[0];\n}\n\nfunction doesAnchorFitWithinScrollParents(anchor, rects, triggerOffset, scrollOffset, layerDimensions) {\n  const layerRect = getLayerRectByAnchor({\n    anchor,\n    trigger: rects.trigger,\n    layer: rects.layer,\n    triggerOffset,\n    scrollOffset,\n    layerDimensions\n  });\n  return doesEntireLayerFitWithinScrollParents(layerRect, rects.scrollParents);\n}\n\nfunction getLayerOffsetsToScrollParentsByAnchor(anchor, rects, triggerOffset, scrollOffset) {\n  return getLayerOffsetsToParents(getLayerRectByAnchor({\n    anchor,\n    trigger: rects.trigger,\n    layer: rects.layer,\n    triggerOffset,\n    scrollOffset,\n    layerDimensions: null\n  }), rects.scrollParents);\n}\n\nfunction triggerIsBiggerThanLayer(layerSide, layer, trigger) {\n  return (layerSide === \"top\" || layerSide === \"bottom\") && trigger.width > layer.width || (layerSide === \"left\" || layerSide === \"right\") && trigger.height > layer.height;\n}\n\nfunction getOffsetSurface(anchor, layer, triggerOffset, scrollOffset) {\n  const primaryDirection = getPrimaryDirection(anchor);\n  const primarySize = layer[primaryDirection === \"X\" ? \"width\" : \"height\"] - triggerOffset - scrollOffset * 2;\n  const secondarySize = layer[primaryDirection === \"X\" ? \"height\" : \"width\"] - triggerOffset - scrollOffset * 2;\n  return primarySize * secondarySize;\n}\n\nfunction findAnchorByLayerSurface(rects, anchorOptions, triggerOffset, scrollOffset, layerDimensions) {\n  const result = anchorOptions.map(anchor => {\n    // get layerRect based on all offsets\n    const layerRect = getLayerRectByAnchor({\n      anchor,\n      layer: rects.layer,\n      trigger: rects.trigger,\n      scrollOffset,\n      triggerOffset,\n      layerDimensions\n    }); // get smallest visible layer surface for current anchor\n\n    const surface = getVisibleLayerSurfaceWithinScrollParent(layerRect, rects.scrollParents); // get surface of the offsets\n    // offsets are important for collision detection, but\n    // eventually we are interested in the 'meat' of the layer\n\n    const offsetSurface = getOffsetSurface(anchor, layerRect, triggerOffset, scrollOffset);\n    return {\n      anchor,\n      square: surface - offsetSurface\n    };\n  }) // sort -> biggest surface first\n  .sort((a, b) => b.square - a.square);\n  return result[0].anchor;\n}\n\nfunction findBestSuitableAnchor(rects, anchorOptions, triggerOffset, scrollOffset, layerDimensions) {\n  // STRATEGY A\n  // find first that fits parent\n  const anchor = anchorOptions.find(anchor => doesAnchorFitWithinScrollParents(anchor, rects, triggerOffset, scrollOffset, layerDimensions));\n\n  if (anchor) {\n    return anchor;\n  } // STRATEGY B\n  // find first with biggest surface\n\n\n  return findAnchorByLayerSurface(rects, anchorOptions, triggerOffset, scrollOffset, layerDimensions);\n}\n\nfunction getSecondaryOffsetSide(currentAnchor, firstAnchorThatDoesNotFit, rects, triggerOffset, scrollOffset) {\n  const primaryDirection = getPrimaryDirection(currentAnchor);\n  const offsets = getLayerOffsetsToScrollParentsByAnchor(firstAnchorThatDoesNotFit, rects, triggerOffset, scrollOffset);\n  const sides = getNegativeOffsetSides(offsets);\n  return sides.find(side => {\n    if (primaryDirection === \"X\") {\n      return side === \"top\" || side === \"bottom\";\n    }\n\n    return side === \"left\" || side === \"right\";\n  });\n}\n\nfunction findSecondaryOffset(anchor, anchorOptions, rects, triggerOffset, scrollOffset) {\n  const {\n    primary\n  } = splitAnchor(anchor);\n  /**\n   * A.\n   * Check which other anchors available\n   */\n\n  const secondaryAnchorOptions = getSecondaryAnchorOptionsByPrimary(primary, anchorOptions);\n  /**\n   * B.\n   * Check whether current anchor is the preffered anchor and whether\n   * it fits\n   * If so, skip secondary offset\n   */\n\n  const currentAnchorHasHighestPriority = secondaryAnchorOptions.indexOf(anchor) === 0;\n  const currentAnchorFits = doesAnchorFitWithinScrollParents(anchor, rects, triggerOffset, scrollOffset, null);\n\n  if (currentAnchorHasHighestPriority && currentAnchorFits) {\n    return 0;\n  }\n  /**\n   * C.\n   * Retrieve the first anchor on same primary side (by priority) that\n   * does not fit.\n   * Check if there's a relevant side that has a negative offset.\n   * If not, skip secondary offset\n   */\n\n\n  const firstAnchorThatDoesNotFit = secondaryAnchorOptions.find(anchor => {\n    return !doesAnchorFitWithinScrollParents(anchor, rects, triggerOffset, scrollOffset, null);\n  });\n  const affectedSide = getSecondaryOffsetSide(anchor, firstAnchorThatDoesNotFit, rects, triggerOffset, scrollOffset);\n\n  if (!affectedSide) {\n    return 0;\n  }\n  /**\n   * Determine the final secondary offset\n   */\n\n\n  const currentOffsets = reduceOffsets(getLayerOffsetsToScrollParentsByAnchor(anchor, rects, triggerOffset, scrollOffset));\n  let secondaryOffset = -currentOffsets[affectedSide];\n  const triggerIsBigger = triggerIsBiggerThanLayer(getLayerSideByAnchor(anchor), rects.layer, rects.trigger);\n  const isCenter = anchor.includes(\"_CENTER\");\n  const isLeft = anchor.includes(\"_LEFT\");\n  const isTop = anchor.includes(\"_TOP\"); // when trigger is bigger, make `secondaryOffset` positive\n  // conditionally\n\n  if (triggerIsBigger && (isLeft && affectedSide === \"right\" || affectedSide === \"left\" || isTop && affectedSide === \"bottom\" || affectedSide === \"top\")) {\n    secondaryOffset = -secondaryOffset;\n  } else if ( // when current anchor is center, make `secondaryOffset` positive\n  // when affectedSide is top or right\n  !triggerIsBigger && isCenter && (affectedSide === \"top\" || affectedSide === \"left\")) {\n    secondaryOffset = -secondaryOffset;\n  }\n\n  return secondaryOffset;\n}\n\nfunction getOffsets(layer, trigger, arrow) {\n  const left = layer.left + layer.width / 2 - trigger.left - arrow.width / 2;\n  const right = layer.right - layer.width / 2 - trigger.right + arrow.width / 2;\n  const top = layer.top + layer.height / 2 - trigger.top - arrow.height / 2;\n  const bottom = layer.bottom - layer.height / 2 - trigger.bottom + arrow.height / 2;\n  return {\n    left: left < 0 ? -left : 0,\n    right: right > 0 ? -right : 0,\n    top: top < 0 ? -top : 0,\n    bottom: bottom > 0 ? -bottom : 0\n  };\n}\n\nfunction getArrowStyle(layer, trigger, layerSide, arrow) {\n  const triggerIsBigger = triggerIsBiggerThanLayer(layerSide, layer, trigger);\n  const limitsDefault = {\n    left: {\n      min: arrow.width / 2,\n      max: layer.width - arrow.width / 2\n    },\n    top: {\n      min: arrow.height / 2,\n      max: layer.height - arrow.height / 2\n    }\n  };\n  const offsets = getOffsets(layer, trigger, arrow);\n\n  if (layerSide === \"bottom\") {\n    return {\n      bottom: \"100%\",\n      top: null,\n      left: minMax(triggerIsBigger ? layer.width / 2 + (offsets.left + offsets.right) : trigger.left + trigger.width / 2 - layer.left, limitsDefault.left),\n      right: null\n    };\n  }\n\n  if (layerSide === \"right\") {\n    return {\n      right: \"100%\",\n      left: null,\n      top: minMax(triggerIsBigger ? layer.height / 2 + (offsets.top + offsets.bottom) : trigger.top + trigger.height / 2 - layer.top, limitsDefault.top),\n      bottom: null\n    };\n  }\n\n  if (layerSide === \"top\") {\n    return {\n      top: \"100%\",\n      bottom: null,\n      left: minMax(triggerIsBigger ? layer.width / 2 + (offsets.left + offsets.right) : trigger.left + trigger.width / 2 - layer.left, limitsDefault.left),\n      right: null\n    };\n  }\n\n  return {\n    left: \"100%\",\n    right: null,\n    top: minMax(triggerIsBigger ? layer.height / 2 + (offsets.top + offsets.bottom) : trigger.top + trigger.height / 2 - layer.top, limitsDefault.top),\n    bottom: null\n  };\n}\n\nfunction getAbsoluteStyle({\n  rects,\n  scrollTop,\n  scrollLeft,\n  triggerOffset,\n  scrollOffset,\n  possibleAnchors,\n  preferedAnchor,\n  preferedX,\n  preferedY,\n  autoAdjust,\n  snapToAnchor,\n  layerDimensions\n}) {\n  // get a list of possible anchors bases on user set props\n  const possibleAnchorsByPriority = getAnchorPriority(preferedAnchor, possibleAnchors, preferedX, preferedY, rects); // on `autoAdjust` find best suitable anchor based on\n  // window's / scrollParent's position\n\n  const anchor = autoAdjust ? findBestSuitableAnchor(rects, possibleAnchorsByPriority, triggerOffset, scrollOffset, layerDimensions) : preferedAnchor; // calculate a secondary offset when `autoAdjust` is set\n  // and `snapToAnchor` is not.\n  // Basically it creates a visual effect where it seems that\n  // the layer has glued to it's parents sides\n  // Note: `offsetSecondary` is disabled when anchor is CENTER\n\n  const offsetSecondary = autoAdjust && !snapToAnchor && anchor !== \"CENTER\" ? findSecondaryOffset(anchor, possibleAnchorsByPriority, rects, triggerOffset, scrollOffset) : 0;\n  const layerStyle = getAbsolutePositions({\n    anchor,\n    rects,\n    triggerOffset,\n    offsetSecondary,\n    scrollLeft,\n    scrollTop\n  });\n  const layerRect = getLayerRectByAnchor({\n    anchor,\n    trigger: rects.trigger,\n    layer: rects.layer,\n    triggerOffset,\n    offsetSecondary,\n    layerDimensions\n  });\n\n  if (layerDimensions) {\n    layerStyle.width = layerRect.width;\n    layerStyle.height = layerRect.height;\n  }\n\n  return {\n    layerStyle,\n    layerRect,\n    anchor\n  };\n}\n\nfunction compensateScrollbars(rect, clientWidth, clientHeight) {\n  const scrollbarWidth = rect.width - clientWidth;\n  const scrollbarHeight = rect.height - clientHeight;\n  return {\n    left: rect.left,\n    top: rect.top,\n    width: rect.width - scrollbarWidth,\n    right: rect.right - scrollbarWidth,\n    height: rect.height - scrollbarHeight,\n    bottom: rect.bottom - scrollbarHeight\n  };\n}\n\nfunction getArrowRect(layerElement, arrowOffset) {\n  const arrowElement = layerElement.querySelector(\"[data-arrow]\");\n\n  if (!arrowElement) {\n    return {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      width: 0,\n      height: 0\n    };\n  }\n\n  const rect = arrowElement.getBoundingClientRect();\n  return { ...clientRectToObject(rect),\n    width: rect.width + arrowOffset * 2,\n    height: rect.height + arrowOffset * 2\n  };\n}\n\nconst defaultPlacement = {\n  autoAdjust: false,\n  snapToAnchor: false,\n  anchor: \"TOP_CENTER\",\n  layerDimensions: null,\n  possibleAnchors: POSSIBLE_ANCHORS,\n  preferX: \"RIGHT\",\n  preferY: \"BOTTOM\",\n  scrollOffset: 10,\n  triggerOffset: 0,\n  arrowOffset: 0\n};\n\nfunction getPositioning({\n  triggerRect,\n  layerElement,\n  relativeParentElement,\n  scrollParents,\n  placement = {},\n  environment,\n  fixed\n}) {\n  /**\n   * A.\n   * Calculate new layer positions\n   */\n  // sometimes ResizeObserver calls this function when all values in the\n  // trigger ClientRect are 0. Return early in that case\n  if (triggerRect.height === 0) {\n    return;\n  }\n\n  if (!layerElement) {\n    return;\n  } // gather all scroll parents (including the window ClientRect)\n  // in order to check for collisions\n\n\n  const scrollParentRects = fixed ? [getWindowClientRect(environment)] : [...scrollParents.map(parent => compensateScrollbars(parent.getBoundingClientRect(), parent.clientWidth, parent.clientHeight)), getWindowClientRect(environment)];\n  const options = {\n    autoAdjust: placement.autoAdjust || defaultPlacement.autoAdjust,\n    snapToAnchor: placement.snapToAnchor || defaultPlacement.snapToAnchor,\n    triggerOffset: isSet(placement.triggerOffset) ? placement.triggerOffset : defaultPlacement.triggerOffset,\n    scrollOffset: isSet(placement.scrollOffset) ? placement.scrollOffset : defaultPlacement.scrollOffset,\n    possibleAnchors: placement.possibleAnchors || defaultPlacement.possibleAnchors,\n    preferedAnchor: placement.anchor || defaultPlacement.anchor,\n    preferedX: placement.preferX || defaultPlacement.preferX,\n    preferedY: placement.preferY || defaultPlacement.preferY,\n    scrollLeft: relativeParentElement === document.body ? 0 : relativeParentElement.scrollLeft,\n    scrollTop: relativeParentElement === document.body ? 0 : relativeParentElement.scrollTop,\n    relativeParentElement,\n    layerDimensions: placement.layerDimensions || defaultPlacement.layerDimensions\n  };\n  const layerBox = layerElement.getBoundingClientRect(); // construct layerRect\n\n  const layer = {\n    top: layerBox.top,\n    left: layerBox.left,\n    right: layerBox.right,\n    bottom: layerBox.bottom,\n    // use `window.getComputedProperty` for width / height in order\n    // to handle things like scale-transforms\n    ...getContentBox(layerElement, environment)\n  };\n  const rects = {\n    layer,\n    relativeParent: relativeParentElement.getBoundingClientRect(),\n    scrollParents: scrollParentRects,\n    trigger: triggerRect,\n    arrow: getArrowRect(layerElement, placement.arrowOffset || defaultPlacement.arrowOffset)\n  };\n  const {\n    layerRect,\n    layerStyle,\n    anchor\n  } = getAbsoluteStyle({\n    rects,\n    ...options\n  });\n\n  if (fixed) {\n    layerStyle.top = layerRect.top;\n    layerStyle.left = layerRect.left;\n  } // determine in which side to layer will be relative to\n  // the trigger\n\n\n  const layerSide = getLayerSideByAnchor(anchor); // get optional arrow positions\n  // anchor-style is pointless when rendered anchor is CENTER\n\n  const arrowStyle = anchor === \"CENTER\" ? EMPTY_STYLE : getArrowStyle(layerRect, triggerRect, layerSide, rects.arrow);\n  const styles = {\n    layer: layerStyle,\n    arrow: arrowStyle,\n    layerSide\n  };\n  return {\n    styles,\n    layerRect\n  };\n}\n/**\n * Tracks an element and keeps it in state\n * (together with other relevant state that depends on the element)\n */\n\n\nfunction useElementRef(initialState, elementToState) {\n  const [state, setState] = useState(initialState || null);\n  const lastElement = useRef(null);\n  const setRef = useCallback(node => {\n    if (node && node !== lastElement.current) {\n      lastElement.current = node;\n\n      if (elementToState) {\n        setState(elementToState(node));\n      } else {\n        setState(node);\n      }\n    }\n  }, []);\n  return [setRef, state, lastElement];\n}\n\nfunction findScrollContainers(element, environment) {\n  const result = [];\n\n  if (!element || !environment) {\n    return result;\n  }\n\n  if (element === document.body) {\n    return result;\n  }\n\n  const {\n    overflow,\n    overflowX,\n    overflowY\n  } = environment.getComputedStyle(element);\n\n  if ([overflow, overflowX, overflowY].some(prop => prop === \"auto\" || prop === \"scroll\")) {\n    result.push(element);\n  }\n\n  return [...result, ...findScrollContainers(element.parentElement, environment)];\n}\n\nfunction useElementState(container, fixed, environment) {\n  return useElementRef({\n    triggerElement: null,\n    relativeParentElement: null,\n    scrollParents: []\n  }, useCallback(triggerElement => {\n    const scrollParents = findScrollContainers(triggerElement, environment);\n    const relativeParentElement = scrollParents[0] || document.body;\n\n    if (relativeParentElement === document.body) {\n      document.body.style.position = \"relative\";\n    } else if (process.env.NODE_ENV === \"development\" && environment) {\n      // Check if we should warn the user about 'position: relative; stuff...'\n      const containerElement = typeof container === \"function\" ? container() : container;\n      const position = environment.getComputedStyle(relativeParentElement).position;\n      const shouldWarnAboutPositionStyle = position !== \"relative\" && position !== \"absolute\" && position !== \"fixed\" && !fixed && !containerElement;\n\n      if (shouldWarnAboutPositionStyle) {\n        console.error(\"react-laag: Set the 'position' style of the nearest scroll-container to 'relative', 'absolute' or 'fixed', or set the 'fixed' prop to true. This is needed in order to position the layers properly. Currently the scroll-container is positioned: \\\"\" + position + \"\\\". Visit https://react-laag.com/docs/#position-relative for more info.\", relativeParentElement);\n      }\n    }\n\n    return {\n      triggerElement,\n      relativeParentElement,\n      scrollParents\n    };\n  }, []));\n}\n\nfunction useIsOpen(internal, external) {\n  const shouldOpenAfterMount = useRef(external);\n  const isOpen = shouldOpenAfterMount.current ? false : isSet(external) ? external : internal;\n  const rerenderAfterMount = useState(false)[1];\n  useEffect(() => {\n    if (shouldOpenAfterMount.current) {\n      shouldOpenAfterMount.current = false;\n      rerenderAfterMount(true);\n    }\n  }, []);\n  return isOpen;\n}\n\nconst ToggleLayer = ({\n  children,\n  renderLayer,\n  placement = {},\n  onStyle,\n  isOpen: isOpenExternal,\n  closeOnOutsideClick,\n  onOutsideClick,\n  onDisappear,\n  closeOnDisappear,\n  fixed,\n  container,\n  environment = typeof window !== \"undefined\" ? window : undefined,\n  ...props\n}) => {\n  /**\n   * Tracks trigger element and keeps it in state together with it's\n   * relative/absolute positioned parent\n   */\n  const [triggerRef, {\n    relativeParentElement,\n    triggerElement,\n    scrollParents\n  }, normalTriggerRef] = useElementState(container, fixed, environment);\n  const {\n    styles,\n    setStyles,\n    lastStyles,\n    resetLastStyles\n  } = useStyleState(placement.anchor || defaultPlacement.anchor);\n  const layerRef = useRef(null);\n  const [isOpenInternal, setOpenInternal] = useState(false);\n  const isOpen = useIsOpen(isOpenInternal, isOpenExternal);\n  const handlePositioning = useCallback(() => {\n    if (!triggerElement) {\n      throw new Error(\"Could not find a valid reference of the trigger element. See https://www.react-laag.com/docs/togglelayer/#children for more info.\");\n    }\n\n    const triggerRect = triggerElement.getBoundingClientRect();\n    const result = getPositioning({\n      triggerRect,\n      layerElement: layerRef.current,\n      placement,\n      relativeParentElement,\n      scrollParents,\n      fixed,\n      environment\n    });\n\n    if (!result) {\n      return;\n    }\n\n    const {\n      layerRect,\n      styles\n    } = result; // only update styles when necessary\n\n    if (shouldUpdateStyles(lastStyles.current, styles)) {\n      // is parent in control of styles? (onStyle)\n      if (isSet(onStyle)) {\n        lastStyles.current = styles;\n        onStyle(styles.layer, styles.arrow, styles.layerSide);\n      } // ... otherwise set styles internally\n      else {\n          setStyles(styles);\n        }\n    }\n    /**\n     * B.\n     * Manage disappearance\n     */\n\n\n    const hasOnDisappear = isSet(onDisappear);\n    const shouldCloseOnDisappear = closeOnDisappear && !isSet(isOpenExternal); // Should we respond to the layer's partial or full disappearance?\n    // (trigger's disappearance when `fixed` props is set)\n\n    if (hasOnDisappear || shouldCloseOnDisappear) {\n      const allScrollParents = [...scrollParents.map(parent => parent.getBoundingClientRect()), getWindowClientRect(environment)];\n      const partial = !doesEntireLayerFitWithinScrollParents(fixed ? triggerRect : layerRect, allScrollParents);\n      const full = isLayerCompletelyInvisible(fixed ? triggerRect : layerRect, allScrollParents); // if parent is interested in diseappearance...\n\n      if (hasOnDisappear) {\n        if (partial || full) {\n          onDisappear(full ? \"full\" : \"partial\");\n        }\n      } // ... else close accordingly\n      else {\n          if (closeOnDisappear === \"partial\" && partial) {\n            setOpenInternal(false);\n          }\n\n          if (closeOnDisappear === \"full\" && full) {\n            setOpenInternal(false);\n          }\n        }\n    }\n  }, [relativeParentElement, isOpen, triggerElement, scrollParents, fixed, placement]); // call `handlePositioning` when the layer's / trigger's\n  // height and / or width changes\n\n  const resizeObserver = useTrackElementResize(props.ResizeObserver, layerRef, triggerElement, isOpen, handlePositioning, environment); // On every render, check a few things...\n\n  useIsomorphicLayoutEffect(() => {\n    /**\n     * A.\n     * Ignore when render is caused by internal style change\n     */\n    const styleIsSetInterally = !isSet(onStyle);\n    const effectBecauseOfInternalStyleChange = styles !== lastStyles.current;\n\n    if (effectBecauseOfInternalStyleChange && styleIsSetInterally) {\n      lastStyles.current = styles;\n      return;\n    } // reset lastStyles-ref when closed\n\n\n    if (!isOpen) {\n      resetLastStyles();\n      return;\n    }\n    /**\n     * B.\n     * Prepare to calculate new layer style\n     */\n    // if (!triggerElement) {\n    //   throw new Error(\"Please provide a valid ref to the trigger element\");\n    // } else if (!layerRef.current) {\n    //   throw new Error(\"Please provide a valid ref to the layer element\");\n    // }\n\n\n    handlePositioning();\n  }); // calculate new layer style when window size changes\n\n  useOnWindowResize(handlePositioning, environment, isOpen); // calculate new layer style when user scrolls\n\n  useOnScroll(scrollParents, handlePositioning, environment, isOpen);\n  const outsideClickRefs = useRef(new Set([layerRef, normalTriggerRef])); // handle clicks that are not originated from the trigger / layer\n  // element\n\n  useOutsideClick(outsideClickRefs, useCallback(() => {\n    if (!isOpen) {\n      return;\n    }\n\n    if (onOutsideClick) {\n      onOutsideClick();\n    }\n\n    if (closeOnOutsideClick && !isSet(isOpenExternal)) {\n      setOpenInternal(false);\n    }\n  }, [isOpen, setOpenInternal, isOpenExternal, onOutsideClick]));\n  const containerElement = typeof container === \"function\" ? container() : container;\n  return /*#__PURE__*/createElement(Fragment, null, children({\n    isOpen,\n    close: () => {\n      /* istanbul ignore next */\n      if (isSet(isOpenExternal)) {\n        throw new Error(\"You cannot call `close()` while using the `isOpen` prop\");\n      }\n      /* istanbul ignore next */\n\n\n      setOpenInternal(false);\n    },\n    open: () => {\n      /* istanbul ignore next */\n      if (isSet(isOpenExternal)) {\n        throw new Error(\"You cannot call `open()` while using the `isOpen` prop\");\n      }\n      /* istanbul ignore next */\n\n\n      setOpenInternal(true);\n    },\n    toggle: () => {\n      /* istanbul ignore next */\n      if (isSet(isOpenExternal)) {\n        throw new Error(\"You cannot call `toggle()` while using the `isOpen` prop\");\n      }\n\n      setOpenInternal(!isOpenInternal);\n    },\n    triggerRef,\n    layerSide: isOpen ? styles.layerSide : null\n  }), relativeParentElement && /*#__PURE__*/createElement(OutsideClickGroupProvider, {\n    refs: outsideClickRefs\n  }, /*#__PURE__*/createPortal(renderLayer({\n    layerProps: {\n      ref: element => {\n        if (element) {\n          // observe the layer for resizing\n          // it's ok to observe the same element multiple times\n          // since multiple observes of same element are ignored\n          resizeObserver.observe(element);\n        }\n\n        layerRef.current = element;\n      },\n      style: { ...(isSet(onStyle) ? EMPTY_STYLE : styles.layer),\n        position: fixed ? \"fixed\" : \"absolute\",\n        willChange: \"top, bottom, left, right, width, height\"\n      }\n    },\n    arrowStyle: { ...(isSet(onStyle) ? EMPTY_STYLE : styles.arrow),\n      position: \"absolute\",\n      willChange: \"top, bottom, left, right\"\n    },\n    isOpen,\n    layerSide: styles.layerSide,\n    triggerRect: triggerElement ? triggerElement.getBoundingClientRect() : null,\n    close: () => {\n      /* istanbul ignore next */\n      if (isSet(isOpenExternal)) {\n        throw new Error(\"You cannot call `close()` while using the `isOpen` prop\");\n      }\n      /* istanbul ignore next */\n\n\n      setOpenInternal(false);\n    }\n  }), containerElement || relativeParentElement)));\n};\n\nfunction getWidthBasedOnAngle(angle, size) {\n  return Math.tan(angle * (Math.PI / 180)) * size;\n}\n\nfunction getViewBox(sizeA, sizeB, layerSide, borderWidth) {\n  switch (layerSide) {\n    case \"bottom\":\n      return \"0 \" + -borderWidth + \" \" + sizeB + \" \" + sizeA;\n\n    case \"top\":\n      return \"0 0 \" + sizeB + \" \" + (sizeA + borderWidth);\n\n    case \"right\":\n      return -borderWidth + \" 0 \" + sizeA + \" \" + sizeB;\n\n    case \"left\":\n      return \"0 0 \" + (sizeA + borderWidth) + \" \" + sizeB;\n  }\n\n  return \"\";\n}\n\nfunction getTrianglePath({\n  sizeA,\n  sizeB,\n  layerSide,\n  roundness,\n  angle\n}) {\n  const relativeRoundness = roundness / 10 * sizeA * 2;\n  const A = layerSide === \"bottom\" ? \"0 \" + sizeA : layerSide === \"top\" ? \"0 0\" : layerSide === \"right\" ? sizeA + \" \" + sizeB : \"0 \" + sizeB;\n  const B = (layerSide === \"bottom\" || layerSide === \"top\" ? \"H\" : \"V\") + \" \" + (layerSide === \"bottom\" || layerSide === \"top\" ? sizeB : 0);\n  const cPoint = sizeB / 2;\n  const c1A = sizeB / 2 + getWidthBasedOnAngle(angle, sizeA / 8);\n  const c1B = sizeA / 8;\n  const C = layerSide === \"bottom\" ? \"C \" + c1A + \" \" + c1B + \" \" + (cPoint + relativeRoundness) + \" 0 \" + cPoint + \" 0\" : layerSide === \"top\" ? \"C \" + c1A + \" \" + (sizeA - c1B) + \" \" + (cPoint + relativeRoundness) + \" \" + sizeA + \" \" + cPoint + \" \" + sizeA : layerSide === \"right\" ? \"C \" + c1B + \" \" + (sizeB - c1A) + \" 0 \" + (cPoint - relativeRoundness) + \" 0 \" + cPoint : \"C \" + (sizeA - c1B) + \" \" + (sizeB - c1A) + \" \" + sizeA + \" \" + (cPoint - relativeRoundness) + \" \" + sizeA + \" \" + cPoint;\n  const d1A = sizeB / 2 - getWidthBasedOnAngle(angle, sizeA / 8);\n  const d1B = sizeA / 8;\n  const D = layerSide === \"bottom\" ? \"C \" + (cPoint - relativeRoundness) + \" 0 \" + d1A + \" \" + d1B + \" \" + A : layerSide === \"top\" ? \"C \" + (cPoint - relativeRoundness) + \" \" + sizeA + \" \" + d1A + \" \" + (sizeA - d1B) + \" \" + A : layerSide === \"right\" ? \"C 0 \" + (cPoint + relativeRoundness) + \" \" + d1B + \" \" + (sizeB - d1A) + \" \" + A : \"C\" + sizeA + \" \" + (cPoint + relativeRoundness) + \" \" + (sizeA - d1B) + \" \" + (sizeB - d1A) + \" \" + A;\n  return \"M \" + A + \" \" + B + \" \" + C + \" \" + D;\n}\n\nfunction getBorderMaskPath({\n  sizeA,\n  sizeB,\n  borderWidth,\n  layerSide,\n  angle\n}) {\n  const borderOffset = getWidthBasedOnAngle(angle, borderWidth);\n\n  if (layerSide === \"bottom\" || layerSide === \"top\") {\n    return \"M \" + borderWidth + \" \" + (layerSide === \"bottom\" ? sizeA : 0) + \" H \" + (sizeB - borderWidth) + \" L \" + (sizeB - borderWidth - borderOffset) + \" \" + (layerSide === \"bottom\" ? sizeA - borderWidth : borderWidth) + \" H \" + (borderOffset + borderWidth) + \" Z\";\n  }\n\n  return \"M \" + (layerSide === \"right\" ? sizeA : 0) + \" \" + borderWidth + \" V \" + (sizeB - borderWidth) + \" L \" + (layerSide === \"right\" ? sizeA - borderWidth : borderWidth) + \" \" + (sizeB - borderWidth - borderOffset) + \" V \" + (borderOffset + borderWidth) + \" Z\";\n}\n\nconst Arrow = ({\n  size = 8,\n  angle = 45,\n  borderWidth = 0,\n  borderColor = \"black\",\n  roundness = 0,\n  backgroundColor = \"white\",\n  layerSide = \"top\",\n  style = {}\n}) => {\n  if (layerSide === \"center\") {\n    return null;\n  }\n\n  const sizeA = size;\n  const sizeB = getWidthBasedOnAngle(angle, size) * 2;\n  return /*#__PURE__*/createElement(\"svg\", {\n    style: { ...style,\n      transform: \"translate\" + (layerSide === \"left\" || layerSide === \"right\" ? \"Y\" : \"X\") + \"(-50%)\"\n    },\n    \"data-arrow\": \"true\",\n    width: layerSide === \"left\" || layerSide === \"right\" ? sizeA : sizeB,\n    viewBox: getViewBox(sizeA, sizeB, layerSide, borderWidth)\n  }, /*#__PURE__*/createElement(\"path\", {\n    fill: backgroundColor,\n    strokeWidth: borderWidth,\n    stroke: borderColor,\n    d: getTrianglePath({\n      angle,\n      layerSide,\n      roundness,\n      sizeA,\n      sizeB\n    })\n  }), /*#__PURE__*/createElement(\"path\", {\n    fill: backgroundColor,\n    d: getBorderMaskPath({\n      sizeA,\n      sizeB,\n      angle,\n      borderWidth,\n      layerSide\n    })\n  }));\n};\n\nfunction useToggleLayer(renderLayer, {\n  onStyle,\n  closeOnOutsideClick,\n  closeOnDisappear,\n  fixed,\n  container,\n  placement = {},\n  environment = typeof window !== \"undefined\" ? window : undefined,\n  ...props\n} = {}) {\n  /**\n   * Tracks trigger element and keeps it in state together with it's\n   * relative/absolute positioned parent\n   */\n  const [setTargetRef, {\n    relativeParentElement,\n    triggerElement: targetElement,\n    scrollParents\n  }, normalTriggerRef] = useElementState(container, fixed, environment);\n  const {\n    styles,\n    setStyles,\n    lastStyles,\n    resetLastStyles\n  } = useStyleState(placement.anchor || defaultPlacement.anchor);\n  const layerRef = useRef(null);\n  const triggerRectRef = useRef(null);\n\n  function getTriggerRect() {\n    return typeof triggerRectRef.current === \"function\" ? triggerRectRef.current() : triggerRectRef.current;\n  }\n\n  const [isOpen, setOpen] = useState(false);\n\n  function close() {\n    triggerRectRef.current = null;\n    setOpen(false);\n  }\n\n  const handlePositioning = useCallback(() => {\n    const triggerRect = getTriggerRect();\n\n    if (!triggerRect) {\n      return;\n    }\n\n    const result = getPositioning({\n      triggerRect,\n      layerElement: layerRef.current,\n      placement,\n      relativeParentElement,\n      scrollParents,\n      fixed,\n      environment\n    });\n\n    if (!result) {\n      return;\n    }\n\n    const {\n      layerRect,\n      styles\n    } = result; // only update styles when necessary\n\n    if (shouldUpdateStyles(lastStyles.current, styles)) {\n      // is parent in control of styles? (onStyle)\n      if (isSet(onStyle)) {\n        lastStyles.current = styles;\n        onStyle(styles.layer, styles.arrow, styles.layerSide);\n      } // ... otherwise set styles internally\n      else {\n          setStyles(styles);\n        }\n    }\n    /**\n     * B.\n     * Manage disappearance\n     */\n    // Should we respond to the layer's partial or full disappearance?\n    // (trigger's disappearance when `fixed` props is set)\n\n\n    if (closeOnDisappear) {\n      const allScrollParents = [...scrollParents.map(parent => parent.getBoundingClientRect()), getWindowClientRect(environment)];\n      const partial = !doesEntireLayerFitWithinScrollParents(fixed ? triggerRect : layerRect, allScrollParents);\n      const full = isLayerCompletelyInvisible(fixed ? triggerRect : layerRect, allScrollParents);\n\n      if (closeOnDisappear === \"partial\" && partial) {\n        close();\n      }\n\n      if (closeOnDisappear === \"full\" && full) {\n        close();\n      }\n    }\n  }, [relativeParentElement, isOpen, targetElement, scrollParents, fixed, placement]); // call `handlePositioning` when the layer's / targets's\n  // height and / or width changes\n\n  const resizeObserver = useTrackElementResize(props.ResizeObserver, layerRef, targetElement, isOpen, handlePositioning, environment); // On every render, check a few things...\n\n  useIsomorphicLayoutEffect(() => {\n    /**\n     * A.\n     * Ignore when render is caused by internal style change\n     */\n    const styleIsSetInterally = !isSet(onStyle);\n    const effectBecauseOfInternalStyleChange = styles !== lastStyles.current;\n\n    if (effectBecauseOfInternalStyleChange && styleIsSetInterally) {\n      lastStyles.current = styles;\n      return;\n    } // reset `lastStyles` when closed\n\n\n    if (!isOpen) {\n      resetLastStyles();\n      return;\n    }\n    /**\n     * B.\n     * Prepare to calculate new layer style\n     */\n\n\n    handlePositioning();\n  }); // calculate new layer style when window size changes\n\n  useOnWindowResize(handlePositioning, environment, isOpen); // calculate new layer style when user scrolls\n\n  useOnScroll(scrollParents, handlePositioning, environment, isOpen);\n  const outsideClickRefs = useRef(new Set([layerRef, normalTriggerRef])); // handle clicks that are not originated from the trigger / layer\n  // element\n\n  useOutsideClick(outsideClickRefs, useCallback(() => {\n    if (!isOpen) {\n      return;\n    }\n\n    if (closeOnOutsideClick) {\n      close();\n    }\n  }, [isOpen, setOpen, closeOnOutsideClick]));\n  const containerElement = typeof container === \"function\" ? container() : container;\n\n  function open({\n    clientRect,\n    target\n  }) {\n    triggerRectRef.current = clientRect;\n\n    if (isOpen && target === targetElement) {\n      handlePositioning();\n    } else {\n      setTargetRef(target);\n      setOpen(true);\n    }\n  }\n\n  const payload = {\n    isOpen,\n    close,\n    open,\n    openFromContextMenuEvent: evt => {\n      evt.preventDefault();\n      const target = evt.target;\n      const clientRect = {\n        top: evt.clientY,\n        left: evt.clientX,\n        bottom: evt.clientY + 1,\n        right: evt.clientX + 1,\n        width: 1,\n        height: 1\n      };\n      open({\n        clientRect,\n        target\n      });\n    },\n    openFromMouseEvent: evt => {\n      const currentTarget = evt.currentTarget;\n\n      if (!currentTarget || !currentTarget.getBoundingClientRect) {\n        return;\n      }\n\n      const clientRect = () => currentTarget.getBoundingClientRect();\n\n      open({\n        clientRect,\n        target: currentTarget\n      });\n    },\n    openFromRef: ref => {\n      if (!ref.current) {\n        console.error(\"Error inside useTooltip(): Expected a valid ref to a trigger element, but got \" + typeof ref.current);\n        return;\n      }\n\n      open({\n        target: ref.current,\n        clientRect: ref.current.getBoundingClientRect()\n      });\n    },\n    openFromSelection: selection => {\n      if (!selection.anchorNode || selection.isCollapsed) {\n        return;\n      }\n\n      const element = getElementFromAnchorNode(selection.anchorNode);\n\n      if (!element) {\n        return;\n      }\n\n      const range = selection.getRangeAt(0);\n      open({\n        clientRect: () => range.getBoundingClientRect(),\n        target: element\n      });\n    },\n    layerSide: isOpen ? styles.layerSide : null\n  };\n  const element = relativeParentElement && /*#__PURE__*/createPortal(renderLayer({\n    layerProps: {\n      ref: element => {\n        if (element) {\n          // observe the layer for resizing\n          // it's ok to observe the same element multiple times\n          // since multiple observes of same element are ignored\n          resizeObserver.observe(element);\n        }\n\n        layerRef.current = element;\n      },\n      style: { ...(isSet(onStyle) ? EMPTY_STYLE : styles.layer),\n        position: fixed ? \"fixed\" : \"absolute\",\n        willChange: \"top, bottom, left, right, width, height\"\n      }\n    },\n    arrowStyle: { ...(isSet(onStyle) ? EMPTY_STYLE : styles.arrow),\n      position: \"absolute\",\n      willChange: \"top, bottom, left, right\"\n    },\n    isOpen,\n    layerSide: styles.layerSide,\n    triggerRect: getTriggerRect(),\n    close: () => {\n      close();\n    }\n  }), containerElement || relativeParentElement);\n  return [/*#__PURE__*/createElement(OutsideClickGroupProvider, {\n    refs: outsideClickRefs\n  }, element), payload];\n}\n\nfunction useHover(config) {\n  const {\n    delayEnter = 0,\n    delayLeave = 0,\n    hideOnScroll = true,\n    onShow,\n    onHide\n  } = config || {};\n  const [show, setShow] = useState(false);\n  const timeoutRef = useRef(null);\n  const timeoutState = useRef(null);\n  const hasTouchMoved = useRef(false);\n\n  function handleShowHide(show) {\n    if (show) {\n      if (onShow) {\n        onShow();\n      }\n\n      setShow(true);\n      return;\n    }\n\n    if (onHide) {\n      onHide();\n    }\n\n    setShow(false);\n  }\n\n  function onMouseEnter() {\n    // if was leaving, stop leaving\n    if (timeoutState.current === \"leaving\" && timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = null;\n      timeoutState.current = null;\n    }\n\n    if (show) {\n      return;\n    }\n\n    timeoutState.current = \"entering\";\n    timeoutRef.current = setTimeout(() => {\n      handleShowHide(true);\n      timeoutRef.current = null;\n      timeoutState.current = null;\n    }, delayEnter);\n  }\n\n  function onMouseLeave() {\n    // if was waiting for entering,\n    // clear timeout\n    if (timeoutState.current === \"entering\" && timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = null;\n    }\n\n    if (!show) {\n      return;\n    }\n\n    timeoutState.current = \"leaving\";\n    timeoutRef.current = setTimeout(() => {\n      handleShowHide(false);\n      timeoutRef.current = null;\n    }, delayLeave);\n  } // make sure to clear timeout on unmount\n\n\n  useEffect(() => {\n    const to = timeoutRef.current;\n\n    function clear() {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n        timeoutRef.current = null;\n      }\n    }\n\n    function onScroll() {\n      if (show && hideOnScroll) {\n        clear();\n        handleShowHide(false);\n      }\n    }\n\n    function onTouchEnd() {\n      if (show) {\n        clear();\n        handleShowHide(false);\n      }\n    }\n\n    window.addEventListener(\"scroll\", onScroll, true);\n    window.addEventListener(\"touchend\", onTouchEnd, true);\n    return () => {\n      window.removeEventListener(\"scroll\", onScroll, true);\n      window.removeEventListener(\"touchend\", onTouchEnd, true);\n\n      if (to) {\n        clearTimeout(to);\n      }\n    };\n  }, [show, hideOnScroll]);\n  const hoverProps = {\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart: () => {\n      hasTouchMoved.current = false;\n    },\n    onTouchMove: () => {\n      hasTouchMoved.current = true;\n    },\n    onTouchEnd: () => {\n      if (!hasTouchMoved.current && !show) {\n        handleShowHide(true);\n      }\n\n      hasTouchMoved.current = false;\n    }\n  }; // @ts-ignore\n\n  if (onShow) {\n    return hoverProps;\n  }\n\n  return [show, hoverProps];\n}\n\nfunction useBreakpoint(maxPixels) {\n  const [match, setMatch] = useState(typeof window !== \"undefined\" ? window.matchMedia(\"(max-width: \" + maxPixels + \"px)\").matches : false);\n  useEffect(() => {\n    const matcher = window.matchMedia(\"(max-width: \" + maxPixels + \"px)\");\n\n    function onMatch(evt) {\n      setMatch(evt.matches);\n    }\n\n    matcher.addListener(onMatch);\n    return () => {\n      matcher.removeListener(onMatch);\n    };\n  }, [maxPixels]);\n  return match;\n}\n\nfunction Transition({\n  isOpen: isOpenExternal,\n  children\n}) {\n  const [state, setState] = useState({\n    isOpenInternal: isOpenExternal,\n    isLeaving: false\n  });\n  const didMount = useRef(false);\n  useEffect(() => {\n    if (isOpenExternal) {\n      setState({\n        isOpenInternal: true,\n        isLeaving: false\n      });\n    } else if (didMount.current) {\n      setState({\n        isOpenInternal: false,\n        isLeaving: true\n      });\n    }\n  }, [isOpenExternal, setState]);\n  useEffect(() => {\n    didMount.current = true;\n  }, []);\n\n  if (!isOpenExternal && !state.isOpenInternal && !state.isLeaving) {\n    return null;\n  }\n\n  return children(state.isOpenInternal, () => {\n    if (!state.isOpenInternal) {\n      setState(s => ({ ...s,\n        isLeaving: false\n      }));\n    }\n  }, state.isLeaving);\n}\n\nfunction useTooltip(renderLayer, {\n  delayEnter,\n  delayLeave,\n  hideOnScroll,\n  ...rest\n} = {}) {\n  const triggerRef = useRef();\n  const [element, {\n    openFromRef,\n    close\n  }] = useToggleLayer(renderLayer, rest);\n  const hoverProps = useHover({\n    delayEnter,\n    delayLeave,\n    hideOnScroll,\n    onShow: () => openFromRef(triggerRef),\n    onHide: close\n  });\n  const triggerProps = {\n    ref: triggerRef,\n    ...hoverProps\n  };\n  return [element, triggerProps];\n}\n\nexport { Arrow, ToggleLayer, Transition, Anchor as anchor, useBreakpoint, useHover, useToggleLayer, useTooltip };","map":{"version":3,"sources":["../src/ToggleLayer/useEvent.tsx","../src/ToggleLayer/useOutsideClick.tsx","../src/ToggleLayer/useOnScroll.tsx","../src/ToggleLayer/useOnWindowResize.tsx","../src/ToggleLayer/useIsomorphicLayoutEffect.tsx","../src/ToggleLayer/useTrackElementResize.tsx","../src/ToggleLayer/util.tsx","../src/ToggleLayer/useStyleState.tsx","../src/ToggleLayer/anchor.tsx","../src/ToggleLayer/style/getAbsolutePositions.tsx","../src/ToggleLayer/rect/getLayerRectByAnchor.tsx","../src/ToggleLayer/rect/index.tsx","../src/ToggleLayer/style/getSuitableAnchor.tsx","../src/ToggleLayer/style/getSecondaryOffset.tsx","../src/ToggleLayer/style/getArrowStyle.tsx","../src/ToggleLayer/style/index.tsx","../src/ToggleLayer/getPositioning.tsx","../src/ToggleLayer/useElementRef.tsx","../src/ToggleLayer/findScrollContainers.tsx","../src/ToggleLayer/useElementState.tsx","../src/ToggleLayer/useIsOpen.tsx","../src/ToggleLayer/ToggleLayer.tsx","../src/ToggleLayer/Arrow.tsx","../src/ToggleLayer/useToggleLayer.tsx","../src/useHover.tsx","../src/useBreakpoint.tsx","../src/Transition.tsx","../src/useTooltip.tsx"],"names":["enabled","capture","cb","el","Array","ev","e","event","OutsideClickContext","React","parent","hasChildren","i","child","isChildOf","children","isPartOfGroup","layerRef","refs","registerRefToGroup","useRegisterGroup","useEvent","evt","ref","callback","trackScroll","memoElements","trackResize","useIsomorphicLayoutEffect","callbackRef","ResizeObserver","injectedResizeObserver","environment","resizeObserver","EMPTY_STYLE","value","aKeys","Object","bKeys","Math","key","a","b","areStylesTheSame","prev","next","top","left","right","bottom","height","width","convertFloat","parseFloat","paddingBottom","boxSizing","total","clientRect","currentElement","max","layer","arrow","layerSide","anchor","lastStyles","resetLastStyles","Anchor","BOTTOM_LEFT","BOTTOM_RIGHT","BOTTOM_CENTER","TOP_LEFT","TOP_CENTER","TOP_RIGHT","LEFT_BOTTOM","LEFT_CENTER","LEFT_TOP","RIGHT_BOTTOM","RIGHT_CENTER","RIGHT_TOP","POSSIBLE_ANCHORS","primary","prefferedIsY","primaryIsY","index","x","triggerHasBiggerHeight","rects","triggerHasBiggerWidth","preferedSecondary","preferedPrimary","anchorOptions","secondary","splitAnchor","preferedAnchor","anchors","getPrimaryByIndex","getSecondaryByIndex","possibleAnchors","prop","size","scroll","triggerOffset","minMax","getLimits","topBase","leftBase","min","primaryDirection","getCenter","scrollTop","getPrimaryDirection","getPrimaryStyle","getSecondaryStyle","dimensions","layerDimensions","getLayerSideByAnchor","clientRectToObject","propMap","TOP","side1","side2","factor","BOTTOM","LEFT","RIGHT","trigger","offsetSecondary","scrollOffset","layerRect","fixLayerDimensions","primaryRect","secondaryRect","getPrimaryRect","getSecondaryRect","result","ALL_OFFSET_SIDES","parents","getLayerOffsetsToParent","parentOffsets","getLayerOffsetsToParents","offsets","side","parentOffsetsCombined","reduceOffsets","affectedProperty","rect","surfaces","getVisibleLayerSurface","getLayerRectByAnchor","doesEntireLayerFitWithinScrollParents","primarySize","secondarySize","surface","getVisibleLayerSurfaceWithinScrollParent","offsetSurface","getOffsetSurface","square","doesAnchorFitWithinScrollParents","findAnchorByLayerSurface","getLayerOffsetsToScrollParentsByAnchor","sides","getNegativeOffsetSides","secondaryAnchorOptions","getSecondaryAnchorOptionsByPrimary","currentAnchorHasHighestPriority","currentAnchorFits","firstAnchorThatDoesNotFit","affectedSide","getSecondaryOffsetSide","currentOffsets","secondaryOffset","triggerIsBigger","triggerIsBiggerThanLayer","isCenter","isLeft","isTop","limitsDefault","getOffsets","possibleAnchorsByPriority","getAnchorPriority","autoAdjust","getSuitableAnchor","getSecondaryOffset","layerStyle","getAbsolutePositions","scrollbarWidth","scrollbarHeight","arrowElement","layerElement","arrowOffset","defaultPlacement","snapToAnchor","preferX","preferY","placement","fixed","triggerRect","scrollParentRects","getWindowClientRect","scrollParents","compensateScrollbars","options","isSet","preferedX","preferedY","scrollLeft","relativeParentElement","document","layerBox","getContentBox","relativeParent","getArrowRect","getAbsoluteStyle","arrowStyle","getArrowStyle","styles","initialState","lastElement","setRef","node","setState","elementToState","element","overflowY","findScrollContainers","useElementRef","triggerElement","process","containerElement","container","position","shouldWarnAboutPositionStyle","console","shouldOpenAfterMount","isOpen","rerenderAfterMount","ToggleLayer","props","useElementState","useStyleState","useIsOpen","handlePositioning","getPositioning","shouldUpdateStyles","onStyle","setStyles","hasOnDisappear","shouldCloseOnDisappear","closeOnDisappear","allScrollParents","partial","full","isLayerCompletelyInvisible","onDisappear","setOpenInternal","useTrackElementResize","styleIsSetInterally","effectBecauseOfInternalStyleChange","useOnWindowResize","useOnScroll","outsideClickRefs","useOutsideClick","onOutsideClick","closeOnOutsideClick","close","open","toggle","createPortal","renderLayer","layerProps","style","willChange","angle","sizeA","relativeRoundness","roundness","A","B","cPoint","sizeB","c1A","getWidthBasedOnAngle","c1B","C","d1A","d1B","D","borderOffset","Arrow","borderWidth","borderColor","backgroundColor","transform","getViewBox","getTrianglePath","getBorderMaskPath","triggerRectRef","setOpen","getTriggerRect","target","setTargetRef","payload","openFromContextMenuEvent","openFromMouseEvent","currentTarget","openFromRef","openFromSelection","selection","getElementFromAnchorNode","range","delayEnter","delayLeave","hideOnScroll","onHide","config","timeoutRef","timeoutState","hasTouchMoved","onShow","setShow","clearTimeout","setTimeout","handleShowHide","to","show","clear","window","hoverProps","onTouchStart","onTouchMove","onTouchEnd","matcher","setMatch","isOpenInternal","isLeaving","didMount","state","s","rest","triggerRef","useToggleLayer","useHover","triggerProps"],"mappings":"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","sourcesContent":["import * as React from \"react\";\n\ntype EventListenable = {\n  addEventListener: any;\n  removeEventListener: any;\n};\n\nexport default function useEvent<T extends EventListener>(\n  element: EventListenable | EventListenable[] | null,\n  event: string | string[],\n  callback: T,\n  enabled = true,\n  capture = false\n) {\n  return React.useEffect(() => {\n    if (!enabled || !element) {\n      return;\n    }\n\n    const cb = callback;\n\n    const el = Array.isArray(element) ? element : [element];\n    const ev = Array.isArray(event) ? event : [event];\n\n    el.forEach(e => {\n      ev.forEach(event => {\n        e.addEventListener(event as any, cb, capture);\n      });\n    });\n\n    return () => {\n      el.forEach(e => {\n        ev.forEach(event => {\n          e.removeEventListener(event as any, cb, capture);\n        });\n      });\n    };\n  }, [callback, element, enabled, event, capture]);\n}\n","import React from \"react\";\n\nimport useEvent from \"./useEvent\";\n\nexport const OutsideClickContext = React.createContext({} as (\n  layer: React.RefObject<HTMLElement | null | undefined>\n) => void);\n\nfunction isChildOf(parent: HTMLElement, target: HTMLElement) {\n  if (parent === target) {\n    return true;\n  }\n\n  const hasChildren = parent.children && parent.children.length > 0;\n\n  if (hasChildren) {\n    // tslint:disable-next-line\n    for (let i = 0; i < parent.children.length; i++) {\n      const child = parent.children[i];\n      if (child && isChildOf(child as HTMLElement, target)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\ntype OutsideClickGroupProviderProps = {\n  refs: React.MutableRefObject<\n    Set<React.RefObject<HTMLElement | null | undefined>>\n  >;\n  children: any;\n};\n\nexport function OutsideClickGroupProvider({\n  refs,\n  children\n}: OutsideClickGroupProviderProps) {\n  const isPartOfGroup =\n    typeof React.useContext(OutsideClickContext) === \"function\";\n\n  if (isPartOfGroup) {\n    return children;\n  }\n\n  return (\n    <OutsideClickContext.Provider\n      value={React.useCallback(layerRef => {\n        refs.current.add(layerRef);\n      }, [])}\n    >\n      {children}\n    </OutsideClickContext.Provider>\n  );\n}\n\nfunction useRegisterGroup(\n  refs: React.MutableRefObject<\n    Set<React.RefObject<HTMLElement | null | undefined>>\n  >\n) {\n  const registerRefToGroup = React.useContext(OutsideClickContext);\n\n  React.useEffect(() => {\n    const [layerRef] = refs.current.values();\n\n    if (typeof registerRefToGroup === \"function\" && layerRef) {\n      registerRefToGroup(layerRef);\n    }\n  }, [registerRefToGroup, refs]);\n}\n\nfunction useOutsideClick(\n  refs: React.MutableRefObject<\n    Set<React.RefObject<HTMLElement | null | undefined>>\n  >,\n  callback: () => void\n) {\n  const [events] = React.useState([\"click\"]);\n\n  useRegisterGroup(refs);\n\n  useEvent(\n    typeof document !== \"undefined\" ? document : null,\n    events,\n    React.useCallback(\n      (evt: any) => {\n        for (const ref of refs.current) {\n          if (!ref.current) {\n            continue;\n          }\n\n          if (isChildOf(ref.current, evt.target as HTMLElement)) {\n            return;\n          }\n        }\n\n        callback();\n      },\n      [callback]\n    ),\n    true,\n\n    true\n  );\n}\n\nexport default useOutsideClick;\n","import * as React from \"react\";\n\nimport useEvent from \"./useEvent\";\n\nfunction useOnScroll(\n  elements: HTMLElement[],\n  onScroll: (event: Event) => void,\n  environment?: Window,\n  trackScroll = true\n) {\n  const memoElements = React.useMemo(\n    () =>\n      typeof environment !== \"undefined\" ? [environment, ...elements] : [],\n    [elements]\n  );\n  useEvent(memoElements, \"scroll\", onScroll, trackScroll);\n}\n\nexport default useOnScroll;\n","import useEvent from \"./useEvent\";\n\nfunction useOnWindowResize(\n  onResize: (event: Event) => void,\n  environment?: Window,\n  trackResize = true\n) {\n  useEvent(\n    typeof environment !== \"undefined\" ? environment : null,\n    \"resize\",\n    onResize,\n    trackResize\n  );\n}\n\nexport default useOnWindowResize;\n","import * as React from \"react\";\nconst useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\n\nexport default useIsomorphicLayoutEffect;\n","import * as React from \"react\";\nimport useIsomorphicLayoutEffect from \"./useIsomorphicLayoutEffect\";\n\nexport default function useTrackElementResize(\n  injectedResizeObserver: any,\n  layerRef: React.RefObject<HTMLElement>,\n  triggerElement: HTMLElement | null,\n  isOpen: boolean,\n  callback: () => void,\n  environment?: Window\n) {\n  const callbackRef = React.useRef(callback);\n  callbackRef.current = callback;\n\n  const ResizeObserver =\n    injectedResizeObserver ||\n    (typeof environment === \"undefined\"\n      ? class ResizeObserver {}\n      : (environment as any).ResizeObserver);\n\n  if (!ResizeObserver) {\n    throw new Error(\n      \"This browser does not support `ResizeObserver` out of the box. Please provide a polyfill as a prop.\"\n    );\n  }\n\n  const resizeObserver = React.useRef(\n    new ResizeObserver(() => {\n      if (layerRef.current) {\n        callbackRef.current();\n      }\n    })\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    if (isOpen) {\n      if (triggerElement) {\n        resizeObserver.current.observe(triggerElement);\n      }\n    } else {\n      if (triggerElement) {\n        resizeObserver.current.unobserve(triggerElement);\n      }\n      if (layerRef.current) {\n        resizeObserver.current.unobserve(layerRef.current);\n      }\n    }\n  }, [isOpen, triggerElement]);\n\n  React.useEffect(() => {\n    return () => {\n      resizeObserver.current.disconnect();\n    };\n  }, []);\n\n  return resizeObserver.current;\n}\n","import { ResultingStyles } from \"./types\";\n\nexport const EMPTY_STYLE: React.CSSProperties = {};\n\nexport function isSet<T>(value: T) {\n  return value !== undefined && value !== null;\n}\n\nfunction areStylesTheSame(a: React.CSSProperties, b: React.CSSProperties) {\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n\n  if (aKeys.length !== bKeys.length) {\n    return false;\n  }\n\n  for (let i = 0; i < Math.max(aKeys.length, bKeys.length); i++) {\n    const key: keyof React.CSSProperties = aKeys[i] || (bKeys[i] as any);\n\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function shouldUpdateStyles(\n  prev: ResultingStyles,\n  next: ResultingStyles\n) {\n  if (\n    areStylesTheSame(prev.layer, next.layer) &&\n    areStylesTheSame(prev.arrow, next.arrow)\n  ) {\n    return false;\n  }\n\n  return true;\n}\n\n// creates a ClientRect-like object from the viewport's dimensions\nexport function getWindowClientRect(environment?: Window): ClientRect {\n  return {\n    top: 0,\n    left: 0,\n    right: environment ? environment.innerWidth : 0,\n    bottom: environment ? environment.innerHeight : 0,\n    height: environment ? environment.innerHeight : 0,\n    width: environment ? environment.innerWidth : 0\n  };\n}\n\nconst convertFloat = (value: string) => parseFloat(value.replace(\"px\", \"\"));\n\n// get the outer width / height of an element\n// We effectively want the same width / height that `getBoundingClientRect()`\n// gives, minus optional `scale` transforms\nexport function getContentBox(element: HTMLElement, environment?: Window) {\n  if (!environment) {\n    return { width: 0, height: 0 };\n  }\n\n  const {\n    width,\n    height,\n    boxSizing,\n    borderLeft,\n    borderRight,\n    borderTop,\n    borderBottom,\n    paddingLeft,\n    paddingRight,\n    paddingTop,\n    paddingBottom\n  } = environment.getComputedStyle(element);\n\n  return {\n    width:\n      boxSizing === \"border-box\"\n        ? convertFloat(width!)\n        : [width, borderLeft, borderRight, paddingLeft, paddingRight].reduce(\n            (total, value) => total + (value ? convertFloat(value!) : 0),\n            0\n          ),\n    height:\n      boxSizing === \"border-box\"\n        ? convertFloat(height!)\n        : [height, borderTop, borderBottom, paddingTop, paddingBottom].reduce(\n            (total, value) => total + (value ? convertFloat(value!) : 0),\n            0\n          )\n  };\n}\n\n// converts a ClientRect (or DOMRect) to a plain js-object\n// usefull for destructuring for instance\nexport function clientRectToObject(clientRect: ClientRect): ClientRect {\n  return {\n    top: clientRect.top,\n    left: clientRect.left,\n    right: clientRect.right,\n    bottom: clientRect.bottom,\n    width: clientRect.width,\n    height: clientRect.height\n  };\n}\n\nexport function getElementFromAnchorNode(anchorNode: Node): HTMLElement | null {\n  let currentElement = anchorNode as HTMLElement;\n\n  while (!currentElement.getBoundingClientRect) {\n    if (!currentElement.parentElement) {\n      return null;\n    }\n\n    currentElement = currentElement.parentElement;\n  }\n\n  return currentElement;\n}\n\nexport function minMax(\n  value: number,\n  { min, max }: { min: number; max: number }\n): number {\n  return value < min ? min : value > max ? max : value;\n}\n","import * as React from \"react\";\n\nimport { AnchorEnum, ResultingStyles, LayerSide } from \"./types\";\nimport { EMPTY_STYLE } from \"./util\";\n\nexport default function useStyleState(anchor: AnchorEnum) {\n  const [INITIAL_STYLES] = React.useState<ResultingStyles>({\n    layer: EMPTY_STYLE,\n    arrow: EMPTY_STYLE,\n    layerSide: anchor.split(\"_\")[0].toLowerCase() as LayerSide\n  });\n\n  const [styles, setStyles] = React.useState<ResultingStyles>(INITIAL_STYLES);\n  const lastStyles = React.useRef<ResultingStyles>(styles);\n\n  return {\n    styles,\n    lastStyles,\n    setStyles,\n    resetLastStyles: () => {\n      lastStyles.current = INITIAL_STYLES;\n    }\n  };\n}\n","import {\n  AnchorEnum,\n  Direction,\n  Primary,\n  Side,\n  LayerSide,\n  Rects\n} from \"./types\";\n\nexport const Anchor: Record<Exclude<AnchorEnum, \"CENTER\">, AnchorEnum> = {\n  BOTTOM_LEFT: \"BOTTOM_LEFT\",\n  BOTTOM_RIGHT: \"BOTTOM_RIGHT\",\n  BOTTOM_CENTER: \"BOTTOM_CENTER\",\n  TOP_LEFT: \"TOP_LEFT\",\n  TOP_CENTER: \"TOP_CENTER\",\n  TOP_RIGHT: \"TOP_RIGHT\",\n  LEFT_BOTTOM: \"LEFT_BOTTOM\",\n  LEFT_CENTER: \"LEFT_CENTER\",\n  LEFT_TOP: \"LEFT_TOP\",\n  RIGHT_BOTTOM: \"RIGHT_BOTTOM\",\n  RIGHT_CENTER: \"RIGHT_CENTER\",\n  RIGHT_TOP: \"RIGHT_TOP\"\n};\n\nexport const POSSIBLE_ANCHORS = Object.keys(Anchor) as AnchorEnum[];\n\nexport const PRIMARY_OPPOSITES: Record<Primary, Primary> = {\n  TOP: \"BOTTOM\",\n  BOTTOM: \"TOP\",\n  LEFT: \"RIGHT\",\n  RIGHT: \"LEFT\"\n};\n\nexport function getPrimaryDirection(anchor: AnchorEnum): Direction {\n  return anchor.startsWith(\"TOP_\") || anchor.startsWith(\"BOTTOM_\") ? \"Y\" : \"X\";\n}\n\nfunction primaryIsY(primary: Primary) {\n  return primary === \"TOP\" || primary === \"BOTTOM\";\n}\n\nfunction getPrimaryByIndex(\n  index: number,\n  preferedPrimary: Primary,\n  preferedX: \"LEFT\" | \"RIGHT\",\n  preferedY: \"TOP\" | \"BOTTOM\"\n): Primary {\n  const prefferedIsY = primaryIsY(preferedPrimary);\n\n  if (index < 3) {\n    return preferedPrimary;\n  }\n  if (index < 6) {\n    return prefferedIsY ? preferedX : preferedY;\n  }\n  if (index < 9) {\n    if (prefferedIsY) {\n      return [\"LEFT\", \"RIGHT\"].filter(x => x !== preferedX)[0] as Primary;\n    } else {\n      return [\"TOP\", \"BOTTOM\"].filter(x => x !== preferedY)[0] as Primary;\n    }\n  }\n\n  if (prefferedIsY) {\n    return [\"TOP\", \"BOTTOM\"].filter(x => x !== preferedPrimary)[0] as Primary;\n  } else {\n    return [\"LEFT\", \"RIGHT\"].filter(x => x !== preferedPrimary)[0] as Primary;\n  }\n}\n\nfunction getSecondaryByIndex(\n  index: number,\n  preferedPrimary: Primary,\n  preferedSecondary: Side,\n  rects: Rects\n): Side {\n  const prefferedIsY = primaryIsY(preferedPrimary);\n\n  const triggerHasBiggerHeight = rects.trigger.height > rects.layer.height;\n  const triggerHasBiggerWidth = rects.trigger.width > rects.layer.width;\n\n  switch (index) {\n    case 9:\n    case 0:\n      return preferedSecondary;\n\n    case 1:\n    case 10: {\n      if (preferedSecondary === \"CENTER\") {\n        return prefferedIsY ? \"RIGHT\" : \"BOTTOM\";\n      }\n\n      return \"CENTER\";\n    }\n\n    case 4:\n    case 7:\n      return \"CENTER\";\n\n    case 2:\n    case 11: {\n      if (prefferedIsY) {\n        return [\"LEFT\", \"RIGHT\"].filter(\n          x => x !== preferedSecondary\n        )[0] as Side;\n      } else {\n        return [\"TOP\", \"BOTTOM\"].filter(\n          x => x !== preferedSecondary\n        )[0] as Side;\n      }\n    }\n\n    case 3:\n    case 6: {\n      if (prefferedIsY) {\n        return preferedPrimary === \"BOTTOM\"\n          ? triggerHasBiggerHeight\n            ? \"BOTTOM\"\n            : \"TOP\"\n          : triggerHasBiggerHeight\n          ? \"TOP\"\n          : \"BOTTOM\";\n      }\n\n      return preferedPrimary === \"LEFT\"\n        ? triggerHasBiggerWidth\n          ? \"LEFT\"\n          : \"RIGHT\"\n        : triggerHasBiggerWidth\n        ? \"RIGHT\"\n        : \"LEFT\";\n    }\n\n    case 5:\n    case 8: {\n      if (prefferedIsY) {\n        return preferedPrimary === \"BOTTOM\"\n          ? triggerHasBiggerHeight\n            ? \"TOP\"\n            : \"BOTTOM\"\n          : triggerHasBiggerHeight\n          ? \"BOTTOM\"\n          : \"TOP\";\n      }\n\n      return preferedPrimary === \"LEFT\"\n        ? triggerHasBiggerWidth\n          ? \"RIGHT\"\n          : \"LEFT\"\n        : triggerHasBiggerWidth\n        ? \"LEFT\"\n        : \"RIGHT\";\n    }\n  }\n\n  /* istanbul ignore next */\n  return \"LEFT\";\n}\n\nexport function getSecondaryAnchorOptionsByPrimary(\n  primary: Primary,\n  anchorOptions: AnchorEnum[]\n) {\n  return anchorOptions.filter(anchor => anchor.startsWith(primary));\n}\n\ntype SplitAnchor = {\n  primary: Primary;\n  secondary: Side;\n};\n\nexport function splitAnchor(anchor: AnchorEnum): SplitAnchor {\n  const [primary, secondary] = anchor.split(\"_\") as [Primary, Side];\n\n  return { primary, secondary };\n}\n\nexport function getLayerSideByAnchor(anchor: AnchorEnum): LayerSide {\n  if (anchor === \"CENTER\") {\n    return \"center\";\n  }\n\n  return splitAnchor(anchor).primary.toLowerCase() as LayerSide;\n}\n\nexport function getAnchorPriority(\n  preferedAnchor: AnchorEnum,\n  possibleAnchors: AnchorEnum[],\n  preferedX: \"LEFT\" | \"RIGHT\",\n  preferedY: \"TOP\" | \"BOTTOM\",\n  rects: Rects\n) {\n  const { primary, secondary } =\n    preferedAnchor !== \"CENTER\"\n      ? splitAnchor(preferedAnchor)\n      : {\n          primary: preferedY as Primary,\n          secondary: \"CENTER\" as Side\n        };\n\n  let anchors = POSSIBLE_ANCHORS.map((_, index) => {\n    return `${getPrimaryByIndex(\n      index,\n      primary,\n      preferedX,\n      preferedY\n    )}_${getSecondaryByIndex(index, primary, secondary, rects)}` as AnchorEnum;\n  }).filter(anchor => possibleAnchors.indexOf(anchor) > -1);\n\n  // include prefered anchor if not included in possibleAnchors\n  if (anchors.indexOf(preferedAnchor) === -1) {\n    /* istanbul ignore next */\n    anchors = [preferedAnchor, ...anchors];\n  }\n\n  return anchors;\n}\n","import { Rects, Primary, Side, Direction, AnchorEnum } from \"../types\";\nimport { minMax } from \"../util\";\n\nimport { splitAnchor, getPrimaryDirection } from \"../anchor\";\n\ntype Scroll = { top: number; left: number };\n\nfunction getPrimaryStyle(\n  primary: Primary,\n  rects: Rects,\n  scroll: Scroll,\n  triggerOffset: number\n) {\n  const prop = primary === \"TOP\" || primary === \"BOTTOM\" ? \"top\" : \"left\";\n  const size = primary === \"TOP\" || primary === \"BOTTOM\" ? \"height\" : \"width\";\n\n  if (primary === \"TOP\" || primary === \"LEFT\") {\n    return {\n      [prop]:\n        rects.trigger[prop] -\n        rects.layer[size] -\n        (rects.relativeParent[prop] - scroll[prop]) -\n        triggerOffset\n    };\n  }\n\n  return {\n    [prop]:\n      rects.trigger[prop] +\n      rects.trigger[size] -\n      (rects.relativeParent[prop] - scroll[prop]) +\n      triggerOffset\n  };\n}\n\nfunction getCenter(\n  rects: Rects,\n  scroll: Scroll,\n  offsetSecondary: number,\n  prop: \"top\" | \"left\",\n  size: \"width\" | \"height\"\n) {\n  return minMax(\n    rects.trigger[prop] -\n      rects.relativeParent[prop] +\n      scroll[prop] +\n      rects.trigger[size] / 2 -\n      rects.layer[size] / 2 -\n      offsetSecondary,\n    getLimits(rects, scroll)[prop]\n  );\n}\n\nfunction getLimits(rects: Rects, scroll: Scroll) {\n  const topBase = rects.trigger.top - rects.relativeParent.top + scroll.top;\n  const leftBase = rects.trigger.left - rects.relativeParent.left + scroll.left;\n\n  return {\n    top: {\n      min: topBase - (rects.layer.height - rects.arrow.height),\n      max: topBase + (rects.trigger.height - rects.arrow.height)\n    },\n    left: {\n      min: leftBase - (rects.layer.width - rects.arrow.width),\n      max: leftBase + (rects.trigger.width - rects.arrow.width)\n    }\n  };\n}\n\nfunction getSecondaryStyle(\n  secondary: Side,\n  rects: Rects,\n  scroll: Scroll,\n  offsetSecondary: number,\n  primaryDirection: Direction\n) {\n  if (secondary === \"CENTER\") {\n    const prop = primaryDirection === \"X\" ? \"top\" : \"left\";\n    const size = primaryDirection === \"X\" ? \"height\" : \"width\";\n\n    return {\n      [prop]: getCenter(rects, scroll, offsetSecondary, prop, size)\n    };\n  }\n\n  const prop = secondary === \"TOP\" || secondary === \"BOTTOM\" ? \"top\" : \"left\";\n  const size =\n    secondary === \"TOP\" || secondary === \"BOTTOM\" ? \"height\" : \"width\";\n\n  if (secondary === \"TOP\" || secondary === \"LEFT\") {\n    return {\n      [prop]: minMax(\n        rects.trigger[prop] -\n          rects.relativeParent[prop] +\n          scroll[prop] +\n          offsetSecondary,\n        getLimits(rects, scroll)[prop]\n      )\n    };\n  }\n\n  return {\n    [prop]: minMax(\n      rects.trigger[prop] +\n        rects.trigger[size] -\n        rects.layer[size] -\n        (rects.relativeParent[prop] - scroll[prop]) -\n        offsetSecondary,\n      getLimits(rects, scroll)[prop]\n    )\n  };\n}\n\ntype GetAbsolutePositionsArgs = {\n  anchor: AnchorEnum;\n  rects: Rects;\n  scrollTop: number;\n  scrollLeft: number;\n  triggerOffset: number;\n  offsetSecondary: number;\n};\n\nexport default function getAbsolutePositions({\n  anchor,\n  rects,\n  triggerOffset,\n  offsetSecondary,\n  scrollLeft,\n  scrollTop\n}: GetAbsolutePositionsArgs) {\n  const scroll: Scroll = { left: scrollLeft, top: scrollTop };\n\n  if (anchor === \"CENTER\") {\n    return {\n      top: getCenter(rects, scroll, 0, \"top\", \"height\"),\n      left: getCenter(rects, scroll, 0, \"left\", \"width\")\n    };\n  }\n\n  const { primary, secondary } = splitAnchor(anchor);\n  const primaryDirection = getPrimaryDirection(anchor);\n\n  return {\n    ...getPrimaryStyle(primary, rects, scroll, triggerOffset),\n    ...getSecondaryStyle(\n      secondary,\n      rects,\n      scroll,\n      offsetSecondary,\n      primaryDirection\n    )\n  } as React.CSSProperties;\n}\n","import {\n  Direction,\n  Primary,\n  Side,\n  AnchorEnum,\n  LayerDimensions\n} from \"../types\";\n\nimport {\n  splitAnchor,\n  getPrimaryDirection,\n  getLayerSideByAnchor\n} from \"../anchor\";\n\nimport { clientRectToObject } from \"../util\";\n\n// if user provided `layerDimensions` to the `placement` prop,\n// anticipate the width / height based on the current anchor\nfunction fixLayerDimensions(\n  originalLayer: ClientRect,\n  anchor: AnchorEnum,\n  layerDimensions: LayerDimensions\n): ClientRect {\n  const dimensions =\n    typeof layerDimensions === \"function\"\n      ? layerDimensions(getLayerSideByAnchor(anchor))\n      : layerDimensions;\n\n  return {\n    ...clientRectToObject(originalLayer),\n    ...dimensions\n  };\n}\n\nconst propMap = {\n  TOP: { side1: \"bottom\", side2: \"top\", size: \"height\", factor: -1 },\n  BOTTOM: { side1: \"top\", side2: \"bottom\", size: \"height\", factor: 1 },\n  LEFT: { side1: \"right\", side2: \"left\", size: \"width\", factor: -1 },\n  RIGHT: { side1: \"left\", side2: \"right\", size: \"width\", factor: 1 }\n};\n\nfunction getPrimaryRect(\n  primary: Primary,\n  trigger: ClientRect,\n  layer: ClientRect,\n  triggerOffset: number\n) {\n  const { side1, side2, size, factor } = propMap[primary];\n\n  const value = trigger[side2] + triggerOffset * factor;\n\n  return {\n    [side1]: value,\n    [side2]: value + layer[size] * factor\n  };\n}\n\nfunction getCenter(\n  trigger: ClientRect,\n  layer: ClientRect,\n  offsetSecondary: number,\n  prop: \"top\" | \"left\",\n  size: \"width\" | \"height\"\n) {\n  const value =\n    trigger[prop] + trigger[size] / 2 - layer[size] / 2 - offsetSecondary;\n\n  return {\n    [prop]: value,\n    [prop === \"left\" ? \"right\" : \"bottom\"]: value + layer[size]\n  };\n}\n\nfunction getSecondaryRect(\n  secondary: Side,\n  trigger: ClientRect,\n  layer: ClientRect,\n  offsetSecondary: number,\n  primaryDirection: Direction\n) {\n  if (secondary === \"CENTER\") {\n    const prop = primaryDirection === \"X\" ? \"top\" : \"left\";\n    const size = primaryDirection === \"X\" ? \"height\" : \"width\";\n\n    return getCenter(trigger, layer, offsetSecondary, prop, size);\n  }\n\n  const { side1, side2, size, factor } = propMap[secondary];\n\n  const value = trigger[side2] - offsetSecondary * factor;\n\n  return {\n    [side2]: value,\n    [side1]: value - layer[size] * factor\n  };\n}\n\ntype GetLayerRectArgs = {\n  trigger: ClientRect;\n  layer: ClientRect;\n  anchor: AnchorEnum;\n  triggerOffset: number;\n  scrollOffset?: number;\n  offsetSecondary?: number;\n  layerDimensions: LayerDimensions | null;\n};\n\nexport default function getLayerRectByAnchor({\n  trigger,\n  layer,\n  anchor,\n  triggerOffset,\n  scrollOffset = 0,\n  offsetSecondary = 0,\n  layerDimensions\n}: GetLayerRectArgs): ClientRect {\n  let primaryRect: Partial<ClientRect>;\n  let secondaryRect: Partial<ClientRect>;\n\n  // get the correct anticipated ClientRect based on the provided Anchor\n  const layerRect = layerDimensions\n    ? fixLayerDimensions(layer, anchor, layerDimensions)\n    : layer;\n\n  if (anchor === \"CENTER\") {\n    primaryRect = getCenter(trigger, layerRect, 0, \"top\", \"height\");\n    secondaryRect = getCenter(trigger, layerRect, 0, \"left\", \"width\");\n  } else {\n    const { primary, secondary } = splitAnchor(anchor);\n\n    const primaryDirection = getPrimaryDirection(anchor);\n\n    primaryRect = getPrimaryRect(primary, trigger, layerRect, triggerOffset);\n    secondaryRect = getSecondaryRect(\n      secondary,\n      trigger,\n      layerRect,\n      offsetSecondary,\n      primaryDirection\n    );\n  }\n\n  const result = {\n    ...layerRect,\n    ...primaryRect,\n    ...secondaryRect\n  };\n\n  // correct scrollOffsets\n  result.top = result.top - scrollOffset;\n  result.right = result.right + scrollOffset;\n  result.left = result.left - scrollOffset;\n  result.bottom = result.bottom + scrollOffset;\n\n  return result;\n}\n","import {\n  Rects,\n  AnchorEnum,\n  OffsetSide,\n  LayerDimensions,\n  LayerSide\n} from \"../types\";\nimport getLayerRectByAnchor from \"./getLayerRectByAnchor\";\n\nconst ALL_OFFSET_SIDES: OffsetSide[] = [\"bottom\", \"top\", \"left\", \"right\"];\n\ntype LayerOffsets = Record<OffsetSide, number>;\n\nfunction getLayerOffsetsToParent(\n  layer: ClientRect,\n  parent: ClientRect\n): LayerOffsets {\n  return {\n    top: layer.top - parent.top,\n    bottom: parent.bottom - layer.bottom,\n    left: layer.left - parent.left,\n    right: parent.right - layer.right\n  };\n}\n\nfunction getLayerOffsetsToParents(layer: ClientRect, parents: ClientRect[]) {\n  return parents.map(parent => getLayerOffsetsToParent(layer, parent));\n}\n\nexport function isLayerCompletelyInvisible(\n  layer: ClientRect,\n  parents: ClientRect[]\n) {\n  return parents.some(parent => {\n    return (\n      layer.bottom <= parent.top ||\n      layer.right <= parent.left ||\n      layer.top >= parent.bottom ||\n      layer.left >= parent.right\n    );\n  });\n}\n\nexport function doesEntireLayerFitWithinScrollParents(\n  layer: ClientRect,\n  parents: ClientRect[]\n) {\n  const parentOffsets = getLayerOffsetsToParents(layer, parents);\n\n  return parentOffsets.every(offsets => {\n    return ALL_OFFSET_SIDES.every(side => offsets[side] >= 0);\n  });\n}\n\nexport function reduceOffsets(parentOffsets: LayerOffsets[]): LayerOffsets {\n  const parentOffsetsCombined = parentOffsets.reduce(\n    (result, offsets) => {\n      ALL_OFFSET_SIDES.forEach(side => {\n        result[side] = [...result[side], offsets[side]];\n      });\n      return result;\n    },\n    {\n      top: [] as number[],\n      bottom: [] as number[],\n      left: [] as number[],\n      right: [] as number[]\n    }\n  );\n\n  return ALL_OFFSET_SIDES.reduce(\n    (result, side) => {\n      result[side] = parentOffsetsCombined[side].sort((a, b) => a - b)[0];\n      return result;\n    },\n    {} as LayerOffsets\n  );\n}\n\nexport function getNegativeOffsetSides(parentOffsets: LayerOffsets[]) {\n  const offsets = reduceOffsets(parentOffsets);\n\n  return ALL_OFFSET_SIDES.filter(side => offsets[side] < 0);\n}\n\nfunction getVisibleLayerSurface(layer: ClientRect, parent: ClientRect) {\n  const offsets = getLayerOffsetsToParent(layer, parent);\n\n  const { width, height } = ALL_OFFSET_SIDES.filter(\n    side => offsets[side] < 0\n  ).reduce((rect, side) => {\n    const affectedProperty: \"width\" | \"height\" =\n      side === \"top\" || side === \"bottom\" ? \"height\" : \"width\";\n\n    return {\n      ...rect,\n      [affectedProperty]: rect[affectedProperty] + offsets[side]\n    };\n  }, layer);\n\n  const result = width * height;\n\n  return width < 0 && height < 0 ? -result : result;\n}\n\nexport function getVisibleLayerSurfaceWithinScrollParent(\n  layer: ClientRect,\n  parents: ClientRect[]\n) {\n  const surfaces = parents.map(parent => getVisibleLayerSurface(layer, parent));\n\n  // pick smallest\n  return surfaces.sort((a, b) => a - b)[0];\n}\n\nexport function doesAnchorFitWithinScrollParents(\n  anchor: AnchorEnum,\n  rects: Rects,\n  triggerOffset: number,\n  scrollOffset: number,\n  layerDimensions: LayerDimensions | null\n) {\n  const layerRect = getLayerRectByAnchor({\n    anchor,\n    trigger: rects.trigger,\n    layer: rects.layer,\n    triggerOffset,\n    scrollOffset,\n    layerDimensions\n  });\n\n  return doesEntireLayerFitWithinScrollParents(layerRect, rects.scrollParents);\n}\n\nexport function getLayerOffsetsToScrollParentsByAnchor(\n  anchor: AnchorEnum,\n  rects: Rects,\n  triggerOffset: number,\n  scrollOffset: number\n) {\n  return getLayerOffsetsToParents(\n    getLayerRectByAnchor({\n      anchor,\n      trigger: rects.trigger,\n      layer: rects.layer,\n      triggerOffset,\n      scrollOffset,\n      layerDimensions: null\n    }),\n    rects.scrollParents\n  );\n}\n\nexport function triggerIsBiggerThanLayer(\n  layerSide: LayerSide,\n  layer: ClientRect,\n  trigger: ClientRect\n): boolean {\n  return (\n    ((layerSide === \"top\" || layerSide === \"bottom\") &&\n      trigger.width > layer.width) ||\n    ((layerSide === \"left\" || layerSide === \"right\") &&\n      trigger.height > layer.height)\n  );\n}\n","import { Rects, AnchorEnum, LayerDimensions } from \"../types\";\nimport { getPrimaryDirection } from \"../anchor\";\nimport {\n  doesAnchorFitWithinScrollParents,\n  getVisibleLayerSurfaceWithinScrollParent\n} from \"../rect\";\nimport getLayerRectByAnchor from \"../rect/getLayerRectByAnchor\";\n\nfunction getOffsetSurface(\n  anchor: AnchorEnum,\n  layer: ClientRect,\n  triggerOffset: number,\n  scrollOffset: number\n) {\n  const primaryDirection = getPrimaryDirection(anchor);\n\n  const primarySize =\n    layer[primaryDirection === \"X\" ? \"width\" : \"height\"] -\n    triggerOffset -\n    scrollOffset * 2;\n\n  const secondarySize =\n    layer[primaryDirection === \"X\" ? \"height\" : \"width\"] -\n    triggerOffset -\n    scrollOffset * 2;\n\n  return primarySize * secondarySize;\n}\n\nfunction findAnchorByLayerSurface(\n  rects: Rects,\n  anchorOptions: AnchorEnum[],\n  triggerOffset: number,\n  scrollOffset: number,\n  layerDimensions: LayerDimensions | null\n): AnchorEnum {\n  const result = anchorOptions\n    .map(anchor => {\n      // get layerRect based on all offsets\n      const layerRect = getLayerRectByAnchor({\n        anchor,\n        layer: rects.layer,\n        trigger: rects.trigger,\n        scrollOffset,\n        triggerOffset,\n        layerDimensions\n      });\n\n      // get smallest visible layer surface for current anchor\n      const surface = getVisibleLayerSurfaceWithinScrollParent(\n        layerRect,\n        rects.scrollParents\n      );\n\n      // get surface of the offsets\n      // offsets are important for collision detection, but\n      // eventually we are interested in the 'meat' of the layer\n      const offsetSurface = getOffsetSurface(\n        anchor,\n        layerRect,\n        triggerOffset,\n        scrollOffset\n      );\n\n      return {\n        anchor,\n        square: surface - offsetSurface\n      };\n    })\n    // sort -> biggest surface first\n    .sort((a, b) => b.square - a.square);\n\n  return result[0].anchor;\n}\n\nexport default function findBestSuitableAnchor(\n  rects: Rects,\n  anchorOptions: AnchorEnum[],\n  triggerOffset: number,\n  scrollOffset: number,\n  layerDimensions: LayerDimensions | null\n): AnchorEnum {\n  // STRATEGY A\n  // find first that fits parent\n  const anchor = anchorOptions.find(anchor =>\n    doesAnchorFitWithinScrollParents(\n      anchor,\n      rects,\n      triggerOffset,\n      scrollOffset,\n      layerDimensions\n    )\n  );\n\n  if (anchor) {\n    return anchor;\n  }\n\n  // STRATEGY B\n  // find first with biggest surface\n  return findAnchorByLayerSurface(\n    rects,\n    anchorOptions,\n    triggerOffset,\n    scrollOffset,\n    layerDimensions\n  );\n}\n","import { Rects, AnchorEnum, OffsetSide } from \"../types\";\nimport {\n  getLayerOffsetsToScrollParentsByAnchor,\n  getNegativeOffsetSides,\n  doesAnchorFitWithinScrollParents,\n  reduceOffsets,\n  triggerIsBiggerThanLayer\n} from \"../rect\";\nimport {\n  splitAnchor,\n  getPrimaryDirection,\n  getSecondaryAnchorOptionsByPrimary,\n  getLayerSideByAnchor\n} from \"../anchor\";\n\n// finds out which side of the layer will be affected\nfunction getSecondaryOffsetSide(\n  currentAnchor: AnchorEnum,\n  firstAnchorThatDoesNotFit: AnchorEnum,\n  rects: Rects,\n  triggerOffset: number,\n  scrollOffset: number\n): OffsetSide | undefined {\n  const primaryDirection = getPrimaryDirection(currentAnchor);\n\n  const offsets = getLayerOffsetsToScrollParentsByAnchor(\n    firstAnchorThatDoesNotFit,\n    rects,\n    triggerOffset,\n    scrollOffset\n  );\n\n  const sides = getNegativeOffsetSides(offsets);\n\n  return sides.find(side => {\n    if (primaryDirection === \"X\") {\n      return side === \"top\" || side === \"bottom\";\n    }\n\n    return side === \"left\" || side === \"right\";\n  });\n}\n\nexport default function findSecondaryOffset(\n  anchor: AnchorEnum,\n  anchorOptions: AnchorEnum[],\n  rects: Rects,\n  triggerOffset: number,\n  scrollOffset: number\n) {\n  const { primary } = splitAnchor(anchor);\n\n  /**\n   * A.\n   * Check which other anchors available\n   */\n  const secondaryAnchorOptions = getSecondaryAnchorOptionsByPrimary(\n    primary,\n    anchorOptions\n  );\n\n  /**\n   * B.\n   * Check whether current anchor is the preffered anchor and whether\n   * it fits\n   * If so, skip secondary offset\n   */\n  const currentAnchorHasHighestPriority =\n    secondaryAnchorOptions.indexOf(anchor) === 0;\n  const currentAnchorFits = doesAnchorFitWithinScrollParents(\n    anchor,\n    rects,\n    triggerOffset,\n    scrollOffset,\n    null\n  );\n\n  if (currentAnchorHasHighestPriority && currentAnchorFits) {\n    return 0;\n  }\n\n  /**\n   * C.\n   * Retrieve the first anchor on same primary side (by priority) that\n   * does not fit.\n   * Check if there's a relevant side that has a negative offset.\n   * If not, skip secondary offset\n   */\n  const firstAnchorThatDoesNotFit = secondaryAnchorOptions.find(anchor => {\n    return !doesAnchorFitWithinScrollParents(\n      anchor,\n      rects,\n      triggerOffset,\n      scrollOffset,\n      null\n    );\n  })!;\n\n  const affectedSide = getSecondaryOffsetSide(\n    anchor,\n    firstAnchorThatDoesNotFit,\n    rects,\n    triggerOffset,\n    scrollOffset\n  );\n\n  if (!affectedSide) {\n    return 0;\n  }\n\n  /**\n   * Determine the final secondary offset\n   */\n  const currentOffsets = reduceOffsets(\n    getLayerOffsetsToScrollParentsByAnchor(\n      anchor,\n      rects,\n      triggerOffset,\n      scrollOffset\n    )\n  );\n\n  let secondaryOffset = -currentOffsets[affectedSide];\n\n  const triggerIsBigger = triggerIsBiggerThanLayer(\n    getLayerSideByAnchor(anchor),\n    rects.layer,\n    rects.trigger\n  );\n\n  const isCenter = anchor.includes(\"_CENTER\");\n  const isLeft = anchor.includes(\"_LEFT\");\n  const isTop = anchor.includes(\"_TOP\");\n\n  // when trigger is bigger, make `secondaryOffset` positive\n  // conditionally\n  if (\n    triggerIsBigger &&\n    ((isLeft && affectedSide === \"right\") ||\n      affectedSide === \"left\" ||\n      (isTop && affectedSide === \"bottom\") ||\n      affectedSide === \"top\")\n  ) {\n    secondaryOffset = -secondaryOffset;\n  } else if (\n    // when current anchor is center, make `secondaryOffset` positive\n    // when affectedSide is top or right\n    !triggerIsBigger &&\n    (isCenter && (affectedSide === \"top\" || affectedSide === \"left\"))\n  ) {\n    secondaryOffset = -secondaryOffset;\n  }\n\n  return secondaryOffset;\n}\n","import { LayerSide } from \"../types\";\nimport { triggerIsBiggerThanLayer } from \"../rect\";\nimport { minMax } from \"../util\";\n\nfunction getOffsets(layer: ClientRect, trigger: ClientRect, arrow: ClientRect) {\n  const left = layer.left + layer.width / 2 - trigger.left - arrow.width / 2;\n  const right = layer.right - layer.width / 2 - trigger.right + arrow.width / 2;\n  const top = layer.top + layer.height / 2 - trigger.top - arrow.height / 2;\n  const bottom =\n    layer.bottom - layer.height / 2 - trigger.bottom + arrow.height / 2;\n\n  return {\n    left: left < 0 ? -left : 0,\n    right: right > 0 ? -right : 0,\n    top: top < 0 ? -top : 0,\n    bottom: bottom > 0 ? -bottom : 0\n  };\n}\n\nexport default function getArrowStyle(\n  layer: ClientRect,\n  trigger: ClientRect,\n  layerSide: LayerSide,\n  arrow: ClientRect\n): React.CSSProperties {\n  const triggerIsBigger = triggerIsBiggerThanLayer(layerSide, layer, trigger);\n\n  const limitsDefault = {\n    left: {\n      min: arrow.width / 2,\n      max: layer.width - arrow.width / 2\n    },\n    top: {\n      min: arrow.height / 2,\n      max: layer.height - arrow.height / 2\n    }\n  };\n\n  const offsets = getOffsets(layer, trigger, arrow);\n\n  if (layerSide === \"bottom\") {\n    return {\n      bottom: \"100%\",\n      top: null,\n      left: minMax(\n        triggerIsBigger\n          ? layer.width / 2 + (offsets.left + offsets.right)\n          : trigger.left + trigger.width / 2 - layer.left,\n        limitsDefault.left\n      ),\n      right: null\n    } as any;\n  }\n  if (layerSide === \"right\") {\n    return {\n      right: \"100%\",\n      left: null,\n      top: minMax(\n        triggerIsBigger\n          ? layer.height / 2 + (offsets.top + offsets.bottom)\n          : trigger.top + trigger.height / 2 - layer.top,\n        limitsDefault.top\n      ),\n      bottom: null\n    } as any;\n  }\n  if (layerSide === \"top\") {\n    return {\n      top: \"100%\",\n      bottom: null,\n      left: minMax(\n        triggerIsBigger\n          ? layer.width / 2 + (offsets.left + offsets.right)\n          : trigger.left + trigger.width / 2 - layer.left,\n        limitsDefault.left\n      ),\n      right: null\n    } as any;\n  }\n\n  return {\n    left: \"100%\",\n    right: null,\n    top: minMax(\n      triggerIsBigger\n        ? layer.height / 2 + (offsets.top + offsets.bottom)\n        : trigger.top + trigger.height / 2 - layer.top,\n      limitsDefault.top\n    ),\n    bottom: null\n  } as any;\n}\n","import {\n  Rects,\n  AnchorEnum,\n  PreferedX,\n  PreferedY,\n  LayerDimensions\n} from \"../types\";\n\nimport { getAnchorPriority } from \"../anchor\";\n\nimport getAbsolutePositions from \"./getAbsolutePositions\";\nimport getSuitableAnchor from \"./getSuitableAnchor\";\nimport getSecondaryOffset from \"./getSecondaryOffset\";\nimport getLayerRectByAnchor from \"../rect/getLayerRectByAnchor\";\n\nexport { default as getArrowStyle } from \"./getArrowStyle\";\n\ntype GetAutoAdjustStyleArgs = {\n  rects: Rects;\n  scrollTop: number;\n  scrollLeft: number;\n  triggerOffset: number;\n  scrollOffset: number;\n  preferedAnchor: AnchorEnum;\n  preferedX: PreferedX;\n  preferedY: PreferedY;\n  possibleAnchors: AnchorEnum[];\n  autoAdjust: boolean;\n  snapToAnchor: boolean;\n  layerDimensions: LayerDimensions | null;\n};\n\nexport default function getAbsoluteStyle({\n  rects,\n  scrollTop,\n  scrollLeft,\n  triggerOffset,\n  scrollOffset,\n  possibleAnchors,\n  preferedAnchor,\n  preferedX,\n  preferedY,\n  autoAdjust,\n  snapToAnchor,\n  layerDimensions\n}: GetAutoAdjustStyleArgs): {\n  layerStyle: React.CSSProperties;\n  layerRect: ClientRect;\n  anchor: AnchorEnum;\n} {\n  // get a list of possible anchors bases on user set props\n  const possibleAnchorsByPriority = getAnchorPriority(\n    preferedAnchor,\n    possibleAnchors,\n    preferedX,\n    preferedY,\n    rects\n  );\n\n  // on `autoAdjust` find best suitable anchor based on\n  // window's / scrollParent's position\n  const anchor = autoAdjust\n    ? getSuitableAnchor(\n        rects,\n        possibleAnchorsByPriority,\n        triggerOffset,\n        scrollOffset,\n        layerDimensions\n      )\n    : preferedAnchor;\n\n  // calculate a secondary offset when `autoAdjust` is set\n  // and `snapToAnchor` is not.\n  // Basically it creates a visual effect where it seems that\n  // the layer has glued to it's parents sides\n  // Note: `offsetSecondary` is disabled when anchor is CENTER\n  const offsetSecondary =\n    autoAdjust && !snapToAnchor && anchor !== \"CENTER\"\n      ? getSecondaryOffset(\n          anchor,\n          possibleAnchorsByPriority,\n          rects,\n          triggerOffset,\n          scrollOffset\n        )\n      : 0;\n\n  const layerStyle = getAbsolutePositions({\n    anchor,\n    rects,\n    triggerOffset,\n    offsetSecondary,\n    scrollLeft,\n    scrollTop\n  });\n\n  const layerRect = getLayerRectByAnchor({\n    anchor,\n    trigger: rects.trigger,\n    layer: rects.layer,\n    triggerOffset,\n    offsetSecondary,\n    layerDimensions\n  });\n\n  if (layerDimensions) {\n    layerStyle.width = layerRect.width;\n    layerStyle.height = layerRect.height;\n  }\n\n  return {\n    layerStyle,\n    layerRect,\n    anchor\n  };\n}\n","import { Placement, ResultingStyles, Rects } from \"./types\";\nimport {\n  getWindowClientRect,\n  getContentBox,\n  EMPTY_STYLE,\n  isSet,\n  clientRectToObject\n} from \"./util\";\nimport { POSSIBLE_ANCHORS, getLayerSideByAnchor } from \"./anchor\";\nimport getAbsoluteStyle, { getArrowStyle } from \"./style\";\n\nfunction compensateScrollbars(\n  rect: ClientRect,\n  clientWidth: number,\n  clientHeight: number\n) {\n  const scrollbarWidth = rect.width - clientWidth;\n  const scrollbarHeight = rect.height - clientHeight;\n\n  return {\n    left: rect.left,\n    top: rect.top,\n    width: rect.width - scrollbarWidth,\n    right: rect.right - scrollbarWidth,\n    height: rect.height - scrollbarHeight,\n    bottom: rect.bottom - scrollbarHeight\n  };\n}\n\nfunction getArrowRect(\n  layerElement: HTMLElement,\n  arrowOffset: number\n): ClientRect {\n  const arrowElement = layerElement.querySelector(\"[data-arrow]\");\n  if (!arrowElement) {\n    return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 };\n  }\n\n  const rect = arrowElement.getBoundingClientRect();\n\n  return {\n    ...clientRectToObject(rect),\n    width: rect.width + arrowOffset * 2,\n    height: rect.height + arrowOffset * 2\n  };\n}\n\nexport const defaultPlacement: Required<Placement> = {\n  autoAdjust: false,\n  snapToAnchor: false,\n  anchor: \"TOP_CENTER\",\n  layerDimensions: null,\n  possibleAnchors: POSSIBLE_ANCHORS,\n  preferX: \"RIGHT\",\n  preferY: \"BOTTOM\",\n  scrollOffset: 10,\n  triggerOffset: 0,\n  arrowOffset: 0\n};\n\ntype CalculateStyleProps = {\n  triggerRect: ClientRect;\n  layerElement: HTMLElement | null;\n  relativeParentElement: HTMLElement | null;\n  scrollParents: HTMLElement[];\n  placement: Placement;\n  fixed: boolean | undefined;\n  environment?: Window;\n};\n\nexport default function getPositioning({\n  triggerRect,\n  layerElement,\n  relativeParentElement,\n  scrollParents,\n  placement = {},\n  environment,\n  fixed\n}: CalculateStyleProps) {\n  /**\n   * A.\n   * Calculate new layer positions\n   */\n\n  // sometimes ResizeObserver calls this function when all values in the\n  // trigger ClientRect are 0. Return early in that case\n  if (triggerRect.height === 0) {\n    return;\n  }\n\n  if (!layerElement) {\n    return;\n  }\n\n  // gather all scroll parents (including the window ClientRect)\n  // in order to check for collisions\n  const scrollParentRects = fixed\n    ? [getWindowClientRect(environment)]\n    : [\n        ...scrollParents.map(parent =>\n          compensateScrollbars(\n            parent.getBoundingClientRect(),\n            parent.clientWidth,\n            parent.clientHeight\n          )\n        ),\n        getWindowClientRect(environment)\n      ];\n\n  const options = {\n    autoAdjust: placement.autoAdjust || defaultPlacement.autoAdjust,\n    snapToAnchor: placement.snapToAnchor || defaultPlacement.snapToAnchor,\n    triggerOffset: (isSet(placement.triggerOffset)\n      ? placement.triggerOffset\n      : defaultPlacement.triggerOffset) as number,\n    scrollOffset: (isSet(placement.scrollOffset)\n      ? placement.scrollOffset\n      : defaultPlacement.scrollOffset) as number,\n    possibleAnchors:\n      placement.possibleAnchors || defaultPlacement.possibleAnchors,\n    preferedAnchor: placement.anchor || defaultPlacement.anchor,\n    preferedX: placement.preferX || defaultPlacement.preferX,\n    preferedY: placement.preferY || defaultPlacement.preferY,\n    scrollLeft:\n      relativeParentElement === document.body\n        ? 0\n        : relativeParentElement!.scrollLeft,\n    scrollTop:\n      relativeParentElement === document.body\n        ? 0\n        : relativeParentElement!.scrollTop,\n    relativeParentElement,\n    layerDimensions:\n      placement.layerDimensions || defaultPlacement.layerDimensions\n  };\n\n  const layerBox = layerElement.getBoundingClientRect();\n\n  // construct layerRect\n  const layer = {\n    top: layerBox.top,\n    left: layerBox.left,\n    right: layerBox.right,\n    bottom: layerBox.bottom,\n\n    // use `window.getComputedProperty` for width / height in order\n    // to handle things like scale-transforms\n    ...getContentBox(layerElement!, environment)\n  };\n\n  const rects: Rects = {\n    layer,\n    relativeParent: relativeParentElement!.getBoundingClientRect(),\n    scrollParents: scrollParentRects,\n    trigger: triggerRect,\n    arrow: getArrowRect(\n      layerElement,\n      placement.arrowOffset || defaultPlacement.arrowOffset\n    )\n  };\n\n  const { layerRect, layerStyle, anchor } = getAbsoluteStyle({\n    rects,\n    ...options\n  });\n\n  if (fixed) {\n    layerStyle.top = layerRect.top;\n    layerStyle.left = layerRect.left;\n  }\n\n  // determine in which side to layer will be relative to\n  // the trigger\n  const layerSide = getLayerSideByAnchor(anchor);\n\n  // get optional arrow positions\n  // anchor-style is pointless when rendered anchor is CENTER\n  const arrowStyle =\n    anchor === \"CENTER\"\n      ? EMPTY_STYLE\n      : getArrowStyle(layerRect, triggerRect, layerSide, rects.arrow);\n\n  const styles: ResultingStyles = {\n    layer: layerStyle,\n    arrow: arrowStyle,\n    layerSide\n  };\n\n  return {\n    styles,\n    layerRect\n  };\n}\n","import * as React from \"react\";\n\n/**\n * Tracks an element and keeps it in state\n * (together with other relevant state that depends on the element)\n */\nfunction useElementRef<T = HTMLElement | null>(\n  initialState?: T,\n  elementToState?: (element: HTMLElement) => T\n) {\n  const [state, setState] = React.useState<T | null>(initialState || null);\n\n  const lastElement = React.useRef<HTMLElement | null>(null);\n\n  const setRef = React.useCallback(node => {\n    if (node && node !== lastElement.current) {\n      lastElement.current = node;\n      if (elementToState) {\n        setState(elementToState(node));\n      } else {\n        setState(node);\n      }\n    }\n  }, []);\n\n  return [setRef, state, lastElement] as [\n    any,\n    T,\n    React.MutableRefObject<HTMLElement | null>\n  ];\n}\n\nexport default useElementRef;\n","export default function findScrollContainers(\n  element: HTMLElement | null,\n  environment?: Window\n): HTMLElement[] {\n  const result: HTMLElement[] = [];\n\n  if (!element || !environment) {\n    return result;\n  }\n\n  if (element === document.body) {\n    return result;\n  }\n\n  const { overflow, overflowX, overflowY } = environment.getComputedStyle(\n    element\n  );\n\n  if (\n    [overflow, overflowX, overflowY].some(\n      prop => prop === \"auto\" || prop === \"scroll\"\n    )\n  ) {\n    result.push(element);\n  }\n\n  return [\n    ...result,\n    ...findScrollContainers(element.parentElement, environment)\n  ];\n}\n","import { Container } from \"./types\";\nimport useElementRef from \"./useElementRef\";\nimport * as React from \"react\";\nimport findScrollContainers from \"./findScrollContainers\";\n\ntype UseElementState = {\n  triggerElement: HTMLElement | null;\n  relativeParentElement: HTMLElement | null;\n  scrollParents: HTMLElement[];\n};\n\nexport default function useElementState(\n  container: Container | undefined,\n  fixed: boolean | undefined,\n  environment?: Window\n) {\n  return useElementRef<UseElementState>(\n    { triggerElement: null, relativeParentElement: null, scrollParents: [] },\n    React.useCallback((triggerElement: HTMLElement) => {\n      const scrollParents = findScrollContainers(triggerElement, environment);\n\n      const relativeParentElement = scrollParents[0] || document.body;\n\n      if (relativeParentElement === document.body) {\n        document.body.style.position = \"relative\";\n      } else if (process.env.NODE_ENV === \"development\" && environment) {\n        // Check if we should warn the user about 'position: relative; stuff...'\n        const containerElement =\n          typeof container === \"function\" ? container() : container;\n\n        const position = environment.getComputedStyle(relativeParentElement)\n          .position;\n        const shouldWarnAboutPositionStyle =\n          position !== \"relative\" &&\n          position !== \"absolute\" &&\n          position !== \"fixed\" &&\n          !fixed &&\n          !containerElement;\n\n        if (shouldWarnAboutPositionStyle) {\n          console.error(\n            `react-laag: Set the 'position' style of the nearest scroll-container to 'relative', 'absolute' or 'fixed', or set the 'fixed' prop to true. This is needed in order to position the layers properly. Currently the scroll-container is positioned: \"${position}\". Visit https://react-laag.com/docs/#position-relative for more info.`,\n            relativeParentElement\n          );\n        }\n      }\n\n      return {\n        triggerElement,\n        relativeParentElement,\n        scrollParents\n      };\n    }, [])\n  );\n}\n","import * as React from \"react\";\nimport { isSet } from \"./util\";\n\nexport default function useIsOpen(\n  internal: boolean,\n  external: boolean | undefined\n) {\n  const shouldOpenAfterMount = React.useRef<boolean>(external!);\n\n  const isOpen = shouldOpenAfterMount.current\n    ? false\n    : isSet(external)\n    ? external!\n    : internal;\n\n  const rerenderAfterMount = React.useState(false)[1];\n\n  React.useEffect(() => {\n    if (shouldOpenAfterMount.current) {\n      shouldOpenAfterMount.current = false;\n      rerenderAfterMount(true);\n    }\n  }, []);\n\n  return isOpen;\n}\n","import * as React from \"react\";\nimport {\n  LayerSide,\n  RenderLayer,\n  ToggleLayerOptions,\n  DisappearType\n} from \"./types\";\n\nimport useOutsideClick, { OutsideClickGroupProvider } from \"./useOutsideClick\";\nimport useOnScroll from \"./useOnScroll\";\nimport useOnWindowResize from \"./useOnWindowResize\";\nimport useTrackElementResize from \"./useTrackElementResize\";\nimport useIsomorphicLayoutEffect from \"./useIsomorphicLayoutEffect\";\nimport useStyleState from \"./useStyleState\";\nimport getPositioning, { defaultPlacement } from \"./getPositioning\";\nimport useElementState from \"./useElementState\";\nimport useIsOpen from \"./useIsOpen\";\n\nimport {\n  EMPTY_STYLE,\n  isSet,\n  shouldUpdateStyles,\n  getWindowClientRect\n} from \"./util\";\n\nimport {\n  doesEntireLayerFitWithinScrollParents,\n  isLayerCompletelyInvisible\n} from \"./rect\";\nimport { createPortal } from \"react-dom\";\n\ntype RenderChildrenProps = {\n  isOpen: boolean;\n  open: () => void;\n  close: () => void;\n  toggle: () => void;\n  triggerRef: React.RefObject<any>;\n  layerSide: LayerSide | null;\n};\n\nexport type ToggleLayerProps = {\n  children: (childrenProps: RenderChildrenProps) => React.ReactNode;\n  renderLayer: RenderLayer;\n  isOpen?: boolean;\n  onOutsideClick?: () => void;\n  onDisappear?: (type: DisappearType) => void;\n} & ToggleLayerOptions;\n\nexport const ToggleLayer = ({\n  children,\n  renderLayer,\n  placement = {},\n  onStyle,\n  isOpen: isOpenExternal,\n  closeOnOutsideClick,\n  onOutsideClick,\n  onDisappear,\n  closeOnDisappear,\n  fixed,\n  container,\n  environment = typeof window !== \"undefined\" ? window : undefined,\n  ...props\n}: ToggleLayerProps) => {\n  /**\n   * Tracks trigger element and keeps it in state together with it's\n   * relative/absolute positioned parent\n   */\n  const [\n    triggerRef,\n    { relativeParentElement, triggerElement, scrollParents },\n    normalTriggerRef\n  ] = useElementState(container, fixed, environment!);\n\n  const { styles, setStyles, lastStyles, resetLastStyles } = useStyleState(\n    placement.anchor || defaultPlacement.anchor\n  );\n\n  const layerRef = React.useRef<HTMLElement | null>(null);\n\n  const [isOpenInternal, setOpenInternal] = React.useState(false);\n\n  const isOpen = useIsOpen(isOpenInternal, isOpenExternal);\n\n  const handlePositioning = React.useCallback(() => {\n    if (!triggerElement) {\n      throw new Error(\n        \"Could not find a valid reference of the trigger element. See https://www.react-laag.com/docs/togglelayer/#children for more info.\"\n      );\n    }\n    const triggerRect = triggerElement.getBoundingClientRect();\n\n    const result = getPositioning({\n      triggerRect,\n      layerElement: layerRef.current,\n      placement,\n      relativeParentElement,\n      scrollParents,\n      fixed,\n      environment\n    });\n\n    if (!result) {\n      return;\n    }\n\n    const { layerRect, styles } = result;\n\n    // only update styles when necessary\n    if (shouldUpdateStyles(lastStyles.current, styles)) {\n      // is parent in control of styles? (onStyle)\n      if (isSet(onStyle)) {\n        lastStyles.current = styles;\n        onStyle!(styles.layer, styles.arrow, styles.layerSide);\n      }\n      // ... otherwise set styles internally\n      else {\n        setStyles(styles);\n      }\n    }\n\n    /**\n     * B.\n     * Manage disappearance\n     */\n\n    const hasOnDisappear = isSet(onDisappear);\n    const shouldCloseOnDisappear = closeOnDisappear && !isSet(isOpenExternal);\n\n    // Should we respond to the layer's partial or full disappearance?\n    // (trigger's disappearance when `fixed` props is set)\n    if (hasOnDisappear || shouldCloseOnDisappear) {\n      const allScrollParents = [\n        ...scrollParents.map(parent => parent.getBoundingClientRect()),\n        getWindowClientRect(environment)\n      ];\n\n      const partial = !doesEntireLayerFitWithinScrollParents(\n        fixed ? triggerRect : layerRect,\n        allScrollParents\n      );\n\n      const full = isLayerCompletelyInvisible(\n        fixed ? triggerRect : layerRect,\n        allScrollParents\n      );\n\n      // if parent is interested in diseappearance...\n      if (hasOnDisappear) {\n        if (partial || full) {\n          onDisappear!(full ? \"full\" : \"partial\");\n        }\n      }\n      // ... else close accordingly\n      else {\n        if (closeOnDisappear === \"partial\" && partial) {\n          setOpenInternal(false);\n        }\n        if (closeOnDisappear === \"full\" && full) {\n          setOpenInternal(false);\n        }\n      }\n    }\n  }, [\n    relativeParentElement,\n    isOpen,\n    triggerElement,\n    scrollParents,\n    fixed,\n    placement\n  ]);\n\n  // call `handlePositioning` when the layer's / trigger's\n  // height and / or width changes\n  const resizeObserver = useTrackElementResize(\n    props.ResizeObserver,\n    layerRef,\n    triggerElement,\n    isOpen,\n    handlePositioning,\n    environment\n  );\n\n  // On every render, check a few things...\n  useIsomorphicLayoutEffect(() => {\n    /**\n     * A.\n     * Ignore when render is caused by internal style change\n     */\n    const styleIsSetInterally = !isSet(onStyle);\n    const effectBecauseOfInternalStyleChange = styles !== lastStyles.current;\n\n    if (effectBecauseOfInternalStyleChange && styleIsSetInterally) {\n      lastStyles.current = styles;\n      return;\n    }\n\n    // reset lastStyles-ref when closed\n    if (!isOpen) {\n      resetLastStyles();\n      return;\n    }\n\n    /**\n     * B.\n     * Prepare to calculate new layer style\n     */\n\n    // if (!triggerElement) {\n    //   throw new Error(\"Please provide a valid ref to the trigger element\");\n    // } else if (!layerRef.current) {\n    //   throw new Error(\"Please provide a valid ref to the layer element\");\n    // }\n\n    handlePositioning();\n  });\n\n  // calculate new layer style when window size changes\n  useOnWindowResize(handlePositioning, environment, isOpen);\n\n  // calculate new layer style when user scrolls\n  useOnScroll(scrollParents, handlePositioning, environment, isOpen);\n\n  const outsideClickRefs = React.useRef(\n    new Set<React.RefObject<HTMLElement | null | undefined>>([\n      layerRef,\n      normalTriggerRef\n    ])\n  );\n\n  // handle clicks that are not originated from the trigger / layer\n  // element\n  useOutsideClick(\n    outsideClickRefs,\n    React.useCallback(() => {\n      if (!isOpen) {\n        return;\n      }\n\n      if (onOutsideClick) {\n        onOutsideClick();\n      }\n\n      if (closeOnOutsideClick && !isSet(isOpenExternal)) {\n        setOpenInternal(false);\n      }\n    }, [isOpen, setOpenInternal, isOpenExternal, onOutsideClick])\n  );\n\n  const containerElement =\n    typeof container === \"function\" ? container() : container;\n\n  return (\n    <>\n      {children({\n        isOpen,\n        close: () => {\n          /* istanbul ignore next */\n          if (isSet(isOpenExternal)) {\n            throw new Error(\n              \"You cannot call `close()` while using the `isOpen` prop\"\n            );\n          }\n          /* istanbul ignore next */\n          setOpenInternal(false);\n        },\n        open: () => {\n          /* istanbul ignore next */\n          if (isSet(isOpenExternal)) {\n            throw new Error(\n              \"You cannot call `open()` while using the `isOpen` prop\"\n            );\n          }\n          /* istanbul ignore next */\n          setOpenInternal(true);\n        },\n        toggle: () => {\n          /* istanbul ignore next */\n          if (isSet(isOpenExternal)) {\n            throw new Error(\n              \"You cannot call `toggle()` while using the `isOpen` prop\"\n            );\n          }\n          setOpenInternal(!isOpenInternal);\n        },\n        triggerRef,\n        layerSide: isOpen ? styles.layerSide : null\n      })}\n\n      {relativeParentElement && (\n        <OutsideClickGroupProvider refs={outsideClickRefs}>\n          {createPortal(\n            renderLayer({\n              layerProps: {\n                ref: element => {\n                  if (element) {\n                    // observe the layer for resizing\n                    // it's ok to observe the same element multiple times\n                    // since multiple observes of same element are ignored\n                    resizeObserver.observe(element!);\n                  }\n\n                  layerRef.current = element;\n                },\n                style: {\n                  ...(isSet(onStyle) ? EMPTY_STYLE : styles.layer),\n                  position: fixed ? \"fixed\" : \"absolute\",\n                  willChange: \"top, bottom, left, right, width, height\"\n                }\n              },\n              arrowStyle: {\n                ...(isSet(onStyle) ? EMPTY_STYLE : styles.arrow),\n                position: \"absolute\",\n                willChange: \"top, bottom, left, right\"\n              },\n              isOpen,\n              layerSide: styles.layerSide,\n              triggerRect: triggerElement\n                ? triggerElement.getBoundingClientRect()\n                : null,\n              close: () => {\n                /* istanbul ignore next */\n                if (isSet(isOpenExternal)) {\n                  throw new Error(\n                    \"You cannot call `close()` while using the `isOpen` prop\"\n                  );\n                }\n                /* istanbul ignore next */\n                setOpenInternal(false);\n              }\n            }),\n            containerElement || relativeParentElement\n          )}\n        </OutsideClickGroupProvider>\n      )}\n    </>\n  );\n}\n\nexport default ToggleLayer;\n","import * as React from \"react\";\nimport { LayerSide } from \"./types\";\n\nfunction getWidthBasedOnAngle(angle: number, size: number) {\n  return Math.tan(angle * (Math.PI / 180)) * size;\n}\n\nfunction getViewBox(\n  sizeA: number,\n  sizeB: number,\n  layerSide: LayerSide,\n  borderWidth: number\n) {\n  switch (layerSide) {\n    case \"bottom\":\n      return `0 ${-borderWidth} ${sizeB} ${sizeA}`;\n    case \"top\":\n      return `0 0 ${sizeB} ${sizeA + borderWidth}`;\n    case \"right\":\n      return `${-borderWidth} 0 ${sizeA} ${sizeB}`;\n    case \"left\":\n      return `0 0 ${sizeA + borderWidth} ${sizeB}`;\n  }\n\n  return \"\";\n}\n\ntype getTrianglePathProps = {\n  sizeA: number;\n  sizeB: number;\n  layerSide: LayerSide;\n  roundness: number;\n  angle: number;\n};\n\nfunction getTrianglePath({\n  sizeA,\n  sizeB,\n  layerSide,\n  roundness,\n  angle\n}: getTrianglePathProps) {\n  const relativeRoundness = (roundness / 10) * sizeA * 2;\n\n  const A =\n    layerSide === \"bottom\"\n      ? `0 ${sizeA}`\n      : layerSide === \"top\"\n      ? `0 0`\n      : layerSide === \"right\"\n      ? `${sizeA} ${sizeB}`\n      : `0 ${sizeB}`;\n\n  const B = `${layerSide === \"bottom\" || layerSide === \"top\" ? \"H\" : \"V\"} ${\n    layerSide === \"bottom\" || layerSide === \"top\" ? sizeB : 0\n  }`;\n\n  const cPoint = sizeB / 2;\n  const c1A = sizeB / 2 + getWidthBasedOnAngle(angle, sizeA / 8);\n  const c1B = sizeA / 8;\n\n  const C =\n    layerSide === \"bottom\"\n      ? `C ${c1A} ${c1B} ${cPoint + relativeRoundness} 0 ${cPoint} 0`\n      : layerSide === \"top\"\n      ? `C ${c1A} ${sizeA - c1B} ${cPoint +\n          relativeRoundness} ${sizeA} ${cPoint} ${sizeA}`\n      : layerSide === \"right\"\n      ? `C ${c1B} ${sizeB - c1A} 0 ${cPoint - relativeRoundness} 0 ${cPoint}`\n      : `C ${sizeA - c1B} ${sizeB - c1A} ${sizeA} ${cPoint -\n          relativeRoundness} ${sizeA} ${cPoint}`;\n\n  const d1A = sizeB / 2 - getWidthBasedOnAngle(angle, sizeA / 8);\n  const d1B = sizeA / 8;\n\n  const D =\n    layerSide === \"bottom\"\n      ? `C ${cPoint - relativeRoundness} 0 ${d1A} ${d1B} ${A}`\n      : layerSide === \"top\"\n      ? `C ${cPoint - relativeRoundness} ${sizeA} ${d1A} ${sizeA - d1B} ${A}`\n      : layerSide === \"right\"\n      ? `C 0 ${cPoint + relativeRoundness} ${d1B} ${sizeB - d1A} ${A}`\n      : `C${sizeA} ${cPoint + relativeRoundness} ${sizeA - d1B} ${sizeB -\n          d1A} ${A}`;\n\n  return `M ${A} ${B} ${C} ${D}`;\n}\n\ntype GetBorderMaskPathProps = {\n  sizeA: number;\n  sizeB: number;\n  borderWidth: number;\n  layerSide: LayerSide;\n  angle: number;\n};\n\nfunction getBorderMaskPath({\n  sizeA,\n  sizeB,\n  borderWidth,\n  layerSide,\n  angle\n}: GetBorderMaskPathProps) {\n  const borderOffset = getWidthBasedOnAngle(angle, borderWidth);\n\n  if (layerSide === \"bottom\" || layerSide === \"top\") {\n    return `M ${borderWidth} ${layerSide === \"bottom\" ? sizeA : 0} H ${sizeB -\n      borderWidth} L ${sizeB - borderWidth - borderOffset} ${\n      layerSide === \"bottom\" ? sizeA - borderWidth : borderWidth\n    } H ${borderOffset + borderWidth} Z`;\n  }\n\n  return `M ${layerSide === \"right\" ? sizeA : 0} ${borderWidth} V ${sizeB -\n    borderWidth} L ${\n    layerSide === \"right\" ? sizeA - borderWidth : borderWidth\n  } ${sizeB - borderWidth - borderOffset} V ${borderOffset + borderWidth} Z`;\n}\n\nexport type ArrowProps = {\n  angle?: number; // angle of triangle -> range(10, 80) | default 45\n  size?: number; // distance in pixels between point of triangle and layer | default 8\n  roundness?: number; // roundness of the point of the arrow -> range(0, 1) | default 0\n  borderWidth?: number; // default 0\n  borderColor?: string; // default \"black\"\n  backgroundColor?: string; // default \"white\"\n  layerSide?: LayerSide;\n  style?: React.CSSProperties;\n};\n\nexport const Arrow = ({\n  size = 8,\n  angle = 45,\n  borderWidth = 0,\n  borderColor = \"black\",\n  roundness = 0,\n  backgroundColor = \"white\",\n  layerSide = \"top\",\n  style = {}\n}: ArrowProps) => {\n  if (layerSide === \"center\") {\n    return null;\n  }\n\n  const sizeA = size;\n  const sizeB = getWidthBasedOnAngle(angle, size) * 2;\n\n  return (\n    <svg\n      style={{\n        ...style,\n        transform: `translate${\n          layerSide === \"left\" || layerSide === \"right\" ? \"Y\" : \"X\"\n        }(-50%)`\n      }}\n      data-arrow=\"true\"\n      width={layerSide === \"left\" || layerSide === \"right\" ? sizeA : sizeB}\n      viewBox={getViewBox(sizeA, sizeB, layerSide, borderWidth)}\n    >\n      <path\n        fill={backgroundColor}\n        strokeWidth={borderWidth}\n        stroke={borderColor}\n        d={getTrianglePath({\n          angle,\n          layerSide,\n          roundness,\n          sizeA,\n          sizeB\n        })}\n      />\n      <path\n        fill={backgroundColor}\n        d={getBorderMaskPath({ sizeA, sizeB, angle, borderWidth, layerSide })}\n      />\n    </svg>\n  );\n}\n\nexport default Arrow;\n","import * as React from \"react\";\nimport { createPortal } from \"react-dom\";\n\nimport { RenderLayer, ToggleLayerOptions, LayerSide } from \"./types\";\nimport {\n  isSet,\n  shouldUpdateStyles,\n  getWindowClientRect,\n  EMPTY_STYLE,\n  getElementFromAnchorNode\n} from \"./util\";\nimport {\n  doesEntireLayerFitWithinScrollParents,\n  isLayerCompletelyInvisible\n} from \"./rect\";\nimport getPositioning, { defaultPlacement } from \"./getPositioning\";\n\nimport useElementState from \"./useElementState\";\nimport useStyleState from \"./useStyleState\";\nimport useTrackElementResize from \"./useTrackElementResize\";\nimport useIsomorphicLayoutEffect from \"./useIsomorphicLayoutEffect\";\nimport useOnWindowResize from \"./useOnWindowResize\";\nimport useOnScroll from \"./useOnScroll\";\nimport useOutsideClick, { OutsideClickGroupProvider } from \"./useOutsideClick\";\n\ntype OpenProps = {\n  clientRect: ClientRect | (() => ClientRect);\n  target: HTMLElement;\n};\n\ntype UseToggleLayerPayload = {\n  open: (props: OpenProps) => void;\n  openFromContextMenuEvent: (event: React.MouseEvent<any, MouseEvent>) => void;\n  openFromMouseEvent: (event: React.MouseEvent<any, MouseEvent>) => void;\n  openFromSelection: (selection: Selection) => void;\n  openFromRef: (ref: React.MutableRefObject<any>) => void;\n  close: () => void;\n  isOpen: boolean;\n  layerSide: LayerSide | null;\n};\n\nexport default function useToggleLayer(\n  renderLayer: RenderLayer,\n  {\n    onStyle,\n    closeOnOutsideClick,\n    closeOnDisappear,\n    fixed,\n    container,\n    placement = {},\n    environment = typeof window !== \"undefined\" ? window : undefined,\n    ...props\n  }: ToggleLayerOptions = {}\n) {\n  /**\n   * Tracks trigger element and keeps it in state together with it's\n   * relative/absolute positioned parent\n   */\n  const [\n    setTargetRef,\n    { relativeParentElement, triggerElement: targetElement, scrollParents },\n    normalTriggerRef\n  ] = useElementState(container, fixed, environment);\n\n  const { styles, setStyles, lastStyles, resetLastStyles } = useStyleState(\n    placement.anchor || defaultPlacement.anchor\n  );\n\n  const layerRef = React.useRef<HTMLElement | null>(null);\n  const triggerRectRef = React.useRef<ClientRect | (() => ClientRect) | null>(\n    null\n  );\n\n  function getTriggerRect() {\n    return typeof triggerRectRef.current! === \"function\"\n      ? triggerRectRef.current()\n      : triggerRectRef.current!;\n  }\n\n  const [isOpen, setOpen] = React.useState(false);\n\n  function close() {\n    triggerRectRef.current = null;\n    setOpen(false);\n  }\n\n  const handlePositioning = React.useCallback(() => {\n    const triggerRect = getTriggerRect();\n\n    if (!triggerRect) {\n      return;\n    }\n\n    const result = getPositioning({\n      triggerRect,\n      layerElement: layerRef.current,\n      placement,\n      relativeParentElement,\n      scrollParents,\n      fixed,\n      environment\n    });\n\n    if (!result) {\n      return;\n    }\n\n    const { layerRect, styles } = result;\n\n    // only update styles when necessary\n    if (shouldUpdateStyles(lastStyles.current, styles)) {\n      // is parent in control of styles? (onStyle)\n      if (isSet(onStyle)) {\n        lastStyles.current = styles;\n        onStyle!(styles.layer, styles.arrow, styles.layerSide);\n      }\n      // ... otherwise set styles internally\n      else {\n        setStyles(styles);\n      }\n    }\n\n    /**\n     * B.\n     * Manage disappearance\n     */\n\n    // Should we respond to the layer's partial or full disappearance?\n    // (trigger's disappearance when `fixed` props is set)\n    if (closeOnDisappear) {\n      const allScrollParents = [\n        ...scrollParents.map(parent => parent.getBoundingClientRect()),\n        getWindowClientRect(environment)\n      ];\n\n      const partial = !doesEntireLayerFitWithinScrollParents(\n        fixed ? triggerRect : layerRect,\n        allScrollParents\n      );\n      const full = isLayerCompletelyInvisible(\n        fixed ? triggerRect : layerRect,\n        allScrollParents\n      );\n\n      if (closeOnDisappear === \"partial\" && partial) {\n        close();\n      }\n      if (closeOnDisappear === \"full\" && full) {\n        close();\n      }\n    }\n  }, [\n    relativeParentElement,\n    isOpen,\n    targetElement,\n    scrollParents,\n    fixed,\n    placement\n  ]);\n\n  // call `handlePositioning` when the layer's / targets's\n  // height and / or width changes\n  const resizeObserver = useTrackElementResize(\n    props.ResizeObserver,\n    layerRef,\n    targetElement,\n    isOpen,\n    handlePositioning,\n    environment\n  );\n\n  // On every render, check a few things...\n  useIsomorphicLayoutEffect(() => {\n    /**\n     * A.\n     * Ignore when render is caused by internal style change\n     */\n    const styleIsSetInterally = !isSet(onStyle);\n    const effectBecauseOfInternalStyleChange = styles !== lastStyles.current;\n\n    if (effectBecauseOfInternalStyleChange && styleIsSetInterally) {\n      lastStyles.current = styles;\n      return;\n    }\n\n    // reset `lastStyles` when closed\n    if (!isOpen) {\n      resetLastStyles();\n      return;\n    }\n\n    /**\n     * B.\n     * Prepare to calculate new layer style\n     */\n\n    handlePositioning();\n  });\n\n  // calculate new layer style when window size changes\n  useOnWindowResize(handlePositioning, environment, isOpen);\n\n  // calculate new layer style when user scrolls\n  useOnScroll(scrollParents, handlePositioning, environment, isOpen);\n\n  const outsideClickRefs = React.useRef(\n    new Set<React.RefObject<HTMLElement | null | undefined>>([\n      layerRef,\n      normalTriggerRef\n    ])\n  );\n\n  // handle clicks that are not originated from the trigger / layer\n  // element\n  useOutsideClick(\n    outsideClickRefs,\n    React.useCallback(() => {\n      if (!isOpen) {\n        return;\n      }\n\n      if (closeOnOutsideClick) {\n        close();\n      }\n    }, [isOpen, setOpen, closeOnOutsideClick])\n  );\n\n  const containerElement =\n    typeof container === \"function\" ? container() : container;\n\n  function open({ clientRect, target }: OpenProps) {\n    triggerRectRef.current = clientRect;\n\n    if (isOpen && target === targetElement) {\n      handlePositioning();\n    } else {\n      setTargetRef(target);\n      setOpen(true);\n    }\n  }\n\n  const payload: UseToggleLayerPayload = {\n    isOpen,\n    close,\n    open,\n    openFromContextMenuEvent: evt => {\n      evt.preventDefault();\n      const target = evt.target as HTMLElement;\n\n      const clientRect: ClientRect = {\n        top: evt.clientY,\n        left: evt.clientX,\n        bottom: evt.clientY + 1,\n        right: evt.clientX + 1,\n        width: 1,\n        height: 1\n      };\n\n      open({ clientRect, target });\n    },\n    openFromMouseEvent: evt => {\n      const currentTarget = evt.currentTarget as HTMLElement;\n\n      if (!currentTarget || !currentTarget.getBoundingClientRect) {\n        return;\n      }\n\n      const clientRect = () => currentTarget.getBoundingClientRect();\n\n      open({ clientRect, target: currentTarget });\n    },\n\n    openFromRef: (ref: React.MutableRefObject<any>) => {\n      if (!ref.current) {\n        console.error(\n          `Error inside useTooltip(): Expected a valid ref to a trigger element, but got ${typeof ref.current}`\n        );\n        return;\n      }\n      open({\n        target: ref.current,\n        clientRect: ref.current!.getBoundingClientRect()\n      });\n    },\n\n    openFromSelection: selection => {\n      if (!selection.anchorNode || selection.isCollapsed) {\n        return;\n      }\n\n      const element = getElementFromAnchorNode(selection.anchorNode);\n\n      if (!element) {\n        return;\n      }\n\n      const range = selection.getRangeAt(0);\n\n      open({\n        clientRect: () => range.getBoundingClientRect(),\n        target: element\n      });\n    },\n\n    layerSide: isOpen ? styles.layerSide : null\n  };\n\n  const element =\n    relativeParentElement &&\n    createPortal(\n      renderLayer({\n        layerProps: {\n          ref: element => {\n            if (element) {\n              // observe the layer for resizing\n              // it's ok to observe the same element multiple times\n              // since multiple observes of same element are ignored\n              resizeObserver.observe(element!);\n            }\n\n            layerRef.current = element;\n          },\n          style: {\n            ...(isSet(onStyle) ? EMPTY_STYLE : styles.layer),\n            position: fixed ? \"fixed\" : \"absolute\",\n            willChange: \"top, bottom, left, right, width, height\"\n          }\n        },\n        arrowStyle: {\n          ...(isSet(onStyle) ? EMPTY_STYLE : styles.arrow),\n          position: \"absolute\",\n          willChange: \"top, bottom, left, right\"\n        },\n        isOpen,\n        layerSide: styles.layerSide,\n        triggerRect: getTriggerRect(),\n        close: () => {\n          close();\n        }\n      }),\n      containerElement || relativeParentElement\n    );\n\n  return [\n    <OutsideClickGroupProvider refs={outsideClickRefs}>\n      {element}\n    </OutsideClickGroupProvider>,\n    payload\n  ] as [React.ReactElement<any>, UseToggleLayerPayload];\n}\n","import * as React from \"react\";\n\nexport interface HoverOptions {\n  delayEnter?: number;\n  delayLeave?: number;\n  hideOnScroll?: boolean;\n}\n\nexport interface CallbackHoverOptions extends HoverOptions {\n  onShow: () => void;\n  onHide?: () => void;\n}\n\nexport type HoverProps = {\n  onMouseEnter: () => void;\n  onMouseLeave: () => void;\n  onTouchStart: () => void;\n  onTouchMove: () => void;\n  onTouchEnd: () => void;\n};\n\ntype TimeoutState = \"entering\" | \"leaving\" | null;\n\nfunction useHover(config?: HoverOptions): readonly [boolean, HoverProps];\nfunction useHover(config?: CallbackHoverOptions): HoverProps;\nfunction useHover(config?: any): any {\n  const {\n    delayEnter = 0,\n    delayLeave = 0,\n    hideOnScroll = true,\n    onShow,\n    onHide\n  } = (config || {}) as CallbackHoverOptions;\n\n  const [show, setShow] = React.useState(false);\n  const timeoutRef = React.useRef<number | null>(null);\n\n  const timeoutState = React.useRef<TimeoutState>(null);\n\n  const hasTouchMoved = React.useRef<boolean>(false);\n\n  function handleShowHide(show: boolean) {\n    if (show) {\n      if (onShow) {\n        onShow();\n      }\n\n      setShow(true);\n      return;\n    }\n\n    if (onHide) {\n      onHide();\n    }\n\n    setShow(false);\n  }\n\n  function onMouseEnter() {\n    // if was leaving, stop leaving\n    if (timeoutState.current === \"leaving\" && timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = null;\n      timeoutState.current = null;\n    }\n\n    if (show) {\n      return;\n    }\n\n    timeoutState.current = \"entering\";\n    timeoutRef.current = setTimeout(() => {\n      handleShowHide(true);\n      timeoutRef.current = null;\n      timeoutState.current = null;\n    }, delayEnter) as any;\n  }\n\n  function onMouseLeave() {\n    // if was waiting for entering,\n    // clear timeout\n    if (timeoutState.current === \"entering\" && timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = null;\n    }\n\n    if (!show) {\n      return;\n    }\n\n    timeoutState.current = \"leaving\";\n    timeoutRef.current = setTimeout(() => {\n      handleShowHide(false);\n      timeoutRef.current = null;\n    }, delayLeave) as any;\n  }\n\n  // make sure to clear timeout on unmount\n  React.useEffect(() => {\n    const to = timeoutRef.current;\n\n    function clear() {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n        timeoutRef.current = null;\n      }\n    }\n\n    function onScroll() {\n      if (show && hideOnScroll) {\n        clear();\n        handleShowHide(false);\n      }\n    }\n\n    function onTouchEnd() {\n      if (show) {\n        clear();\n        handleShowHide(false);\n      }\n    }\n\n    window.addEventListener(\"scroll\", onScroll, true);\n    window.addEventListener(\"touchend\", onTouchEnd, true);\n\n    return () => {\n      window.removeEventListener(\"scroll\", onScroll, true);\n      window.removeEventListener(\"touchend\", onTouchEnd, true);\n\n      if (to) {\n        clearTimeout(to);\n      }\n    };\n  }, [show, hideOnScroll]);\n\n  const hoverProps: HoverProps = {\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart: () => {\n      hasTouchMoved.current = false;\n    },\n    onTouchMove: () => {\n      hasTouchMoved.current = true;\n    },\n    onTouchEnd: () => {\n      if (!hasTouchMoved.current && !show) {\n        handleShowHide(true);\n      }\n\n      hasTouchMoved.current = false;\n    }\n  };\n\n  // @ts-ignore\n  if (onShow) {\n    return hoverProps;\n  }\n\n  return [show, hoverProps] as const;\n}\n\nexport default useHover;\n","import * as React from \"react\";\n\nexport default function useBreakpoint(maxPixels: number) {\n  const [match, setMatch] = React.useState(\n    typeof window !== \"undefined\"\n      ? window.matchMedia(`(max-width: ${maxPixels}px)`).matches\n      : false\n  );\n\n  React.useEffect(() => {\n    const matcher = window.matchMedia(`(max-width: ${maxPixels}px)`);\n\n    function onMatch(evt: MediaQueryListEvent) {\n      setMatch(evt.matches);\n    }\n\n    matcher.addListener(onMatch);\n\n    return () => {\n      matcher.removeListener(onMatch);\n    };\n  }, [maxPixels]);\n\n  return match;\n}\n","import * as React from \"react\";\n\nexport type TransitionProps = {\n  isOpen: boolean;\n  children: (\n    isOpen: boolean,\n    onTransitionEnd: any,\n    isLeaving: boolean\n  ) => React.ReactElement;\n};\n\nexport default function Transition({\n  isOpen: isOpenExternal,\n  children\n}: TransitionProps) {\n  const [state, setState] = React.useState({\n    isOpenInternal: isOpenExternal,\n    isLeaving: false\n  });\n\n  const didMount = React.useRef(false);\n\n  React.useEffect(() => {\n    if (isOpenExternal) {\n      setState({\n        isOpenInternal: true,\n        isLeaving: false\n      });\n    } else if (didMount.current) {\n      setState({\n        isOpenInternal: false,\n        isLeaving: true\n      });\n    }\n  }, [isOpenExternal, setState]);\n\n  React.useEffect(() => {\n    didMount.current = true;\n  }, []);\n\n  if (!isOpenExternal && !state.isOpenInternal && !state.isLeaving) {\n    return null;\n  }\n\n  return children(\n    state.isOpenInternal,\n    () => {\n      if (!state.isOpenInternal) {\n        setState(s => ({ ...s, isLeaving: false }));\n      }\n    },\n    state.isLeaving\n  );\n}\n","import * as React from \"react\";\n\nimport useHover, { HoverOptions } from \"./useHover\";\nimport useToggleLayer from \"./ToggleLayer/useToggleLayer\";\nimport { ToggleLayerOptions, RenderLayer } from \"./ToggleLayer/types\";\n\nexport type TooltipOptions = HoverOptions & ToggleLayerOptions;\n\nexport default function useTooltip(\n  renderLayer: RenderLayer,\n  { delayEnter, delayLeave, hideOnScroll, ...rest }: TooltipOptions = {}\n) {\n  const triggerRef = React.useRef<any>();\n\n  const [element, { openFromRef, close }] = useToggleLayer(renderLayer, rest);\n\n  const hoverProps = useHover({\n    delayEnter,\n    delayLeave,\n    hideOnScroll,\n    onShow: () => openFromRef(triggerRef),\n    onHide: close\n  });\n\n  const triggerProps = {\n    ref: triggerRef,\n    ...hoverProps\n  };\n\n  return [element, triggerProps] as const;\n}\n"]},"metadata":{},"sourceType":"module"}